{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"datamodel-code-generator","text":"<p>This code generator creates pydantic v1 and v2 model, dataclasses.dataclass, typing.TypedDict and msgspec.Struct from an openapi file and others.</p> <p> </p>","path":["datamodel-code-generator"],"tags":[]},{"location":"#quick-installation","level":2,"title":"Quick Installation","text":"<p>To install <code>datamodel-code-generator</code>: <pre><code>$ pip install datamodel-code-generator\n</code></pre></p>","path":["datamodel-code-generator"],"tags":[]},{"location":"#simple-usage","level":2,"title":"Simple Usage","text":"<p>You can generate models from a local file. <pre><code>$ datamodel-codegen --input api.yaml --output model.py\n</code></pre></p> api.yaml <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Error:\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n</code></pre> model.py <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2020-06-02T05:28:24+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n</code></pre>","path":["datamodel-code-generator"],"tags":[]},{"location":"#supported-input-types","level":2,"title":"Supported input types","text":"<ul> <li>OpenAPI 3 (YAML/JSON, OpenAPI Data Type);</li> <li>JSON Schema (JSON Schema Core/JSON Schema Validation);</li> <li>JSON/YAML/CSV Data (it will be converted to JSON Schema);</li> <li>Python dictionary (it will be converted to JSON Schema);</li> <li>GraphQL schema (GraphQL Schemas and Types);</li> </ul>","path":["datamodel-code-generator"],"tags":[]},{"location":"#supported-output-types","level":2,"title":"Supported output types","text":"<ul> <li>pydantic.BaseModel;</li> <li>pydantic_v2.BaseModel;</li> <li>dataclasses.dataclass;</li> <li>typing.TypedDict;</li> <li>msgspec.Struct;</li> <li>Custom type from your jinja2 template;</li> </ul>","path":["datamodel-code-generator"],"tags":[]},{"location":"#sponsors","level":2,"title":"Sponsors","text":"<p>Astral</p>","path":["datamodel-code-generator"],"tags":[]},{"location":"#projects-that-use-datamodel-code-generator","level":2,"title":"Projects that use datamodel-code-generator","text":"<p>These OSS projects use datamodel-code-generator to generate many models.  See the following linked projects for real world examples and inspiration.</p> <ul> <li>airbytehq/airbyte<ul> <li>code-generator/Dockerfile</li> </ul> </li> <li>apache/iceberg<ul> <li>Generate Python code <code>make generate</code></li> </ul> </li> <li>argoproj-labs/hera<ul> <li><code>Makefile</code></li> </ul> </li> <li>awslabs/aws-lambda-powertools-python<ul> <li>Recommended for advanced-use-cases in the official documentation</li> </ul> </li> <li>DataDog/integrations-core<ul> <li>Config models</li> </ul> </li> <li>hashintel/hash<ul> <li><code>codegen.sh</code></li> </ul> </li> <li>IBM/compliance-trestle<ul> <li>Building the models from the OSCAL schemas.</li> </ul> </li> <li>Netflix/consoleme<ul> <li>How do I generate models from the Swagger specification?</li> </ul> </li> <li>Nike-Inc/brickflow<ul> <li>Code generate tools<code>./tools/gen-bundle.sh</code></li> </ul> </li> <li>open-metadata/OpenMetadata<ul> <li>Makefile</li> </ul> </li> <li>PostHog/posthog<ul> <li>Generate models via <code>npm run</code> </li> </ul> </li> <li>SeldonIO/MLServer<ul> <li>generate-types.sh</li> </ul> </li> </ul>","path":["datamodel-code-generator"],"tags":[]},{"location":"#installation","level":2,"title":"Installation","text":"<p>To install <code>datamodel-code-generator</code>: <pre><code>$ pip install datamodel-code-generator\n</code></pre></p>","path":["datamodel-code-generator"],"tags":[]},{"location":"#http-extra-option","level":3,"title":"<code>http</code> extra option","text":"<p>If you want to resolve <code>$ref</code> for remote files then you should specify <code>http</code> extra option. <pre><code>$ pip install 'datamodel-code-generator[http]'\n</code></pre></p>","path":["datamodel-code-generator"],"tags":[]},{"location":"#graphql-extra-option","level":3,"title":"<code>graphql</code> extra option","text":"<p>If you want to generate data model from a GraphQL schema then you should specify <code>graphql</code> extra option. <pre><code>$ pip install 'datamodel-code-generator[graphql]'\n</code></pre></p>","path":["datamodel-code-generator"],"tags":[]},{"location":"#docker-image","level":3,"title":"Docker Image","text":"<p>The docker image is in Docker Hub <pre><code>$ docker pull koxudaxi/datamodel-code-generator\n</code></pre></p>","path":["datamodel-code-generator"],"tags":[]},{"location":"#advanced-uses","level":2,"title":"Advanced Uses","text":"<p>You can generate models from a URL. <pre><code>$ datamodel-codegen --url https://&lt;INPUT FILE URL&gt; --output model.py\n</code></pre> This method needs the http extra option</p>","path":["datamodel-code-generator"],"tags":[]},{"location":"#all-command-options","level":2,"title":"All Command Options","text":"<p>See detailed CLI Reference →</p> <p>The <code>datamodel-codegen</code> command:</p> <pre><code>usage: \n  datamodel-codegen [options]\n\nGenerate Python data models from schema definitions or structured data\n\nOptions:\n  --additional-imports ADDITIONAL_IMPORTS\n                        Custom imports for output (delimited list input). For example\n                        \"datetime.date,datetime.datetime\"\n  --custom-formatters CUSTOM_FORMATTERS\n                        List of modules with custom formatter (delimited list input).\n  --formatters {black,isort,ruff-check,ruff-format} [{black,isort,ruff-check,ruff-format} ...]\n                        Formatters for output (default: [black, isort])\n  --http-headers HTTP_HEADER [HTTP_HEADER ...]\n                        Set headers in HTTP requests to the remote host. (example:\n                        \"Authorization: Basic dXNlcjpwYXNz\")\n  --http-ignore-tls     Disable verification of the remote host''s TLS certificate\n  --http-query-parameters HTTP_QUERY_PARAMETERS [HTTP_QUERY_PARAMETERS ...]\n                        Set query parameters in HTTP requests to the remote host. (example:\n                        \"ref=branch\")\n  --input INPUT         Input file/directory (default: stdin)\n  --input-file-type {auto,openapi,jsonschema,json,yaml,dict,csv,graphql}\n                        Input file type (default: auto)\n  --output OUTPUT       Output file (default: stdout)\n  --output-model-type {pydantic.BaseModel,pydantic_v2.BaseModel,dataclasses.dataclass,typing.TypedDict,msgspec.Struct}\n                        Output model type (default: pydantic.BaseModel)\n  --url URL             Input file URL. `--input` is ignored when `--url` is used\n\nTyping customization:\n  --allof-merge-mode {constraints,all,none}\n                        Mode for field merging in allOf schemas. ''constraints'': merge only\n                        constraints (minItems, maxItems, pattern, etc.) from parent\n                        (default). ''all'': merge constraints plus annotations (default,\n                        examples) from parent. ''none'': do not merge any fields from parent\n                        properties.\n  --base-class BASE_CLASS\n                        Base Class (default: pydantic.BaseModel)\n  --disable-future-imports\n                        Disable __future__ imports\n  --enum-field-as-literal {all,one}\n                        Parse enum field as literal. all: all enum field type are Literal.\n                        one: field type is Literal when an enum has only one possible value\n  --field-constraints   Use field constraints and not con* annotations\n  --set-default-enum-member\n                        Set enum members as default values for enum field\n  --strict-types {str,bytes,int,float,bool} [{str,bytes,int,float,bool} ...]\n                        Use strict types\n  --type-mappings TYPE_MAPPINGS [TYPE_MAPPINGS ...]\n                        Override default type mappings. Format: \"type+format=target\" (e.g.,\n                        \"string+binary=string\" to map binary format to string type) or\n                        \"format=target\" (e.g., \"binary=string\"). Can be specified multiple\n                        times.\n  --use-annotated       Use typing.Annotated for Field(). Also, `--field-constraints` option\n                        will be enabled.\n  --use-decimal-for-multiple-of\n                        Use condecimal instead of confloat for float/number fields with\n                        multipleOf constraint (Pydantic only). Avoids floating-point\n                        precision issues in validation.\n  --use-enum-values-in-discriminator\n                        Use enum member literals in discriminator fields instead of string\n                        literals\n  --use-generic-container-types\n                        Use generic container types for type hinting (typing.Sequence,\n                        typing.Mapping). If `--use-standard-collections` option is set, then\n                        import from collections.abc instead of typing\n  --use-non-positive-negative-number-constrained-types\n                        Use the Non{Positive,Negative}{FloatInt} types instead of the\n                        corresponding con* constrained types.\n  --use-one-literal-as-default\n                        Use one literal as default value for one literal field\n  --use-serialize-as-any\n                        Use pydantic.SerializeAsAny for fields with types that have subtypes\n                        (Pydantic v2 only)\n  --use-specialized-enum, --no-use-specialized-enum\n                        Use specialized Enum class (StrEnum, IntEnum). Requires --target-\n                        python-version 3.11+\n  --use-standard-collections\n                        Use standard collections for type hinting (list, dict)\n  --use-subclass-enum   Define generic Enum class as subclass with field type when enum has\n                        type (int, float, bytes, str)\n  --use-type-alias      Use TypeAlias instead of root models (experimental)\n  --use-union-operator  Use | operator for Union type (PEP 604).\n  --use-unique-items-as-set\n                        define field type as `set` when the field attribute has\n                        `uniqueItems`\n\nField customization:\n  --capitalise-enum-members, --capitalize-enum-members\n                        Capitalize field names on enum\n  --empty-enum-field-name EMPTY_ENUM_FIELD_NAME\n                        Set field name when enum value is empty (default: `_`)\n  --field-extra-keys FIELD_EXTRA_KEYS [FIELD_EXTRA_KEYS ...]\n                        Add extra keys to field parameters\n  --field-extra-keys-without-x-prefix FIELD_EXTRA_KEYS_WITHOUT_X_PREFIX [FIELD_EXTRA_KEYS_WITHOUT_X_PREFIX ...]\n                        Add extra keys with `x-` prefix to field parameters. The extra keys\n                        are stripped of the `x-` prefix.\n  --field-include-all-keys\n                        Add all keys to field parameters\n  --force-optional      Force optional for required fields\n  --no-alias            Do not add a field alias. E.g., if --snake-case-field is used along\n                        with a base class, which has an alias_generator\n  --original-field-name-delimiter ORIGINAL_FIELD_NAME_DELIMITER\n                        Set delimiter to convert to snake case. This option only can be used\n                        with --snake-case-field (default: `_` )\n  --remove-special-field-name-prefix\n                        Remove field name prefix if it has a special meaning e.g.\n                        underscores\n  --snake-case-field    Change camel-case field name to snake-case\n  --special-field-name-prefix SPECIAL_FIELD_NAME_PREFIX\n                        Set field name prefix when first character can''t be used as Python\n                        field name (default: `field`)\n  --strip-default-none  Strip default None on fields\n  --union-mode {smart,left_to_right}\n                        Union mode for only pydantic v2 field\n  --use-attribute-docstrings\n                        Set use_attribute_docstrings=True in Pydantic v2 ConfigDict\n  --use-default         Use default value even if a field is required\n  --use-default-kwarg   Use `default=` instead of a positional argument for Fields that have\n                        default values.\n  --use-field-description\n                        Use schema description to populate field docstring\n  --use-frozen-field    Use Field(frozen=True) for readOnly fields (Pydantic v2) or\n                        Field(allow_mutation=False) (Pydantic v1)\n  --use-inline-field-description\n                        Use schema description to populate field docstring as inline\n                        docstring\n\nModel customization:\n  --all-exports-collision-strategy {error,minimal-prefix,full-prefix}\n                        Strategy for name collisions when using --all-exports-\n                        scope=recursive. ''error'': raise an error (default). ''minimal-\n                        prefix'': add module prefix only to colliding names. ''full-prefix'':\n                        add full module path prefix to colliding names.\n  --all-exports-scope {children,recursive}\n                        Generate __all__ in __init__.py with re-exports. ''children'': export\n                        from direct child modules only. ''recursive'': export from all\n                        descendant modules.\n  --allow-extra-fields  Deprecated: Allow passing extra fields. This flag is deprecated. Use\n                        `--extra-fields=allow` instead.\n  --allow-population-by-field-name\n                        Allow population by field name\n  --class-name CLASS_NAME\n                        Set class name of root model\n  --collapse-root-models\n                        Models generated with a root-type field will be merged into the\n                        models using that root-type model\n  --dataclass-arguments DATACLASS_ARGUMENTS\n                        Custom dataclass arguments as a JSON dictionary, e.g. ''{\"frozen\":\n                        true, \"kw_only\": true}''. Overrides --frozen-dataclasses and similar\n                        flags.\n  --disable-appending-item-suffix\n                        Disable appending `Item` suffix to model name in an array\n  --disable-timestamp   Disable timestamp on file headers\n  --enable-faux-immutability\n                        Enable faux immutability\n  --enable-version-header\n                        Enable package version on file headers\n  --extra-fields {allow,ignore,forbid}\n                        Set the generated models to allow, forbid, or ignore extra fields.\n  --frozen-dataclasses  Generate frozen dataclasses (dataclass(frozen=True)). Only applies\n                        to dataclass output.\n  --keep-model-order    Keep generated models'' order\n  --keyword-only        Defined models as keyword only (for example\n                        dataclass(kw_only=True)).\n  --output-datetime-class {datetime,AwareDatetime,NaiveDatetime}\n                        Choose Datetime class between AwareDatetime, NaiveDatetime or\n                        datetime. Each output model has its default mapping (for example\n                        pydantic: datetime, dataclass: str, ...)\n  --parent-scoped-naming\n                        Set name of models defined inline from the parent model\n  --reuse-model         Reuse models on the field when a module has the model with the same\n                        content\n  --reuse-scope {module,tree}\n                        Scope for model reuse deduplication: module (per-file, default) or\n                        tree (cross-file with shared module). Only effective when --reuse-\n                        model is set.\n  --shared-module-name SHARED_MODULE_NAME\n                        Name of the shared module for --reuse-scope=tree (default:\n                        \"shared\"). Use this option if your schema has a file named \"shared\".\n  --skip-root-model     Skip generating the model for the root schema element\n  --target-python-version {3.9,3.10,3.11,3.12,3.13,3.14}\n                        target python version\n  --treat-dot-as-module\n                        treat dotted module names as modules\n  --use-exact-imports   import exact types instead of modules, for example: \"from .foo\n                        import Bar\" instead of \"from . import foo\" with \"foo.Bar\"\n  --use-pendulum        use pendulum instead of datetime\n  --use-schema-description\n                        Use schema description to populate class docstring\n  --use-title-as-name   use titles as class names of models\n\nTemplate customization:\n  --aliases ALIASES     Alias mapping file (JSON) for renaming fields. Supports hierarchical\n                        formats: Flat: {''field'': ''alias''} applies to all occurrences.\n                        Scoped: {''ClassName.field'': ''alias''} applies to specific class.\n                        Priority: scoped &gt; flat. Example: {''User.name'': ''user_name'',\n                        ''Address.name'': ''addr_name'', ''id'': ''id_''}\n  --custom-file-header CUSTOM_FILE_HEADER\n                        Custom file header\n  --custom-file-header-path CUSTOM_FILE_HEADER_PATH\n                        Custom file header file path\n  --custom-formatters-kwargs CUSTOM_FORMATTERS_KWARGS\n                        A file with kwargs for custom formatters.\n  --custom-template-dir CUSTOM_TEMPLATE_DIR\n                        Custom template directory\n  --encoding ENCODING   The encoding of input and output (default: utf-8)\n  --extra-template-data EXTRA_TEMPLATE_DATA\n                        Extra template data for output models. Input is supposed to be a\n                        json/yaml file. For OpenAPI and Jsonschema the keys are the spec\n                        path of the object, or the name of the object if you want to apply\n                        the template data to multiple objects with the same name. If you are\n                        using another input file type (e.g. GraphQL), the key is the name of\n                        the object. The value is a dictionary of the template data to add.\n  --use-double-quotes   Model generated with double quotes. Single quotes or your black\n                        config skip_string_normalization value will be used without this\n                        option.\n  --wrap-string-literal\n                        Wrap string literal by using black `experimental-string-processing`\n                        option (require black 20.8b0 or later)\n\nOpenAPI-only options:\n  --include-path-parameters\n                        Include path parameters in generated parameter models in addition to\n                        query parameters (Only OpenAPI)\n  --openapi-scopes {schemas,paths,tags,parameters,webhooks} [{schemas,paths,tags,parameters,webhooks} ...]\n                        Scopes of OpenAPI model generation (default: schemas)\n  --read-only-write-only-model-type {request-response,all}\n                        Model generation for readOnly/writeOnly fields: ''request-response'' =\n                        Request/Response models only (no base model), ''all'' = Base + Request\n                        + Response models.\n  --strict-nullable     Treat default field as a non-nullable field (Only OpenAPI)\n  --use-operation-id-as-name\n                        use operation id of OpenAPI as class names of models\n  --validation          Deprecated: Enable validation (Only OpenAPI). this option is\n                        deprecated. it will be removed in future releases\n\nGeneral options:\n  --check               Verify generated files are up-to-date without modifying them. Exits\n                        with code 1 if differences found, 0 if up-to-date. Useful for CI to\n                        ensure generated code is committed.\n  --debug               show debug message (require \"debug\". `$ pip install ''datamodel-code-\n                        generator[debug]''`)\n  --disable-warnings    disable warnings\n  --generate-cli-command\n                        Generate CLI command from pyproject.toml configuration and exit\n  --generate-pyproject-config\n                        Generate pyproject.toml configuration from the provided CLI\n                        arguments and exit\n  --ignore-pyproject    Ignore pyproject.toml configuration\n  --no-color            disable colorized output\n  --profile PROFILE     Use a named profile from pyproject.toml [tool.datamodel-\n                        codegen.profiles.&lt;name&gt;]\n  --version             show version\n  -h, --help            show this help message and exit\n</code></pre> <p>See supported input formats →</p>","path":["datamodel-code-generator"],"tags":[]},{"location":"#related-projects","level":2,"title":"Related projects","text":"","path":["datamodel-code-generator"],"tags":[]},{"location":"#fastapi-code-generator","level":3,"title":"fastapi-code-generator","text":"<p>This code generator creates FastAPI app from an openapi file.</p> <p>https://github.com/koxudaxi/fastapi-code-generator</p>","path":["datamodel-code-generator"],"tags":[]},{"location":"#pydantic-pycharm-plugin","level":3,"title":"pydantic-pycharm-plugin","text":"<p>A JetBrains PyCharm plugin for <code>pydantic</code>.</p> <p>https://github.com/koxudaxi/pydantic-pycharm-plugin</p>","path":["datamodel-code-generator"],"tags":[]},{"location":"#pypi","level":2,"title":"PyPi","text":"<p>https://pypi.org/project/datamodel-code-generator</p>","path":["datamodel-code-generator"],"tags":[]},{"location":"#license","level":2,"title":"License","text":"<p>datamodel-code-generator is released under the MIT License. http://www.opensource.org/licenses/mit-license</p>","path":["datamodel-code-generator"],"tags":[]},{"location":"aliases/","level":1,"title":"Field Aliases","text":"<p>The <code>--aliases</code> option allows you to rename fields in the generated models. This is useful when you want to use different Python field names than those defined in the schema while preserving the original names as serialization aliases.</p>","path":["Field Aliases"],"tags":[]},{"location":"aliases/#basic-usage","level":2,"title":"Basic Usage","text":"<pre><code>datamodel-codegen --input schema.json --output model.py --aliases aliases.json\n</code></pre>","path":["Field Aliases"],"tags":[]},{"location":"aliases/#alias-file-format","level":2,"title":"Alias File Format","text":"<p>The alias file is a JSON file that maps original field names to their Python aliases.</p>","path":["Field Aliases"],"tags":[]},{"location":"aliases/#flat-format-traditional","level":3,"title":"Flat Format (Traditional)","text":"<p>The simplest format applies aliases to all fields with the matching name, regardless of which class they belong to:</p> <pre><code>{\n  \"id\": \"id_\",\n  \"type\": \"type_\",\n  \"class\": \"class_\"\n}\n</code></pre> <p>This will rename all fields named <code>id</code> to <code>id_</code>, all fields named <code>type</code> to <code>type_</code>, etc.</p>","path":["Field Aliases"],"tags":[]},{"location":"aliases/#scoped-format-class-specific","level":3,"title":"Scoped Format (Class-Specific)","text":"<p>When you have the same field name in multiple classes but want different aliases for each, use the scoped format with <code>ClassName.field</code>:</p> <pre><code>{\n  \"User.name\": \"user_name\",\n  \"Address.name\": \"address_name\",\n  \"name\": \"default_name\"\n}\n</code></pre> <p>Priority: Scoped aliases take priority over flat aliases. In the example above: - <code>User.name</code> will be renamed to <code>user_name</code> - <code>Address.name</code> will be renamed to <code>address_name</code> - Any other class with a <code>name</code> field will use <code>default_name</code></p>","path":["Field Aliases"],"tags":[]},{"location":"aliases/#example","level":2,"title":"Example","text":"","path":["Field Aliases"],"tags":[]},{"location":"aliases/#input-schema","level":3,"title":"Input Schema","text":"<pre><code>{\n  \"type\": \"object\",\n  \"title\": \"Root\",\n  \"properties\": {\n    \"name\": {\"type\": \"string\"},\n    \"user\": {\n      \"type\": \"object\",\n      \"title\": \"User\",\n      \"properties\": {\n        \"name\": {\"type\": \"string\"},\n        \"id\": {\"type\": \"integer\"}\n      }\n    },\n    \"address\": {\n      \"type\": \"object\",\n      \"title\": \"Address\",\n      \"properties\": {\n        \"name\": {\"type\": \"string\"},\n        \"city\": {\"type\": \"string\"}\n      }\n    }\n  }\n}\n</code></pre>","path":["Field Aliases"],"tags":[]},{"location":"aliases/#alias-file","level":3,"title":"Alias File","text":"<pre><code>{\n  \"Root.name\": \"root_name\",\n  \"User.name\": \"user_name\",\n  \"Address.name\": \"address_name\"\n}\n</code></pre>","path":["Field Aliases"],"tags":[]},{"location":"aliases/#generated-output","level":3,"title":"Generated Output","text":"<pre><code>from pydantic import BaseModel, Field\n\nclass User(BaseModel):\n    user_name: str | None = Field(None, alias='name')\n    id: int | None = None\n\nclass Address(BaseModel):\n    address_name: str | None = Field(None, alias='name')\n    city: str | None = None\n\nclass Root(BaseModel):\n    root_name: str | None = Field(None, alias='name')\n    user: User | None = None\n    address: Address | None = None\n</code></pre>","path":["Field Aliases"],"tags":[]},{"location":"aliases/#notes","level":2,"title":"Notes","text":"<ul> <li>The <code>ClassName</code> in scoped format must match the generated Python class name (after title conversion)</li> <li>When using <code>--use-title-as-name</code>, the class name is derived from the <code>title</code> property in the schema</li> <li>Aliases are applied during code generation, so the original field names are preserved as Pydantic <code>alias</code> values for proper serialization/deserialization</li> </ul>","path":["Field Aliases"],"tags":[]},{"location":"aliases/#see-also","level":2,"title":"See Also","text":"<ul> <li>CLI Reference: <code>--aliases</code> - Detailed CLI option documentation with examples</li> </ul>","path":["Field Aliases"],"tags":[]},{"location":"custom-formatters/","level":1,"title":"Custom Code Formatters","text":"<p>New features of the <code>datamodel-code-generator</code> it is custom code formatters.</p>","path":["Usage","Custom Code Formatters"],"tags":[]},{"location":"custom-formatters/#usage","level":2,"title":"Usage","text":"<p>To use the <code>--custom-formatters</code> option, you'll need to pass the module with your formatter. For example</p> <p>your_module.py <pre><code>from datamodel_code_generator.format import CustomCodeFormatter\n\nclass CodeFormatter(CustomCodeFormatter):\n    def apply(self, code: str) -&gt; str:\n        # processed code\n        return ...       \n</code></pre></p> <p>and run the following command</p> <pre><code>$ datamodel-codegen --input {your_input_file} --output {your_output_file} --custom-formatters \"{path_to_your_module}.your_module\"\n</code></pre>","path":["Usage","Custom Code Formatters"],"tags":[]},{"location":"custom-formatters/#see-also","level":2,"title":"See Also","text":"<ul> <li>CLI Reference: <code>--custom-formatters</code> - Detailed CLI option documentation</li> <li>CLI Reference: <code>--custom-formatters-kwargs</code> - Pass arguments to custom formatters</li> <li>Formatting - Built-in code formatting with black and isort</li> </ul>","path":["Usage","Custom Code Formatters"],"tags":[]},{"location":"custom_template/","level":1,"title":"Custom Templates","text":"<p>One of the powerful features of the <code>datamodel-code-generator</code> is the ability to use custom templates with the <code>--custom-template-dir</code> option. This option allows you to provide a directory containing Jinja2 templates for customizing the generated code. In this document, we'll explore how to use this option and provide an example to help you understand its usage.</p>","path":["Usage","Custom Templates"],"tags":[]},{"location":"custom_template/#usage","level":2,"title":"Usage","text":"<p>To use the <code>--custom-template-dir</code> option, you'll need to pass the directory path containing your custom templates as an argument. The command will look like this:</p> <p><pre><code>$ datamodel-codegen --input {your_input_file} --output {your_output_file} --custom-template-dir {your_custom_template_directory}\n</code></pre> Replace {your_input_file}, {your_output_file}, and {your_custom_template_directory} with the appropriate paths.</p>","path":["Usage","Custom Templates"],"tags":[]},{"location":"custom_template/#example","level":2,"title":"Example","text":"<p>Let's say you want to generate a custom Python data model from a JSON Schema file called person.json. You want the generated data model to include a custom comment at the top of the file. To achieve this, you can create a custom template using Jinja2.</p> <p>First, create a directory called <code>custom_templates</code> in your project directory. Inside this folder, create another folder called pydantic. Now, inside the <code>pydantic</code> folder, create a new file called <code>BaseModel.jinja2</code> with the following content:</p> <p>custom_templates/pydantic/BaseModel.jinja2 <pre><code># This is a custom comment generated with custom_template!!\n\nclass {{ class_name }}({{ base_class }}):\n{%- for field in fields %}\n    {{ field.name }}: {{ field.type_hint }}\n{%- endfor -%}\n</code></pre></p> <p>This custom template includes the custom comment at the top and replicates the default rendering behavior of the BaseModel.jinja2 template from the Datamodel Code Generator.</p> <p>Now, you can use the --custom-template-dir option to generate the data model with your custom template: <pre><code>$ datamodel-codegen --input person.json --output person.py --custom-template-dir custom_templates\n</code></pre></p> <p>The generated <code>person.py</code> file will now include your custom comment at the top:</p> <p>person.py <pre><code># generated by datamodel-codegen:\n#   filename:  person.json\n#   timestamp: 2023-04-09T05:36:24+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n# This is a custom comment generated with custom_template!!\n\n\nclass Model(BaseModel):\n    name: Optional[str]\n    age: Optional[int]\n</code></pre></p> <p>In this example, we kept it simple, but you can create more complex custom templates by copying the default templates Use the default templates as a reference for understanding the structure and available variables, and customize the code generation process according to your specific requirements.</p>","path":["Usage","Custom Templates"],"tags":[]},{"location":"custom_template/#see-also","level":2,"title":"See Also","text":"<ul> <li>CLI Reference: <code>--custom-template-dir</code> - Detailed CLI option documentation</li> <li>CLI Reference: <code>--extra-template-data</code> - Pass custom variables to templates</li> </ul>","path":["Usage","Custom Templates"],"tags":[]},{"location":"development-contributing/","level":1,"title":"Development","text":"<p>Install the package in editable mode:</p> <pre><code>$ git clone git@github.com:koxudaxi/datamodel-code-generator.git\n$ pip install -e datamodel-code-generator\n</code></pre>","path":["Development"],"tags":[]},{"location":"development-contributing/#contribute","level":1,"title":"Contribute","text":"<p>We are waiting for your contributions to <code>datamodel-code-generator</code>.</p>","path":["Development"],"tags":[]},{"location":"development-contributing/#how-to-contribute","level":2,"title":"How to contribute","text":"<pre><code>## 1. Clone your fork repository\n$ git clone git@github.com:&lt;your username&gt;/datamodel-code-generator.git\n$ cd datamodel-code-generator\n\n## 2. Install [uv](https://docs.astral.sh/uv/getting-started/installation/)\n$ curl -LsSf https://astral.sh/uv/install.sh | sh\n\n## 3. Install tox with uv\n$ uv tool install --python-preference only-managed --python 3.13 tox --with tox-uv\n\n## 4. Create developer environment\n$ tox run -e dev\n\n.tox/dev is a Python environment you can use for development purposes\n\n## 5. Create new branch and rewrite code.\n$ git checkout -b new-branch\n\n## 6. Run unittest under Python 3.13 (you should pass all test and coverage should be 100%)\n$ tox run -e 3.13\n\n## 7. Format and lint code (will print errors that cannot be automatically fixed)\n$ tox run -e fix\n\n## 8. Check README help text is up to date\n$ tox run -e readme\n\n## 9. Check CLI documentation is up to date\n$ tox run -e cli-docs\n\n## 10. Commit and Push...\n</code></pre>","path":["Development"],"tags":[]},{"location":"development-contributing/#adding-a-new-cli-option","level":2,"title":"Adding a New CLI Option","text":"<p>When adding a new CLI option to <code>datamodel-code-generator</code>, follow these steps:</p>","path":["Development"],"tags":[]},{"location":"development-contributing/#step-1-implement-the-option-required","level":3,"title":"Step 1: Implement the option (Required)","text":"<p>Add the option to <code>src/datamodel_code_generator/arguments.py</code>:</p> <pre><code>arg_parser.add_argument(\n    \"--my-new-option\",\n    help=\"Description of what this option does\",\n    action=\"store_true\",  # or other action type\n)\n</code></pre>","path":["Development"],"tags":[]},{"location":"development-contributing/#step-2-add-a-test-with-documentation-marker-required","level":3,"title":"Step 2: Add a test with documentation marker (Required)","text":"<p>Create a test that demonstrates the option and add the <code>@pytest.mark.cli_doc()</code> marker:</p> <pre><code>@pytest.mark.cli_doc(\n    options=[\"--my-new-option\"],\n    input_schema=\"jsonschema/example.json\",  # Path relative to tests/data/\n    cli_args=[\"--my-new-option\"],\n    golden_output=\"jsonschema/example_with_my_option.py\",  # Expected output\n)\ndef test_my_new_option(output_file: Path) -&gt; None:\n    \"\"\"Short description of what the option does.\n\n    This docstring becomes the documentation for the option.\n    Explain when and why users would use this option.\n    \"\"\"\n    run_main_and_assert(\n        input_path=JSON_SCHEMA_DATA_PATH / \"example.json\",\n        output_path=output_file,\n        extra_args=[\"--my-new-option\"],\n        ...\n    )\n</code></pre>","path":["Development"],"tags":[]},{"location":"development-contributing/#step-3-categorize-the-option-optional","level":3,"title":"Step 3: Categorize the option (Optional)","text":"<p>By default, new options appear in \"General Options\". To place in a specific category, add to <code>src/datamodel_code_generator/cli_options.py</code>:</p> <pre><code>CLI_OPTION_META: dict[str, CLIOptionMeta] = {\n    ...\n    \"--my-new-option\": CLIOptionMeta(\n        name=\"--my-new-option\",\n        category=OptionCategory.MODEL,  # or FIELD, TYPING, TEMPLATE, etc.\n    ),\n}\n</code></pre>","path":["Development"],"tags":[]},{"location":"development-contributing/#step-4-generate-and-verify-documentation","level":3,"title":"Step 4: Generate and verify documentation","text":"<pre><code># Regenerate CLI docs\n$ pytest --collect-cli-docs -p no:xdist -q\n$ python scripts/build_cli_docs.py\n\n# Verify docs are correct\n$ tox run -e cli-docs\n</code></pre>","path":["Development"],"tags":[]},{"location":"development-contributing/#troubleshooting","level":3,"title":"Troubleshooting","text":"<p>If <code>tox run -e cli-docs</code> fails:</p> <ul> <li>\"No test found documenting option --xxx\": Add <code>@pytest.mark.cli_doc(options=[\"--xxx\"], ...)</code> to a test</li> <li>\"File not found: ...\": Check that <code>input_schema</code> and <code>golden_output</code> paths are correct</li> <li>\"CLI docs are OUT OF DATE\": Run <code>python scripts/build_cli_docs.py</code> to regenerate</li> </ul>","path":["Development"],"tags":[]},{"location":"development-contributing/#cli-documentation-marker-reference","level":2,"title":"CLI Documentation Marker Reference","text":"<p>The <code>cli_doc</code> marker supports:</p> Parameter Required Description <code>options</code> Yes List of CLI options this test documents <code>input_schema</code> Yes Input schema path (relative to <code>tests/data/</code>) <code>cli_args</code> Yes CLI arguments used in the test <code>golden_output</code> Yes* Expected output file path <code>model_outputs</code> No Dict of model type → output file (for multi-model tabs) <code>version_outputs</code> No Dict of Python version → output file <code>comparison_output</code> No Baseline output without option (for before/after) <code>primary</code> No Set <code>True</code> if this is the main example for the option <p>*Either <code>golden_output</code> or <code>model_outputs</code> is required.</p> <p>See existing tests in <code>tests/main/</code> for examples.</p>","path":["Development"],"tags":[]},{"location":"field-constraints/","level":1,"title":"Field Constraints","text":"<p>An option <code>--field-constraints</code> converts all con* annotations to Field constraint options.</p> <p>Mypy may show error for <code>con*</code> annotations on fields. The option resolves the problem.</p>","path":["Usage","Field Constraints"],"tags":[]},{"location":"field-constraints/#example","level":2,"title":"Example","text":"<p>Convert simple JSON Schema <code>model.json</code> to pydantic model <code>model.py</code></p> <p>Input JSON Schema</p> <p><code>model.json</code> <pre><code>{\n  \"type\":  \"object\",\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\",\n      \"maxLength\": 64\n    }\n  },\n  \"required\": [\"name\"]\n}\n</code></pre></p>","path":["Usage","Field Constraints"],"tags":[]},{"location":"field-constraints/#without-field-constraints-option","level":3,"title":"Without <code>--field-constraints</code> option","text":"<pre><code>$ datamodel-codegen --input a.json --input-file-type jsonschema &gt; model.py \n</code></pre> <p>Generated Model</p> <p><code>model.py</code> <pre><code># generated by datamodel-codegen:\n#   filename:  model.json\n#   timestamp: 2020-07-20T15:37:56+00:00\n\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel, constr\n\n\nclass  Model(BaseModel):\n  name: constr(max_length=64)\n</code></pre></p> <p>Run mypy... <pre><code>$ mypy model.py \nmodel.py:3: error: Invalid type comment or annotation\nmodel.py:3: note: Suggestion: use constr[...] instead of constr(...)\nFound 1 error in 1 file (checked 1 source file)\n</code></pre> mypy show errors...</p>","path":["Usage","Field Constraints"],"tags":[]},{"location":"field-constraints/#with-field-constraints-option","level":3,"title":"With <code>--field-constraints</code> option","text":"<pre><code>$ datamodel-codegen --input model.json --input-file-type jsonschema --field-constraints &gt; model.py \n</code></pre> <p>Generated Model</p> <p><code>model.py</code> <pre><code># generated by datamodel-codegen:\n#   filename:  model.json\n#   timestamp: 2020-07-20T15:47:21+00:00\n\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    name: str = Field(..., max_length=64)\n</code></pre></p> <p>Run mypy... <pre><code>$ mypy model.py \nSuccess: no issues found in 1 source file\n</code></pre></p>","path":["Usage","Field Constraints"],"tags":[]},{"location":"field-constraints/#see-also","level":2,"title":"See Also","text":"<ul> <li>CLI Reference: <code>--field-constraints</code> - Detailed CLI option documentation with examples</li> </ul>","path":["Usage","Field Constraints"],"tags":[]},{"location":"field-constraints/#related-issues","level":2,"title":"Related issues","text":"<p>https://github.com/samuelcolvin/pydantic/issues/156</p>","path":["Usage","Field Constraints"],"tags":[]},{"location":"formatting/","level":1,"title":"Formatting","text":"<p>Code generated by <code>datamodel-codegen</code> will be passed through <code>isort</code> and <code>black</code> to produce consistent, well-formatted results. Settings for these tools can be specified in <code>pyproject.toml</code> (located in the output directory, or in some parent of the output directory). Also for black you can disable  skip-string-normalization with using datamodel-codegen option <code>--use-double-quotes</code>,  it will override your black config skip-string-normalization value. Using --use-double-quotes may be useful if you can't use black config. </p>","path":["Usage","Formatting"],"tags":[]},{"location":"formatting/#example","level":2,"title":"Example","text":"<p>pyproject.toml <pre><code>[tool.black]\nskip-string-normalization = true\nline-length = 100\n\n[tool.isort]\nmulti_line_output = 3\ninclude_trailing_comma = true\nforce_grid_wrap = 0\nuse_parentheses = true\nline_length = 100\nknown_first_party = \"kelvin\"\n</code></pre></p> <p>See the Black Project for more information.</p>","path":["Usage","Formatting"],"tags":[]},{"location":"formatting/#see-also","level":2,"title":"See Also","text":"<ul> <li>CLI Reference: <code>--formatters</code> - Specify code formatters</li> <li>CLI Reference: <code>--use-double-quotes</code> - Use double quotes for strings</li> <li>Custom Code Formatters - Create custom formatters</li> </ul>","path":["Usage","Formatting"],"tags":[]},{"location":"graphql/","level":1,"title":"Generate from GraphQL","text":"<p>The code generator can create pydantic models from GraphQL schema definitions.</p>","path":["Usage","Generate from GraphQL"],"tags":[]},{"location":"graphql/#simple-example","level":2,"title":"Simple example","text":"<pre><code>$ datamodel-codegen --input schema.graphql --input-file-type graphql --output model.py\n</code></pre> <p>Let's consider a simple GraphQL schema (more details in https://graphql.org/learn/schema/).</p> <p>schema.graphql <pre><code>type Book {\n  id: ID!  \n  title: String\n  author: Author\n}\n\ntype Author {\n  id: ID!  \n  name: String\n  books: [Book]\n}\n\ninput BooksInput {\n    ids: [ID!]!\n}\n\ninput AuthorBooksInput {\n    id: ID!\n}\n\ntype Query {\n  getBooks(input: BooksInput): [Book]\n  getAuthorBooks(input: AuthorBooksInput): [Book]\n}\n</code></pre></p> <p>model.py <pre><code># generated by datamodel-codegen:\n#   filename:  schema.graphql\n#   timestamp: 2023-11-20T17:04:42+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional, TypeAlias\n\nfrom pydantic import BaseModel, Field\nfrom typing_extensions import Literal\n\n# The `Boolean` scalar type represents `true` or `false`.\nBoolean: TypeAlias = bool\n\n\n# The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `\"4\"`) or integer (such as `4`) input value will be accepted as an ID.\nID: TypeAlias = str\n\n\n# The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\nString: TypeAlias = str\n\n\nclass Author(BaseModel):\n    books: Optional[List[Optional[Book]]] = Field(default_factory=list)\n    id: ID\n    name: Optional[String] = None\n    typename__: Optional[Literal['Author']] = Field('Author', alias='__typename')\n\n\nclass Book(BaseModel):\n    author: Optional[Author] = None\n    id: ID\n    title: Optional[String] = None\n    typename__: Optional[Literal['Book']] = Field('Book', alias='__typename')\n\n\nclass AuthorBooksInput(BaseModel):\n    id: ID\n    typename__: Optional[Literal['AuthorBooksInput']] = Field(\n        'AuthorBooksInput', alias='__typename'\n    )\n\n\nclass BooksInput(BaseModel):\n    ids: List[ID]\n    typename__: Optional[Literal['BooksInput']] = Field(\n        'BooksInput', alias='__typename'\n    )\n</code></pre></p>","path":["Usage","Generate from GraphQL"],"tags":[]},{"location":"graphql/#response-deserialization","level":2,"title":"Response deserialization","text":"<p>For the following response of <code>getAuthorBooks</code> GraphQL query  </p> <p>response.json <pre><code>{\n  \"getAuthorBooks\": [\n    {\n      \"author\": {\n        \"id\": \"51341cdscwef14r13\",\n        \"name\": \"J. K. Rowling\"\n      },\n      \"id\": \"1321dfvrt211wdw\",\n      \"title\": \"Harry Potter and the Prisoner of Azkaban\"\n    },\n    {\n      \"author\": {\n        \"id\": \"51341cdscwef14r13\",\n        \"name\": \"J. K. Rowling\"\n      },\n      \"id\": \"dvsmu12e19xmqacqw9\",\n      \"title\": \"Fantastic Beasts: The Crimes of Grindelwald\"\n    }\n  ]\n}\n</code></pre></p> <p>main.py <pre><code>from model import Book\n\nresponse = {...}\n\nbooks = [\n    Book.parse_obj(book_raw) for book_raw in response[\"getAuthorBooks\"]\n]\nprint(books)\n# [Book(author=Author(books=[], id='51341cdscwef14r13', name='J. K. Rowling', typename__='Author'), id='1321dfvrt211wdw', title='Harry Potter and the Prisoner of Azkaban', typename__='Book'), Book(author=Author(books=[], id='51341cdscwef14r13', name='J. K. Rowling', typename__='Author'), id='dvsmu12e19xmqacqw9', title='Fantastic Beasts: The Crimes of Grindelwald', typename__='Book')]\n</code></pre></p>","path":["Usage","Generate from GraphQL"],"tags":[]},{"location":"graphql/#custom-scalar-types","level":2,"title":"Custom scalar types","text":"<pre><code>$ datamodel-codegen --input schema.graphql --input-file-type graphql --output model.py --extra-template-data data.json\n</code></pre> <p>schema.graphql <pre><code>scalar Long\n\ntype A {\n  id: ID!\n  duration: Long!\n}\n</code></pre></p> <p>data.json <pre><code>{\n  \"Long\": {\n    \"py_type\": \"int\"\n  }\n}\n</code></pre></p> <p>model.py <pre><code># generated by datamodel-codegen:\n#   filename:  custom-scalar-types.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional, TypeAlias\n\nfrom pydantic import BaseModel, Field\nfrom typing_extensions import Literal\n\n# The `Boolean` scalar type represents `true` or `false`.\nBoolean: TypeAlias = bool\n\n\n# The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `\"4\"`) or integer (such as `4`) input value will be accepted as an ID.\nID: TypeAlias = str\n\n\nLong: TypeAlias = int\n\n\n# The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\nString: TypeAlias = str\n\n\nclass A(BaseModel):\n    duration: Long\n    id: ID\n    typename__: Optional[Literal['A']] = Field('A', alias='__typename')\n</code></pre></p>","path":["Usage","Generate from GraphQL"],"tags":[]},{"location":"graphql/#see-also","level":2,"title":"See Also","text":"<ul> <li>CLI Reference - Complete CLI options reference</li> <li>CLI Reference: Typing Customization - Type annotation options</li> <li>CLI Reference: <code>--extra-template-data</code> - Custom scalar type mappings</li> </ul>","path":["Usage","Generate from GraphQL"],"tags":[]},{"location":"jsondata/","level":1,"title":"Generate from JSON Data","text":"<p>This code generator can create pydantic models from JSON Data. Under the hood, the generator uses GenSON to create JSON Schema from your input. The generated schema is then processed the in the same manner as JSON Schema input data.</p>","path":["Usage","Generate from JSON Data"],"tags":[]},{"location":"jsondata/#example","level":2,"title":"Example","text":"<pre><code>$ datamodel-codegen  --input pets.json --input-file-type json --output model.py\n</code></pre> <p>pets.json <pre><code>{\n  \"pets\": [\n    {\n      \"name\": \"dog\",\n      \"age\": 2\n    },\n    {\n      \"name\": \"cat\",\n      \"age\": 1\n    },\n    {\n      \"name\": \"snake\",\n      \"age\": 3,\n      \"nickname\": \"python\"\n    }\n  ],\n  \"status\": 200\n}\n</code></pre></p> <p>model.py <pre><code># generated by datamodel-codegen:\n#   filename:  pets.json\n#   timestamp: 2020-04-27T16:08:21+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    name: str\n    age: int\n    nickname: Optional[str] = None\n\n\nclass Model(BaseModel):\n    pets: List[Pet]\n    status: int\n</code></pre></p>","path":["Usage","Generate from JSON Data"],"tags":[]},{"location":"jsonschema/","level":1,"title":"Generate from JSON Schema","text":"<p>The code generator can create pydantic models from JSON Schema. See more information about supported JSON Schema data types and features here.</p>","path":["Usage","Generate from JSON Schema"],"tags":[]},{"location":"jsonschema/#example","level":2,"title":"Example","text":"<pre><code>$ datamodel-codegen  --input person.json --input-file-type jsonschema --output model.py\n</code></pre> <p>person.json <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Person\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"firstName\": {\n      \"type\": \"string\",\n      \"description\": \"The person's first name.\"\n    },\n    \"lastName\": {\n      \"type\": \"string\",\n      \"description\": \"The person's last name.\"\n    },\n    \"age\": {\n      \"description\": \"Age in years which must be equal to or greater than zero.\",\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"friends\": {\n      \"type\": \"array\"\n    },\n    \"comment\": {\n      \"type\": \"null\"\n    }\n  }\n}\n</code></pre></p> <p>model.py <pre><code># generated by datamodel-codegen:\n#   filename:  person.json\n#   timestamp: 2020-04-27T16:12:27+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Any, List, Optional\n\nfrom pydantic import BaseModel, Field, conint\n\n\nclass Person(BaseModel):\n    firstName: Optional[str] = Field(None, description=\"The person's first name.\")\n    lastName: Optional[str] = Field(None, description=\"The person's last name.\")\n    age: Optional[conint(ge=0)] = Field(\n        None, description='Age in years which must be equal to or greater than zero.'\n    )\n    friends: Optional[List] = None\n    comment: Optional[Any] = None\n</code></pre></p>","path":["Usage","Generate from JSON Schema"],"tags":[]},{"location":"jsonschema/#see-also","level":2,"title":"See Also","text":"<ul> <li>CLI Reference - Complete CLI options reference</li> <li>CLI Reference: Typing Customization - Type annotation options</li> <li>CLI Reference: Field Customization - Field naming and constraint options</li> <li>Supported Data Types - JSON Schema data type support</li> </ul>","path":["Usage","Generate from JSON Schema"],"tags":[]},{"location":"openapi/","level":1,"title":"Generate from OpenAPI","text":"<p>The code generator can create pydantic models from OpenAPI schema definitions, particularly using the data from the <code>schema</code> field.</p>","path":["Usage","Generate from OpenAPI"],"tags":[]},{"location":"openapi/#example","level":2,"title":"Example","text":"<pre><code>$ datamodel-codegen --input api.yaml --input-file-type openapi --output model.py\n</code></pre> api.yaml <pre>\n<code>\n<pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Error:\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n</code></pre>\n</code>\n</pre> <p>model.py <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2020-06-02T05:28:24+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n</code></pre></p>","path":["Usage","Generate from OpenAPI"],"tags":[]},{"location":"openapi/#readonly-writeonly-properties","level":2,"title":"readOnly / writeOnly Properties","text":"<p>OpenAPI 3.x supports <code>readOnly</code> and <code>writeOnly</code> property annotations:</p> <ul> <li>readOnly: Property is only returned in responses (e.g., <code>id</code>, <code>created_at</code>)</li> <li>writeOnly: Property is only sent in requests (e.g., <code>password</code>)</li> </ul>","path":["Usage","Generate from OpenAPI"],"tags":[]},{"location":"openapi/#option-read-only-write-only-model-type","level":3,"title":"Option: <code>--read-only-write-only-model-type</code>","text":"<p>This option generates separate Request/Response models based on these annotations.</p> Value Description (not set) Default. No special handling (backward compatible) <code>request-response</code> Generate only Request/Response models (no base model) <code>all</code> Generate base model + Request + Response models","path":["Usage","Generate from OpenAPI"],"tags":[]},{"location":"openapi/#example-schema","level":3,"title":"Example Schema","text":"<pre><code>openapi: \"3.0.0\"\ninfo:\n  title: User API\n  version: \"1.0\"\npaths: {}\ncomponents:\n  schemas:\n    User:\n      type: object\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          readOnly: true      # Server-generated, not in requests\n        name:\n          type: string\n        password:\n          type: string\n          writeOnly: true     # Client-only, not in responses\n        created_at:\n          type: string\n          format: date-time\n          readOnly: true\n</code></pre>","path":["Usage","Generate from OpenAPI"],"tags":[]},{"location":"openapi/#generated-output","level":3,"title":"Generated Output","text":"<pre><code>$ datamodel-codegen --input user.yaml --input-file-type openapi \\\n    --output-model-type pydantic_v2.BaseModel \\\n    --read-only-write-only-model-type all\n</code></pre> <pre><code>from pydantic import BaseModel\nfrom typing import Optional\nfrom datetime import datetime\n\n# Request model: excludes readOnly fields (id, created_at)\nclass UserRequest(BaseModel):\n    name: str\n    password: Optional[str] = None\n\n# Response model: excludes writeOnly fields (password)\nclass UserResponse(BaseModel):\n    id: int\n    name: str\n    created_at: Optional[datetime] = None\n\n# Base model: contains all fields\nclass User(BaseModel):\n    id: int\n    name: str\n    password: Optional[str] = None\n    created_at: Optional[datetime] = None\n</code></pre>","path":["Usage","Generate from OpenAPI"],"tags":[]},{"location":"openapi/#usage-patterns","level":3,"title":"Usage Patterns","text":"Use Case Recommended Option Generated Models API client validation <code>request-response</code> <code>UserRequest</code>, <code>UserResponse</code> Database ORM mapping (not set) <code>User</code> Both client &amp; ORM <code>all</code> <code>User</code>, <code>UserRequest</code>, <code>UserResponse</code>","path":["Usage","Generate from OpenAPI"],"tags":[]},{"location":"openapi/#behavior-with-allof-inheritance","level":3,"title":"Behavior with allOf Inheritance","text":"<p>When using <code>allOf</code> with <code>$ref</code>, fields from all referenced schemas are flattened into Request/Response models:</p> <pre><code>components:\n  schemas:\n    Timestamps:\n      type: object\n      properties:\n        created_at:\n          type: string\n          format: date-time\n          readOnly: true\n\n    User:\n      allOf:\n        - $ref: \"#/components/schemas/Timestamps\"\n        - type: object\n          properties:\n            name:\n              type: string\n</code></pre> <p>Generated <code>UserRequest</code> will exclude <code>created_at</code> (readOnly from Timestamps).</p>","path":["Usage","Generate from OpenAPI"],"tags":[]},{"location":"openapi/#collision-handling","level":3,"title":"Collision Handling","text":"<p>If a schema named <code>UserRequest</code> or <code>UserResponse</code> already exists, the generated model will be named <code>UserRequestModel</code> or <code>UserResponseModel</code> to avoid conflicts.</p>","path":["Usage","Generate from OpenAPI"],"tags":[]},{"location":"openapi/#supported-output-formats","level":3,"title":"Supported Output Formats","text":"<p>This option works with all output formats:</p> <ul> <li><code>pydantic.BaseModel</code> / <code>pydantic_v2.BaseModel</code></li> <li><code>dataclasses.dataclass</code></li> <li><code>typing.TypedDict</code></li> <li><code>msgspec.Struct</code></li> </ul>","path":["Usage","Generate from OpenAPI"],"tags":[]},{"location":"openapi/#supported-ref-types","level":3,"title":"Supported $ref Types","text":"<p>readOnly/writeOnly resolution works with local and file reference types:</p> Reference Type Example Support Local <code>#/components/schemas/User</code> ✅ File <code>./common.yaml#/User</code> ✅","path":["Usage","Generate from OpenAPI"],"tags":[]},{"location":"openapi/#see-also","level":2,"title":"See Also","text":"<ul> <li>CLI Reference: OpenAPI-only Options - All OpenAPI-specific CLI options</li> <li>CLI Reference: Base Options - Input/output configuration options</li> </ul>","path":["Usage","Generate from OpenAPI"],"tags":[]},{"location":"pyproject_toml/","level":1,"title":"pyproject.toml Configuration","text":"<p>datamodel-code-generator can be configured using <code>pyproject.toml</code>. The tool automatically searches for <code>pyproject.toml</code> in the current directory and parent directories (stopping at the git repository root).</p>","path":["Usage","pyproject.toml Configuration"],"tags":[]},{"location":"pyproject_toml/#basic-usage","level":2,"title":"Basic Usage","text":"<pre><code>[tool.datamodel-codegen]\ninput = \"schema.yaml\"\noutput = \"models.py\"\ntarget-python-version = \"3.11\"\nsnake-case-field = true\nfield-constraints = true\n</code></pre> <p>All CLI options can be used in <code>pyproject.toml</code> by converting them to kebab-case (e.g., <code>--snake-case-field</code> becomes <code>snake-case-field</code>).</p>","path":["Usage","pyproject.toml Configuration"],"tags":[]},{"location":"pyproject_toml/#named-profiles","level":2,"title":"Named Profiles","text":"<p>You can define multiple named profiles for different use cases within a single project:</p> <pre><code>[tool.datamodel-codegen]\ntarget-python-version = \"3.9\"\nsnake-case-field = true\n\n[tool.datamodel-codegen.profiles.api]\ninput = \"schemas/api.yaml\"\noutput = \"src/models/api.py\"\ntarget-python-version = \"3.11\"\n\n[tool.datamodel-codegen.profiles.database]\ninput = \"schemas/db.json\"\noutput = \"src/models/db.py\"\ninput-file-type = \"jsonschema\"\n</code></pre> <p>Base settings in <code>[tool.datamodel-codegen]</code> are used when no profile is specified, and also serve as defaults for profiles.</p> <p>Use a profile with the <code>--profile</code> option:</p> <pre><code>datamodel-codegen --profile api\ndatamodel-codegen --profile database\n</code></pre>","path":["Usage","pyproject.toml Configuration"],"tags":[]},{"location":"pyproject_toml/#configuration-priority","level":2,"title":"Configuration Priority","text":"<p>Settings are applied in the following priority order (highest to lowest):</p> <ol> <li>CLI arguments - Always take precedence</li> <li>Profile settings - From <code>[tool.datamodel-codegen.profiles.&lt;name&gt;]</code></li> <li>Base settings - From <code>[tool.datamodel-codegen]</code></li> <li>Default values - Built-in defaults</li> </ol>","path":["Usage","pyproject.toml Configuration"],"tags":[]},{"location":"pyproject_toml/#merge-rules","level":2,"title":"Merge Rules","text":"<p>When using profiles, settings are merged using shallow merge:</p> <ul> <li>Profile values completely replace base values (no deep merging)</li> <li>Settings not specified in the profile are inherited from the base configuration</li> <li>Lists and dictionaries are replaced entirely, not merged</li> </ul>","path":["Usage","pyproject.toml Configuration"],"tags":[]},{"location":"pyproject_toml/#example","level":3,"title":"Example","text":"<pre><code>[tool.datamodel-codegen]\nstrict-types = [\"str\", \"int\"]\nhttp-headers = [\"Authorization: Bearer token\"]\n\n[tool.datamodel-codegen.profiles.api]\nstrict-types = [\"bytes\"]\n</code></pre> <p>When using <code>--profile api</code>:</p> <ul> <li><code>strict-types</code> becomes <code>[\"bytes\"]</code> (completely replaces base, not merged)</li> <li><code>http-headers</code> is inherited from base as <code>[\"Authorization: Bearer token\"]</code></li> </ul>","path":["Usage","pyproject.toml Configuration"],"tags":[]},{"location":"pyproject_toml/#ignoring-pyprojecttoml","level":2,"title":"Ignoring pyproject.toml","text":"<p>To ignore all <code>pyproject.toml</code> configuration and use only CLI arguments:</p> <pre><code>datamodel-codegen --ignore-pyproject --input schema.yaml --output models.py\n</code></pre>","path":["Usage","pyproject.toml Configuration"],"tags":[]},{"location":"pyproject_toml/#generating-configuration","level":2,"title":"Generating Configuration","text":"<p>Generate a <code>pyproject.toml</code> configuration section from CLI arguments:</p> <pre><code>datamodel-codegen --input schema.yaml --output models.py --snake-case-field --generate-pyproject-config\n</code></pre> <p>Output:</p> <pre><code>[tool.datamodel-codegen]\ninput = \"schema.yaml\"\noutput = \"models.py\"\nsnake-case-field = true\n</code></pre> <p>Generate CLI command from existing <code>pyproject.toml</code>:</p> <pre><code>datamodel-codegen --generate-cli-command\n</code></pre> <p>With a specific profile:</p> <pre><code>datamodel-codegen --profile api --generate-cli-command\n</code></pre>","path":["Usage","pyproject.toml Configuration"],"tags":[]},{"location":"pyproject_toml/#see-also","level":2,"title":"See Also","text":"<ul> <li>CLI Reference: <code>--ignore-pyproject</code> - Ignore pyproject.toml configuration</li> <li>CLI Reference: <code>--generate-pyproject-config</code> - Generate pyproject.toml from CLI arguments</li> <li>CLI Reference: <code>--generate-cli-command</code> - Generate CLI command from pyproject.toml</li> </ul>","path":["Usage","pyproject.toml Configuration"],"tags":[]},{"location":"root-model-and-type-alias/","level":1,"title":"Root Models and Type Aliases","text":"<p>When a schema defines a simple type (not an object with properties), <code>datamodel-code-generator</code> creates a root model. If you don't want to introduce a new level of attribute access (<code>.root</code>) or want to use generated types as plain Python types in non-Pydantic code, you can use the <code>--use-type-alias</code> flag to generate type aliases instead of root models.</p>","path":["Usage","Root Models and Type Aliases"],"tags":[]},{"location":"root-model-and-type-alias/#notes-and-limitations","level":2,"title":"Notes and limitations","text":"<p>This functionality experimental! Here are a few known issues: - RootModel and type aliases do not fully support field-specific metadata (default, alias, etc). See https://docs.pydantic.dev/latest/concepts/types/#named-type-aliases for details. - Type aliases do not support some RootModel features (e.g. <code>model_config</code>) - A RootModel or type alias is also generated for the main schema, allowing you to define a single type alias from a schema file (e.g. <code>model.json</code> containing <code>{\"title\": \"MyString\", \"type\": \"string\"}</code>) - Type aliases cannot be combined with <code>Annotated</code> for Pydantic v1</p>","path":["Usage","Root Models and Type Aliases"],"tags":[]},{"location":"root-model-and-type-alias/#type-alias-behavior-by-output-type-and-python-version","level":2,"title":"Type Alias Behavior by Output Type and Python Version","text":"<p>The type of type alias generated depends on the output model type and target Python version:</p> Output Type Python 3.12+ Python 3.10-3.11 Python 3.9 Pydantic v2 <code>type</code> statement <code>TypeAliasType</code> (typing_extensions) <code>TypeAliasType</code> (typing_extensions) Pydantic v1 <code>TypeAlias</code> <code>TypeAlias</code> <code>TypeAlias</code> (typing_extensions) TypedDict <code>type</code> statement <code>TypeAlias</code> <code>TypeAlias</code> (typing_extensions) dataclasses <code>type</code> statement <code>TypeAlias</code> <code>TypeAlias</code> (typing_extensions) msgspec <code>type</code> statement <code>TypeAlias</code> <code>TypeAlias</code> (typing_extensions) <p>Why the difference?</p> <ul> <li>Pydantic v2 requires <code>TypeAliasType</code> because it cannot properly handle <code>TypeAlias</code> annotations</li> <li>Other output types (TypedDict, dataclasses, msgspec) use <code>TypeAlias</code> for better compatibility with libraries that may not expect <code>TypeAliasType</code> objects</li> <li>Python 3.12+ uses the native <code>type</code> statement for all output types</li> </ul>","path":["Usage","Root Models and Type Aliases"],"tags":[]},{"location":"root-model-and-type-alias/#example","level":2,"title":"Example","text":"<p>Input JSON Schema</p> <p><code>model.json</code> <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"definitions\": {\n    \"UserId\": {\n      \"type\": \"string\"\n    },\n    \"Status\": {\n      \"anyOf\": [\n        {\"type\": \"string\"},\n        {\"type\": \"integer\"}\n      ]\n    },\n    \"User\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"id\": {\"$ref\": \"#/definitions/UserId\"},\n        \"status\": {\"$ref\": \"#/definitions/Status\"}\n      }\n    }\n  }\n}\n</code></pre></p>","path":["Usage","Root Models and Type Aliases"],"tags":[]},{"location":"root-model-and-type-alias/#pydantic-v1","level":3,"title":"Pydantic v1","text":"","path":["Usage","Root Models and Type Aliases"],"tags":[]},{"location":"root-model-and-type-alias/#generating-rootmodel","level":4,"title":"Generating RootModel","text":"<pre><code>$ datamodel-codegen --input model.json --input-file-type jsonschema --output model.py\n</code></pre> <p>Generated Model</p> <p><code>model.py</code> <pre><code># generated by datamodel-codegen:\n#   filename:  model.json\n\nfrom __future__ import annotations\n\nfrom typing import Any, Optional, Union\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    __root__: Any\n\n\nclass UserId(BaseModel):\n    __root__: str\n\n\nclass Status(BaseModel):\n    __root__: Union[str, int]\n\n\nclass User(BaseModel):\n    id: Optional[UserId] = None\n    status: Optional[Status] = None\n</code></pre></p>","path":["Usage","Root Models and Type Aliases"],"tags":[]},{"location":"root-model-and-type-alias/#generating-typealias-annotation","level":4,"title":"Generating TypeAlias annotation","text":"<pre><code>$ datamodel-codegen --input model.json --input-file-type jsonschema --use-type-alias --output model.py\n</code></pre> <p>Generated Model (Python 3.10+)</p> <p><code>model.py</code> <pre><code># generated by datamodel-codegen:\n#   filename:  model.json\n\nfrom __future__ import annotations\n\nfrom typing import Any, Optional, TypeAlias, Union\n\nfrom pydantic import BaseModel\n\nModel: TypeAlias = Any\n\n\nUserId: TypeAlias = str\n\n\nStatus: TypeAlias = Union[str, int]\n\n\nclass User(BaseModel):\n    id: Optional[UserId] = None\n    status: Optional[Status] = None\n</code></pre></p> <p>Generated Model (Python 3.9)</p> <p><code>model.py</code> <pre><code># generated by datamodel-codegen:\n#   filename:  model.json\n\nfrom __future__ import annotations\n\nfrom typing import Any, Optional, Union\n\nfrom pydantic import BaseModel\nfrom typing_extensions import TypeAlias\n\nModel: TypeAlias = Any\n\n\nUserId: TypeAlias = str\n\n\nStatus: TypeAlias = Union[str, int]\n\n\nclass User(BaseModel):\n    id: Optional[UserId] = None\n    status: Optional[Status] = None\n</code></pre></p>","path":["Usage","Root Models and Type Aliases"],"tags":[]},{"location":"root-model-and-type-alias/#pydantic-v2","level":3,"title":"Pydantic v2","text":"","path":["Usage","Root Models and Type Aliases"],"tags":[]},{"location":"root-model-and-type-alias/#generating-rootmodel_1","level":4,"title":"Generating RootModel","text":"<pre><code>$ datamodel-codegen --input model.json --input-file-type jsonschema --output-model-type pydantic_v2.BaseModel --output model.py\n</code></pre> <p>Generated Model</p> <p><code>model.py</code> <pre><code># generated by datamodel-codegen:\n#   filename:  model.json\n\nfrom __future__ import annotations\n\nfrom typing import Any, Optional, Union\n\nfrom pydantic import BaseModel, RootModel\n\n\nclass Model(RootModel[Any]):\n    root: Any\n\n\nclass UserId(RootModel[str]):\n    root: str\n\n\nclass Status(RootModel[Union[str, int]]):\n    root: Union[str, int]\n\n\nclass User(BaseModel):\n    id: Optional[UserId] = None\n    status: Optional[Status] = None\n</code></pre></p>","path":["Usage","Root Models and Type Aliases"],"tags":[]},{"location":"root-model-and-type-alias/#generating-typealiastype-python-39-311","level":4,"title":"Generating TypeAliasType (Python 3.9-3.11)","text":"<pre><code>$ datamodel-codegen --input model.json --input-file-type jsonschema --output-model-type pydantic_v2.BaseModel --use-type-alias --output model.py\n</code></pre> <p>Generated Model</p> <p><code>model.py</code> <pre><code># generated by datamodel-codegen:\n#   filename:  model.json\n\nfrom __future__ import annotations\n\nfrom typing import Any, Optional, Union\n\nfrom pydantic import BaseModel\nfrom typing_extensions import TypeAliasType\n\nModel = TypeAliasType(\"Model\", Any)\n\n\nUserId = TypeAliasType(\"UserId\", str)\n\n\nStatus = TypeAliasType(\"Status\", Union[str, int])\n\n\nclass User(BaseModel):\n    id: Optional[UserId] = None\n    status: Optional[Status] = None\n</code></pre></p>","path":["Usage","Root Models and Type Aliases"],"tags":[]},{"location":"root-model-and-type-alias/#generating-type-statement-python-312","level":4,"title":"Generating type statement (Python 3.12+)","text":"<pre><code>$ datamodel-codegen --input model.json --input-file-type jsonschema --output-model-type pydantic_v2.BaseModel --use-type-alias --target-python-version 3.12 --output model.py\n</code></pre> <p>Generated Model</p> <p><code>model.py</code> <pre><code># generated by datamodel-codegen:\n#   filename:  model.json\n\nfrom __future__ import annotations\n\nfrom typing import Any, Optional, Union\n\nfrom pydantic import BaseModel\n\ntype Model = Any\n\n\ntype UserId = str\n\n\ntype Status = Union[str, int]\n\n\nclass User(BaseModel):\n    id: Optional[UserId] = None\n    status: Optional[Status] = None\n</code></pre></p>","path":["Usage","Root Models and Type Aliases"],"tags":[]},{"location":"root-model-and-type-alias/#see-also","level":2,"title":"See Also","text":"<ul> <li>CLI Reference: <code>--use-type-alias</code> - Detailed CLI option documentation</li> <li>CLI Reference: <code>--target-python-version</code> - Control Python version-specific syntax</li> </ul>","path":["Usage","Root Models and Type Aliases"],"tags":[]},{"location":"supported-data-types/","level":1,"title":"Supported Input Formats","text":"<p>This code generator supports the following input formats:</p> <ul> <li>OpenAPI 3 (YAML/JSON, OpenAPI Data Type);</li> <li>JSON Schema (JSON Schema Core /JSON Schema Validation);</li> <li>JSON/YAML Data (it will be converted to JSON Schema);</li> <li>Python dictionary (it will be converted to JSON Schema);</li> <li>GraphQL schema (GraphQL Schemas and Types);</li> </ul>","path":["Supported Input Formats"],"tags":[]},{"location":"supported-data-types/#implemented-data-types-and-features","level":2,"title":"Implemented data types and features","text":"<p>Below are the data types and features recognized by datamodel-code-generator for OpenAPI 3 and JSON Schema.</p>","path":["Supported Input Formats"],"tags":[]},{"location":"supported-data-types/#data-types","level":3,"title":"Data Types","text":"<ul> <li>string (supported keywords: pattern/minLength/maxLength)</li> <li>number (supported keywords: maximum/exclusiveMaximum/minimum/exclusiveMinimum/multipleOf)</li> <li>integer (supported keywords: maximum/exclusiveMaximum/minimum/exclusiveMinimum/multipleOf)</li> <li>boolean</li> <li>array</li> <li>object</li> </ul>","path":["Supported Input Formats"],"tags":[]},{"location":"supported-data-types/#string-formats","level":3,"title":"String Formats","text":"<ul> <li>date</li> <li>datetime</li> <li>time</li> <li>password</li> <li>email</li> <li>idn-email</li> <li>path</li> <li>uuid (uuid1/uuid2/uuid3/uuid4/uuid5)</li> <li>ipv4</li> <li>ipv6</li> <li>hostname</li> <li>decimal</li> <li>uri</li> </ul>","path":["Supported Input Formats"],"tags":[]},{"location":"supported-data-types/#other-schema","level":3,"title":"Other schema","text":"<ul> <li>enum (as enum.Enum or typing.Literal)</li> <li>allOf (as Multiple inheritance)</li> <li>anyOf (as typing.Union)</li> <li>oneOf (as typing.Union)</li> <li>$ref (http extra is required when resolving $ref for remote files.)</li> <li>$id (for JSONSchema)</li> </ul>","path":["Supported Input Formats"],"tags":[]},{"location":"using_as_module/","level":1,"title":"Using datamode-code-generator as a Module","text":"<p>datamodel-code-generator is a CLI tool, but it can also be used as a module.</p> <p>You can call this code-generator in your python code.</p>","path":["Usage","Using datamode-code-generator as a Module"],"tags":[]},{"location":"using_as_module/#how-to-use-it-as-module","level":2,"title":"How to use it as module","text":"<p>You can generate models with <code>datamodel_code_generator.generate</code> using parameters that match the arguments provided to the CLI tool. The generated files can be written to and read from the <code>Path</code> object supplied to output.</p> <p>In the below example, we use a file in a <code>TemporaryDirectory</code> to store our output.</p>","path":["Usage","Using datamode-code-generator as a Module"],"tags":[]},{"location":"using_as_module/#installation","level":3,"title":"Installation","text":"<pre><code>pip install 'datamodel-code-generator[http]'\n</code></pre>","path":["Usage","Using datamode-code-generator as a Module"],"tags":[]},{"location":"using_as_module/#example","level":3,"title":"Example","text":"<pre><code>from pathlib import Path\nfrom tempfile import TemporaryDirectory\nfrom datamodel_code_generator import InputFileType, generate\nfrom datamodel_code_generator import DataModelType\n\njson_schema: str = \"\"\"{\n    \"type\": \"object\",\n    \"properties\": {\n        \"number\": {\"type\": \"number\"},\n        \"street_name\": {\"type\": \"string\"},\n        \"street_type\": {\"type\": \"string\",\n                        \"enum\": [\"Street\", \"Avenue\", \"Boulevard\"]\n                        }\n    }\n}\"\"\"\n\nwith TemporaryDirectory() as temporary_directory_name:\n    temporary_directory = Path(temporary_directory_name)\n    output = Path(temporary_directory / 'model.py')\n    generate(\n        json_schema,\n        input_file_type=InputFileType.JsonSchema,\n        input_filename=\"example.json\",\n        output=output,\n        # set up the output model types\n        output_model_type=DataModelType.PydanticV2BaseModel,\n    )\n    model: str = output.read_text()\nprint(model)\n</code></pre> <p>The result of <code>print(model)</code>: <pre><code># generated by datamodel-codegen:\n#   filename:  example.json\n#   timestamp: 2020-12-21T08:01:06+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass StreetType(Enum):\n    Street = 'Street'\n    Avenue = 'Avenue'\n    Boulevard = 'Boulevard'\n\n\nclass Model(BaseModel):\n    number: Optional[float] = None\n    street_name: Optional[str] = None\n    street_type: Optional[StreetType] = None\n</code></pre></p> <p>Also, you can call parser directly</p> <pre><code>from datamodel_code_generator import DataModelType, PythonVersion\nfrom datamodel_code_generator.model import get_data_model_types\nfrom datamodel_code_generator.parser.jsonschema import JsonSchemaParser\n\njson_schema: str = \"\"\"{\n    \"type\": \"object\",\n    \"properties\": {\n        \"number\": {\"type\": \"number\"},\n        \"street_name\": {\"type\": \"string\"},\n        \"street_type\": {\"type\": \"string\",\n                        \"enum\": [\"Street\", \"Avenue\", \"Boulevard\"]\n                        }\n    }\n}\"\"\"\n\n\ndata_model_types = get_data_model_types(\n    DataModelType.PydanticV2BaseModel,\n    target_python_version=PythonVersion.PY_311\n)\nparser = JsonSchemaParser(\n   json_schema,\n   data_model_type=data_model_types.data_model,\n   data_model_root_type=data_model_types.root_model,\n   data_model_field_type=data_model_types.field_model,\n   data_type_manager_type=data_model_types.data_type_manager,\n   dump_resolve_reference_action=data_model_types.dump_resolve_reference_action,\n                       )\nresult = parser.parse()\nprint(result)\n ```\n\nThe result of `print(model)`:\n```python\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass StreetType(Enum):\n    Street = 'Street'\n    Avenue = 'Avenue'\n    Boulevard = 'Boulevard'\n\n\nclass Model(BaseModel):\n    number: Optional[float] = None\n    street_name: Optional[str] = None\n    street_type: Optional[StreetType] = None\n</code></pre>","path":["Usage","Using datamode-code-generator as a Module"],"tags":[]},{"location":"using_as_module/#why-doesnt-datamodel_code_generatorgenerate-return-a-string","level":2,"title":"Why doesn't <code>datamodel_code_generator.generate</code> return a string?","text":"<p>The above example schema only generates a single python module, but a single schema may generate multiple modules. There is no way to represent these modules as a single string, so the <code>generate</code> method returns <code>None</code>.</p> <p>Note that the output parameter can take any <code>Path</code> object, which includes both file and directory paths. If a file name is provided and multiple modules are generated, <code>generate</code> will raise a <code>datamodel_code_gen.Error</code> exception.</p> <p>If multiple modules are generated, you will need to walk through the supplied output directory to find all of them.</p>","path":["Usage","Using datamode-code-generator as a Module"],"tags":[]},{"location":"what_is_the_difference_between_v1_and_v2/","level":1,"title":"What is the difference between pydantic v1 and v2 output model?","text":"","path":["Usage","What is the difference between pydantic v1 and v2 output model?"],"tags":[]},{"location":"what_is_the_difference_between_v1_and_v2/#summary","level":2,"title":"Summary","text":"<p>datamodel-code-generator supports Pydantic v1 and v2 as output model type.</p> <p>Pydantic v2 is a major release with many breaking changes. See the migration guide for more information: https://docs.pydantic.dev/2.0/migration/</p>","path":["Usage","What is the difference between pydantic v1 and v2 output model?"],"tags":[]},{"location":"what_is_the_difference_between_v1_and_v2/#whats-changes-in-v2-output","level":2,"title":"What's changes in v2 output?","text":"","path":["Usage","What is the difference between pydantic v1 and v2 output model?"],"tags":[]},{"location":"what_is_the_difference_between_v1_and_v2/#__root__-field-aka-custom-root-types","level":3,"title":"<code>__root__</code> field (a.k.a Custom Root Types)","text":"<p><code>__root__</code> field (a.k.a Custom Root Types) is removed in pydantic v2. The model is changed to RootModel</p>","path":["Usage","What is the difference between pydantic v1 and v2 output model?"],"tags":[]},{"location":"what_is_the_difference_between_v1_and_v2/#pydanticfield","level":3,"title":"pydantic.Field","text":"<p>https://docs.pydantic.dev/2.0/migration/#changes-to-pydanticfield</p> <ul> <li>const -&gt; removed</li> <li>min_items (use min_length instead)</li> <li>max_items (use max_length instead)</li> <li>unique_items -&gt; removed and the list type will be replaced by <code>typing.Set</code>. this feature is discussed in https://github.com/pydantic/pydantic-core/issues/296</li> <li>allow_mutation (use frozen instead)</li> <li>regex (use pattern instead)</li> </ul>","path":["Usage","What is the difference between pydantic v1 and v2 output model?"],"tags":[]},{"location":"what_is_the_difference_between_v1_and_v2/#model-config","level":3,"title":"Model Config","text":"<ul> <li><code>pydantic.Config</code> -&gt; <code>pydantic.ConfigDict</code></li> <li>allow_mutation —&gt; frozen (inverse value for getting same behavior).</li> <li>allow_population_by_field_name → populate_by_name</li> </ul>","path":["Usage","What is the difference between pydantic v1 and v2 output model?"],"tags":[]},{"location":"what_is_the_difference_between_v1_and_v2/#see-also","level":2,"title":"See Also","text":"<ul> <li>CLI Reference: <code>--output-model-type</code> - Select Pydantic v1 or v2 output</li> <li>CLI Reference: Model Customization - All model generation options</li> </ul>","path":["Usage","What is the difference between pydantic v1 and v2 output model?"],"tags":[]},{"location":"cli-reference/","level":1,"title":"CLI Reference","text":"<p>This documentation is auto-generated from test cases.</p> <p>Quick Reference - All options on one page for Ctrl+F search</p>","path":["CLI Reference"],"tags":[]},{"location":"cli-reference/#related-documentation","level":2,"title":"Related Documentation","text":"Topic Description Generate from OpenAPI OpenAPI schema generation guide Generate from JSON Schema JSON Schema generation guide Generate from GraphQL GraphQL schema generation guide pyproject.toml Configuration File-based configuration Custom Templates Jinja2 template customization Field Aliases Field renaming with aliases Root Models and Type Aliases Type alias generation","path":["CLI Reference"],"tags":[]},{"location":"cli-reference/#categories","level":2,"title":"Categories","text":"Category Options Description Base Options 5 Input/output configuration Typing Customization 16 Type annotation and import behavior Field Customization 20 Field naming and docstring behavior Model Customization 26 Model generation behavior Template Customization 15 Output formatting and custom rendering OpenAPI-only Options 5 OpenAPI-specific features General Options 11 Utilities and meta options","path":["CLI Reference"],"tags":[]},{"location":"cli-reference/#all-options","level":2,"title":"All Options","text":"<p>Jump to: A · B · C · D · E · F · G · H · I · K · N · O · P · R · S · T · U · V · W</p>","path":["CLI Reference"],"tags":[]},{"location":"cli-reference/#a","level":3,"title":"A","text":"<ul> <li><code>--additional-imports</code></li> <li><code>--aliases</code></li> <li><code>--all-exports-collision-strategy</code></li> <li><code>--all-exports-scope</code></li> <li><code>--allof-merge-mode</code></li> <li><code>--allow-extra-fields</code></li> <li><code>--allow-population-by-field-name</code></li> </ul>","path":["CLI Reference"],"tags":[]},{"location":"cli-reference/#b","level":3,"title":"B","text":"<ul> <li><code>--base-class</code></li> </ul>","path":["CLI Reference"],"tags":[]},{"location":"cli-reference/#c","level":3,"title":"C","text":"<ul> <li><code>--capitalize-enum-members</code></li> <li><code>--check</code></li> <li><code>--class-name</code></li> <li><code>--collapse-root-models</code></li> <li><code>--custom-file-header</code></li> <li><code>--custom-file-header-path</code></li> <li><code>--custom-formatters</code></li> <li><code>--custom-formatters-kwargs</code></li> <li><code>--custom-template-dir</code></li> </ul>","path":["CLI Reference"],"tags":[]},{"location":"cli-reference/#d","level":3,"title":"D","text":"<ul> <li><code>--dataclass-arguments</code></li> <li><code>--disable-appending-item-suffix</code></li> <li><code>--disable-future-imports</code></li> <li><code>--disable-timestamp</code></li> <li><code>--disable-warnings</code></li> </ul>","path":["CLI Reference"],"tags":[]},{"location":"cli-reference/#e","level":3,"title":"E","text":"<ul> <li><code>--empty-enum-field-name</code></li> <li><code>--enable-faux-immutability</code></li> <li><code>--enable-version-header</code></li> <li><code>--encoding</code></li> <li><code>--enum-field-as-literal</code></li> <li><code>--extra-fields</code></li> <li><code>--extra-template-data</code></li> </ul>","path":["CLI Reference"],"tags":[]},{"location":"cli-reference/#f","level":3,"title":"F","text":"<ul> <li><code>--field-constraints</code></li> <li><code>--field-extra-keys</code></li> <li><code>--field-extra-keys-without-x-prefix</code></li> <li><code>--field-include-all-keys</code></li> <li><code>--force-optional</code></li> <li><code>--formatters</code></li> <li><code>--frozen-dataclasses</code></li> </ul>","path":["CLI Reference"],"tags":[]},{"location":"cli-reference/#g","level":3,"title":"G","text":"<ul> <li><code>--generate-cli-command</code></li> <li><code>--generate-pyproject-config</code></li> </ul>","path":["CLI Reference"],"tags":[]},{"location":"cli-reference/#h","level":3,"title":"H","text":"<ul> <li><code>--http-headers</code></li> <li><code>--http-ignore-tls</code></li> <li><code>--http-query-parameters</code></li> </ul>","path":["CLI Reference"],"tags":[]},{"location":"cli-reference/#i","level":3,"title":"I","text":"<ul> <li><code>--ignore-pyproject</code></li> <li><code>--include-path-parameters</code></li> <li><code>--input</code></li> <li><code>--input-file-type</code></li> </ul>","path":["CLI Reference"],"tags":[]},{"location":"cli-reference/#k","level":3,"title":"K","text":"<ul> <li><code>--keep-model-order</code></li> <li><code>--keyword-only</code></li> </ul>","path":["CLI Reference"],"tags":[]},{"location":"cli-reference/#n","level":3,"title":"N","text":"<ul> <li><code>--no-alias</code></li> <li><code>--no-use-specialized-enum</code></li> </ul>","path":["CLI Reference"],"tags":[]},{"location":"cli-reference/#o","level":3,"title":"O","text":"<ul> <li><code>--openapi-scopes</code></li> <li><code>--original-field-name-delimiter</code></li> <li><code>--output</code></li> <li><code>--output-datetime-class</code></li> <li><code>--output-model-type</code></li> </ul>","path":["CLI Reference"],"tags":[]},{"location":"cli-reference/#p","level":3,"title":"P","text":"<ul> <li><code>--parent-scoped-naming</code></li> </ul>","path":["CLI Reference"],"tags":[]},{"location":"cli-reference/#r","level":3,"title":"R","text":"<ul> <li><code>--read-only-write-only-model-type</code></li> <li><code>--remove-special-field-name-prefix</code></li> <li><code>--reuse-model</code></li> <li><code>--reuse-scope</code></li> </ul>","path":["CLI Reference"],"tags":[]},{"location":"cli-reference/#s","level":3,"title":"S","text":"<ul> <li><code>--set-default-enum-member</code></li> <li><code>--shared-module-name</code></li> <li><code>--skip-root-model</code></li> <li><code>--snake-case-field</code></li> <li><code>--special-field-name-prefix</code></li> <li><code>--strict-nullable</code></li> <li><code>--strict-types</code></li> <li><code>--strip-default-none</code></li> </ul>","path":["CLI Reference"],"tags":[]},{"location":"cli-reference/#t","level":3,"title":"T","text":"<ul> <li><code>--target-python-version</code></li> <li><code>--treat-dot-as-module</code></li> <li><code>--type-mappings</code></li> </ul>","path":["CLI Reference"],"tags":[]},{"location":"cli-reference/#u","level":3,"title":"U","text":"<ul> <li><code>--union-mode</code></li> <li><code>--url</code></li> <li><code>--use-annotated</code></li> <li><code>--use-attribute-docstrings</code></li> <li><code>--use-decimal-for-multiple-of</code></li> <li><code>--use-default</code></li> <li><code>--use-default-kwarg</code></li> <li><code>--use-double-quotes</code></li> <li><code>--use-enum-values-in-discriminator</code></li> <li><code>--use-exact-imports</code></li> <li><code>--use-field-description</code></li> <li><code>--use-frozen-field</code></li> <li><code>--use-generic-container-types</code></li> <li><code>--use-inline-field-description</code></li> <li><code>--use-non-positive-negative-number-constrained-types</code></li> <li><code>--use-one-literal-as-default</code></li> <li><code>--use-operation-id-as-name</code></li> <li><code>--use-pendulum</code></li> <li><code>--use-schema-description</code></li> <li><code>--use-serialize-as-any</code></li> <li><code>--use-standard-collections</code></li> <li><code>--use-subclass-enum</code></li> <li><code>--use-title-as-name</code></li> <li><code>--use-type-alias</code></li> <li><code>--use-union-operator</code></li> <li><code>--use-unique-items-as-set</code></li> </ul>","path":["CLI Reference"],"tags":[]},{"location":"cli-reference/#v","level":3,"title":"V","text":"<ul> <li><code>--validation</code></li> </ul>","path":["CLI Reference"],"tags":[]},{"location":"cli-reference/#w","level":3,"title":"W","text":"<ul> <li><code>--wrap-string-literal</code></li> </ul>","path":["CLI Reference"],"tags":[]},{"location":"cli-reference/base-options/","level":1,"title":"Base Options","text":"","path":["CLI Reference","Base Options"],"tags":[]},{"location":"cli-reference/base-options/#options","level":2,"title":"Options","text":"Option Description <code>--encoding</code> Specify character encoding for input and output files. <code>--input</code> Specify the input schema file path. <code>--input-file-type</code> Specify the input file type for code generation. <code>--output</code> Specify the destination path for generated Python code. <code>--url</code> Fetch schema from URL with custom HTTP headers.","path":["CLI Reference","Base Options"],"tags":[]},{"location":"cli-reference/base-options/#encoding","level":2,"title":"<code>--encoding</code>","text":"<p>Specify character encoding for input and output files.</p> <p>The <code>--encoding</code> flag sets the character encoding used when reading the schema file and writing the generated Python code. This is useful for schemas containing non-ASCII characters (e.g., Japanese, Chinese). Default is utf-8.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --encoding utf-8 # (1)!\n</code></pre> <ol> <li> <code>--encoding</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"日本語Model\",\n  \"description\": \"モデルの説明文\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"名前\": {\n      \"type\": \"string\",\n      \"description\": \"ユーザー名\"\n    },\n    \"年齢\": {\n      \"type\": \"integer\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  encoding_test.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass 日本語Model(BaseModel):\n    名前: Optional[str] = Field(None, description='ユーザー名')\n    年齢: Optional[int] = None\n</code></pre>","path":["CLI Reference","Base Options"],"tags":[]},{"location":"cli-reference/base-options/#input","level":2,"title":"<code>--input</code>","text":"<p>Specify the input schema file path.</p> <p>The <code>--input</code> flag specifies the path to the schema file (JSON Schema, OpenAPI, GraphQL, etc.). Multiple input files can be specified to merge schemas. Required unless using <code>--url</code> to fetch schema from a URL.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --input pet_simple.json --output output.py # (1)!\n</code></pre> <ol> <li> <code>--input</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Pet\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"tag\": {\n      \"type\": \"string\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  pet_simple.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    id: Optional[int] = None\n    name: Optional[str] = None\n    tag: Optional[str] = None\n</code></pre>","path":["CLI Reference","Base Options"],"tags":[]},{"location":"cli-reference/base-options/#input-file-type","level":2,"title":"<code>--input-file-type</code>","text":"<p>Specify the input file type for code generation.</p> <p>The <code>--input-file-type</code> flag explicitly sets the input format when it cannot be auto-detected from the file extension. Supported types: openapi, jsonschema, json, yaml, csv, graphql.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --input-file-type json # (1)!\n</code></pre> <ol> <li> <code>--input-file-type</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"Pet\": {\n    \"name\": \"dog\",\n    \"age\": 2\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  pet.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    name: str\n    age: int\n\n\nclass Model(BaseModel):\n    Pet: Pet\n</code></pre>","path":["CLI Reference","Base Options"],"tags":[]},{"location":"cli-reference/base-options/#output","level":2,"title":"<code>--output</code>","text":"<p>Specify the destination path for generated Python code.</p> <p>The <code>--output</code> flag specifies where to write the generated Python code. It can be either a file path (single-file output) or a directory path (multi-file output for modular schemas). If omitted, the generated code is written to stdout.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --input pet_simple.json --output output.py # (1)!\n</code></pre> <ol> <li> <code>--output</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Pet\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"tag\": {\n      \"type\": \"string\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  pet_simple.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    id: Optional[int] = None\n    name: Optional[str] = None\n    tag: Optional[str] = None\n</code></pre>","path":["CLI Reference","Base Options"],"tags":[]},{"location":"cli-reference/base-options/#url","level":2,"title":"<code>--url</code>","text":"<p>Fetch schema from URL with custom HTTP headers.</p> <p>The <code>--url</code> flag specifies a remote URL to fetch the schema from instead of a local file. The <code>--http-headers</code> flag adds custom HTTP headers to the request, useful for authentication (e.g., Bearer tokens) or custom API requirements. Format: <code>HeaderName:HeaderValue</code>.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --url https://api.example.com/schema.json --http-headers \"Authorization:Bearer token\" # (1)!\n</code></pre> <ol> <li> <code>--url</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Pet\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"tag\": {\n      \"type\": \"string\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  https://api.example.com/schema.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    id: Optional[int] = None\n    name: Optional[str] = None\n    tag: Optional[str] = None\n</code></pre>","path":["CLI Reference","Base Options"],"tags":[]},{"location":"cli-reference/field-customization/","level":1,"title":"Field Customization","text":"","path":["CLI Reference","Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#options","level":2,"title":"Options","text":"Option Description <code>--aliases</code> Apply custom field and class name aliases from JSON file. <code>--capitalize-enum-members</code> Capitalize enum member names to UPPER_CASE format. <code>--empty-enum-field-name</code> Name for empty string enum field values. <code>--extra-fields</code> Configure how generated models handle extra fields not defin... <code>--field-constraints</code> Generate Field() with validation constraints from schema. <code>--field-extra-keys</code> Include specific extra keys in Field() definitions. <code>--field-extra-keys-without-x-prefix</code> Include specified schema extension keys in Field() without r... <code>--field-include-all-keys</code> Include all schema keys in Field() json_schema_extra. <code>--no-alias</code> Disable Field alias generation for non-Python-safe property ... <code>--original-field-name-delimiter</code> Specify delimiter for original field names when using snake-... <code>--remove-special-field-name-prefix</code> Remove the special prefix from field names. <code>--set-default-enum-member</code> Set the first enum member as the default value for enum fiel... <code>--snake-case-field</code> Convert field names to snake_case format. <code>--special-field-name-prefix</code> Prefix to add to special field names (like reserved keywords... <code>--use-attribute-docstrings</code> Generate field descriptions as attribute docstrings instead ... <code>--use-enum-values-in-discriminator</code> Use enum values in discriminator mappings for union types. <code>--use-field-description</code> Include schema descriptions as Field docstrings. <code>--use-inline-field-description</code> Add field descriptions as inline comments. <code>--use-schema-description</code> Use schema description as class docstring. <code>--use-title-as-name</code> Use schema title as the generated class name.","path":["CLI Reference","Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#aliases","level":2,"title":"<code>--aliases</code>","text":"<p>Apply custom field and class name aliases from JSON file.</p> <p>The <code>--aliases</code> option allows renaming fields and classes via a JSON mapping file, providing fine-grained control over generated names independent of schema definitions.</p> <p>See Also</p> <p>For detailed explanation and examples, see Field Aliases.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --aliases openapi/aliases.json --target-python 3.9 # (1)!\n</code></pre> <ol> <li> <code>--aliases</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: error result\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output Pydantic v1msgspec <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id_: int = Field(..., alias='id')\n    name_: str = Field(..., alias='name')\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass User(BaseModel):\n    id_: int = Field(..., alias='id')\n    name_: str = Field(..., alias='name')\n    tag: Optional[str] = None\n\n\nclass Users(BaseModel):\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    name_: Optional[str] = Field(None, alias='name')\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Annotated, List, Union\n\nfrom msgspec import UNSET, Meta, Struct, UnsetType, field\nfrom typing_extensions import TypeAlias\n\n\nclass Pet(Struct):\n    id_: int = field(name='id')\n    name_: str = field(name='name')\n    tag: Union[str, UnsetType] = UNSET\n\n\nPets: TypeAlias = List[Pet]\n\n\nclass User(Struct):\n    id_: int = field(name='id')\n    name_: str = field(name='name')\n    tag: Union[str, UnsetType] = UNSET\n\n\nUsers: TypeAlias = List[User]\n\n\nId: TypeAlias = str\n\n\nRules: TypeAlias = List[str]\n\n\nclass Error(Struct):\n    code: int\n    message: str\n\n\nclass Api(Struct):\n    apiKey: Union[\n        Annotated[str, Meta(description='To be used as a dataset parameter value')],\n        UnsetType,\n    ] = UNSET\n    apiVersionNumber: Union[\n        Annotated[str, Meta(description='To be used as a version parameter value')],\n        UnsetType,\n    ] = UNSET\n    apiUrl: Union[\n        Annotated[str, Meta(description=\"The URL describing the dataset's fields\")],\n        UnsetType,\n    ] = UNSET\n    apiDocumentationUrl: Union[\n        Annotated[str, Meta(description='A URL to the API console for each API')],\n        UnsetType,\n    ] = UNSET\n\n\nApis: TypeAlias = List[Api]\n\n\nclass Event(Struct):\n    name_: Union[str, UnsetType] = field(name='name', default=UNSET)\n\n\nclass Result(Struct):\n    event: Union[Event, UnsetType] = UNSET\n</code></pre>","path":["CLI Reference","Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#capitalize-enum-members","level":2,"title":"<code>--capitalize-enum-members</code>","text":"<p>Capitalize enum member names to UPPER_CASE format.</p> <p>The <code>--capitalize-enum-members</code> flag converts enum member names to UPPER_CASE format (e.g., <code>active</code> becomes <code>ACTIVE</code>), following Python naming conventions for constants.</p> <p>Related: <code>--snake-case-field</code></p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --capitalize-enum-members # (1)!\n</code></pre> <ol> <li> <code>--capitalize-enum-members</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"snake_case\",\n    \"CAP_CASE\",\n    \"CamelCase\",\n    \"UPPERCASE\"\n  ]\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  many_case_enum.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\n\n\nclass Model(Enum):\n    SNAKE_CASE = 'snake_case'\n    CAP_CASE = 'CAP_CASE'\n    CAMEL_CASE = 'CamelCase'\n    UPPERCASE = 'UPPERCASE'\n</code></pre>","path":["CLI Reference","Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#empty-enum-field-name","level":2,"title":"<code>--empty-enum-field-name</code>","text":"<p>Name for empty string enum field values.</p> <p>The <code>--empty-enum-field-name</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --empty-enum-field-name empty # (1)!\n</code></pre> <ol> <li> <code>--empty-enum-field-name</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"string\",\n  \"enum\": [\n    true,\n    false,\n    \"\",\n    \"\\n\",\n    \"\\r\\n\",\n    \"\\t\",\n    \"\\b\",\n    null,\n    \"\\\\\"\n  ]\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  special_enum.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass ModelEnum(Enum):\n    True_ = True\n    False_ = False\n    empty = ''\n    field_ = '\\n'\n    field__ = '\\r\\n'\n    field__1 = '\\t'\n    field__2 = '\\b'\n    field__3 = '\\\\'\n\n\nclass Model(BaseModel):\n    __root__: Optional[ModelEnum] = None\n</code></pre>","path":["CLI Reference","Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#extra-fields","level":2,"title":"<code>--extra-fields</code>","text":"<p>Configure how generated models handle extra fields not defined in schema.</p> <p>The <code>--extra-fields</code> flag sets the generated models to allow, forbid, or ignore extra fields. With <code>--extra-fields allow</code>, models will accept and store fields not defined in the schema. Options: allow, ignore, forbid.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --extra-fields allow # (1)!\n</code></pre> <ol> <li> <code>--extra-fields</code> - the option documented here</li> </ol> Input Schema <pre><code>type Person {\n    id: ID!\n    name: String!\n    height: Int\n    mass: Int\n    hair_color: String\n    skin_color: String\n    eye_color: String\n    birth_year: String\n    gender: String\n\n    # Relationships\n    homeworld_id: ID\n    homeworld: Planet\n    species: [Species!]!\n    species_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n    starships: [Starship!]!\n    starships_ids: [ID!]!\n    vehicles: [Vehicle!]!\n    vehicles_ids: [ID!]!\n}\n\ntype Planet {\n    id: ID!\n    name: String!\n    rotation_period: String\n    orbital_period: String\n    diameter: String\n    climate: String\n    gravity: String\n    terrain: String\n    surface_water: String\n    population: String\n\n    # Relationships\n    residents: [Person!]!\n    residents_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n}\n\ntype Species {\n    id: ID!\n    name: String!\n    classification: String\n    designation: String\n    average_height: String\n    skin_colors: String\n    hair_colors: String\n    eye_colors: String\n    average_lifespan: String\n    language: String\n\n    # Relationships\n    people: [Person!]!\n    people_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n}\n\ntype Vehicle {\n    id: ID!\n    name: String!\n    model: String\n    manufacturer: String\n    cost_in_credits: String\n    length: String\n    max_atmosphering_speed: String\n    crew: String\n    passengers: String\n    cargo_capacity: String\n    consumables: String\n    vehicle_class: String\n\n    # Relationships\n    pilots: [Person!]!\n    pilots_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n}\n\ntype Starship {\n    id: ID!\n    name: String!\n    model: String\n    manufacturer: String\n    cost_in_credits: String\n    length: String\n    max_atmosphering_speed: String\n    crew: String\n    passengers: String\n    cargo_capacity: String\n    consumables: String\n    hyperdrive_rating: String\n    MGLT: String\n    starship_class: String\n\n    # Relationships\n    pilots: [Person!]!\n    pilots_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n}\n\ntype Film {\n  id: ID!\n  title: String!\n  episode_id: Int!\n  opening_crawl: String!\n  director: String!\n  producer: String\n  release_date: String!\n\n  # Relationships\n  characters: [Person!]!\n  characters_ids: [ID!]!\n  planets: [Planet!]!\n  planets_ids: [ID!]!\n  starships: [Starship!]!\n  starships_ids: [ID!]!\n  vehicles: [Vehicle!]!\n  vehicles_ids: [ID!]!\n  species: [Species!]!\n  species_ids: [ID!]!\n}\n\ntype Query {\n  planet(id: ID!): Planet\n  listPlanets(page: Int): [Planet!]!\n  person(id: ID!): Person\n  listPeople(page: Int): [Person!]!\n  species(id: ID!): Species\n  listSpecies(page: Int): [Species!]!\n  film(id: ID!): Film\n  listFilms(page: Int): [Film!]!\n  starship(id: ID!): Starship\n  listStarships(page: Int): [Starship!]!\n  vehicle(id: ID!): Vehicle\n  listVehicles(page: Int): [Vehicle!]!\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  simple-star-wars.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Literal, Optional\n\nfrom pydantic import BaseModel, Extra, Field\nfrom typing_extensions import TypeAlias\n\nBoolean: TypeAlias = bool\n\"\"\"\nThe `Boolean` scalar type represents `true` or `false`.\n\"\"\"\n\n\nID: TypeAlias = str\n\"\"\"\nThe `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `\"4\"`) or integer (such as `4`) input value will be accepted as an ID.\n\"\"\"\n\n\nInt: TypeAlias = int\n\"\"\"\nThe `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\n\"\"\"\n\n\nString: TypeAlias = str\n\"\"\"\nThe `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\n\"\"\"\n\n\nclass Film(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    characters: List[Person]\n    characters_ids: List[ID]\n    director: String\n    episode_id: Int\n    id: ID\n    opening_crawl: String\n    planets: List[Planet]\n    planets_ids: List[ID]\n    producer: Optional[String] = None\n    release_date: String\n    species: List[Species]\n    species_ids: List[ID]\n    starships: List[Starship]\n    starships_ids: List[ID]\n    title: String\n    vehicles: List[Vehicle]\n    vehicles_ids: List[ID]\n    typename__: Optional[Literal['Film']] = Field('Film', alias='__typename')\n\n\nclass Person(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    birth_year: Optional[String] = None\n    eye_color: Optional[String] = None\n    films: List[Film]\n    films_ids: List[ID]\n    gender: Optional[String] = None\n    hair_color: Optional[String] = None\n    height: Optional[Int] = None\n    homeworld: Optional[Planet] = None\n    homeworld_id: Optional[ID] = None\n    id: ID\n    mass: Optional[Int] = None\n    name: String\n    skin_color: Optional[String] = None\n    species: List[Species]\n    species_ids: List[ID]\n    starships: List[Starship]\n    starships_ids: List[ID]\n    vehicles: List[Vehicle]\n    vehicles_ids: List[ID]\n    typename__: Optional[Literal['Person']] = Field('Person', alias='__typename')\n\n\nclass Planet(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    climate: Optional[String] = None\n    diameter: Optional[String] = None\n    films: List[Film]\n    films_ids: List[ID]\n    gravity: Optional[String] = None\n    id: ID\n    name: String\n    orbital_period: Optional[String] = None\n    population: Optional[String] = None\n    residents: List[Person]\n    residents_ids: List[ID]\n    rotation_period: Optional[String] = None\n    surface_water: Optional[String] = None\n    terrain: Optional[String] = None\n    typename__: Optional[Literal['Planet']] = Field('Planet', alias='__typename')\n\n\nclass Species(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    average_height: Optional[String] = None\n    average_lifespan: Optional[String] = None\n    classification: Optional[String] = None\n    designation: Optional[String] = None\n    eye_colors: Optional[String] = None\n    films: List[Film]\n    films_ids: List[ID]\n    hair_colors: Optional[String] = None\n    id: ID\n    language: Optional[String] = None\n    name: String\n    people: List[Person]\n    people_ids: List[ID]\n    skin_colors: Optional[String] = None\n    typename__: Optional[Literal['Species']] = Field('Species', alias='__typename')\n\n\nclass Starship(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    MGLT: Optional[String] = None\n    cargo_capacity: Optional[String] = None\n    consumables: Optional[String] = None\n    cost_in_credits: Optional[String] = None\n    crew: Optional[String] = None\n    films: List[Film]\n    films_ids: List[ID]\n    hyperdrive_rating: Optional[String] = None\n    id: ID\n    length: Optional[String] = None\n    manufacturer: Optional[String] = None\n    max_atmosphering_speed: Optional[String] = None\n    model: Optional[String] = None\n    name: String\n    passengers: Optional[String] = None\n    pilots: List[Person]\n    pilots_ids: List[ID]\n    starship_class: Optional[String] = None\n    typename__: Optional[Literal['Starship']] = Field('Starship', alias='__typename')\n\n\nclass Vehicle(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    cargo_capacity: Optional[String] = None\n    consumables: Optional[String] = None\n    cost_in_credits: Optional[String] = None\n    crew: Optional[String] = None\n    films: List[Film]\n    films_ids: List[ID]\n    id: ID\n    length: Optional[String] = None\n    manufacturer: Optional[String] = None\n    max_atmosphering_speed: Optional[String] = None\n    model: Optional[String] = None\n    name: String\n    passengers: Optional[String] = None\n    pilots: List[Person]\n    pilots_ids: List[ID]\n    vehicle_class: Optional[String] = None\n    typename__: Optional[Literal['Vehicle']] = Field('Vehicle', alias='__typename')\n\n\nFilm.update_forward_refs()\nPerson.update_forward_refs()\n</code></pre>","path":["CLI Reference","Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#field-constraints","level":2,"title":"<code>--field-constraints</code>","text":"<p>Generate Field() with validation constraints from schema.</p> <p>The <code>--field-constraints</code> flag generates Pydantic Field() definitions with validation constraints (min/max length, pattern, etc.) from the schema. Output differs between Pydantic v1 and v2 due to API changes.</p> <p>See Also</p> <p>For detailed explanation and mypy compatibility, see Field Constraints.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --field-constraints # (1)!\n</code></pre> <ol> <li> <code>--field-constraints</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n            minimum: 0\n            maximum: 100\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          minimum: 0\n          maximum: 9223372036854775807\n        name:\n          type: string\n          maxLength: 256\n        tag:\n          type: string\n          maxLength: 64\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n      maxItems: 10\n      minItems: 1\n      uniqueItems: true\n    UID:\n      type: integer\n      minimum: 0\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n          - uid\n        properties:\n          id:\n            type: integer\n            format: int64\n            minimum: 0\n          name:\n            type: string\n            maxLength: 256\n          tag:\n            type: string\n            maxLength: 64\n          uid:\n            $ref: '#/components/schemas/UID'\n          phones:\n            type: array\n            items:\n              type: string\n              minLength: 3\n            maxItems: 10\n          fax:\n            type: array\n            items:\n              type: string\n              minLength: 3\n          height:\n            type:\n              - integer\n              - number\n            minimum: 1\n            maximum: 300\n          weight:\n            type:\n              - number\n              - integer\n            minimum: 1.0\n            maximum: 1000.0\n          age:\n            type: integer\n            minimum: 0.0\n            maximum: 200.0\n            exclusiveMinimum: true\n          rating:\n            type: number\n            minimum: 0\n            exclusiveMinimum: True\n            maximum: 5\n\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            minLength: 1\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output Pydantic v1Pydantic v2 <pre><code># generated by datamodel-codegen:\n#   filename:  api_constrained.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional, Union\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int = Field(..., ge=0, le=9223372036854775807)\n    name: str = Field(..., max_length=256)\n    tag: Optional[str] = Field(None, max_length=64)\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet] = Field(..., max_items=10, min_items=1, unique_items=True)\n\n\nclass UID(BaseModel):\n    __root__: int = Field(..., ge=0)\n\n\nclass Phone(BaseModel):\n    __root__: str = Field(..., min_length=3)\n\n\nclass FaxItem(BaseModel):\n    __root__: str = Field(..., min_length=3)\n\n\nclass User(BaseModel):\n    id: int = Field(..., ge=0)\n    name: str = Field(..., max_length=256)\n    tag: Optional[str] = Field(None, max_length=64)\n    uid: UID\n    phones: Optional[List[Phone]] = Field(None, max_items=10)\n    fax: Optional[List[FaxItem]] = None\n    height: Optional[Union[int, float]] = Field(None, ge=1.0, le=300.0)\n    weight: Optional[Union[float, int]] = Field(None, ge=1.0, le=1000.0)\n    age: Optional[int] = Field(None, gt=0, le=200)\n    rating: Optional[float] = Field(None, gt=0.0, le=5.0)\n\n\nclass Users(BaseModel):\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  api_constrained.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional, Union\n\nfrom pydantic import AnyUrl, BaseModel, Field, RootModel\n\n\nclass Pet(BaseModel):\n    id: int = Field(..., ge=0, le=9223372036854775807)\n    name: str = Field(..., max_length=256)\n    tag: Optional[str] = Field(None, max_length=64)\n\n\nclass Pets(RootModel[List[Pet]]):\n    root: List[Pet] = Field(..., max_length=10, min_length=1)\n\n\nclass UID(RootModel[int]):\n    root: int = Field(..., ge=0)\n\n\nclass Phone(RootModel[str]):\n    root: str = Field(..., min_length=3)\n\n\nclass FaxItem(RootModel[str]):\n    root: str = Field(..., min_length=3)\n\n\nclass User(BaseModel):\n    id: int = Field(..., ge=0)\n    name: str = Field(..., max_length=256)\n    tag: Optional[str] = Field(None, max_length=64)\n    uid: UID\n    phones: Optional[List[Phone]] = Field(None, max_length=10)\n    fax: Optional[List[FaxItem]] = None\n    height: Optional[Union[int, float]] = Field(None, ge=1.0, le=300.0)\n    weight: Optional[Union[float, int]] = Field(None, ge=1.0, le=1000.0)\n    age: Optional[int] = Field(None, gt=0, le=200)\n    rating: Optional[float] = Field(None, gt=0.0, le=5.0)\n\n\nclass Users(RootModel[List[User]]):\n    root: List[User]\n\n\nclass Id(RootModel[str]):\n    root: str\n\n\nclass Rules(RootModel[List[str]]):\n    root: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(RootModel[List[Api]]):\n    root: List[Api]\n\n\nclass Event(BaseModel):\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#field-extra-keys","level":2,"title":"<code>--field-extra-keys</code>","text":"<p>Include specific extra keys in Field() definitions.</p> <p>The <code>--field-extra-keys</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --field-extra-keys key2 --field-extra-keys-without-x-prefix x-repr # (1)!\n</code></pre> <ol> <li> <code>--field-extra-keys</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Extras\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\",\n      \"description\": \"normal key\",\n      \"key1\": 123,\n      \"key2\": 456,\n      \"$exclude\": 123,\n      \"invalid-key-1\": \"abc\",\n      \"-invalid+key_2\": \"efg\",\n      \"$comment\": \"comment\",\n      \"$id\": \"#name\",\n      \"register\": \"hij\",\n      \"schema\": \"klm\",\n      \"x-repr\": true,\n      \"x-abc\": true,\n      \"example\": \"example\",\n      \"readOnly\": true\n    },\n    \"age\": {\n      \"type\": \"integer\",\n      \"example\": 12,\n      \"writeOnly\": true,\n      \"examples\": [\n        13,\n        20\n      ]\n    }\n  }\n}\n</code></pre> Output Pydantic v1Pydantic v2 <pre><code># generated by datamodel-codegen:\n#   filename:  extras.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Extras(BaseModel):\n    name: Optional[str] = Field(\n        None,\n        description='normal key',\n        example='example',\n        invalid_key_1='abc',\n        key2=456,\n        repr=True,\n    )\n    age: Optional[int] = Field(None, example=12, examples=[13, 20])\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  extras.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Extras(BaseModel):\n    name: Optional[str] = Field(\n        None,\n        description='normal key',\n        examples=['example'],\n        json_schema_extra={'key2': 456, 'invalid-key-1': 'abc'},\n        repr=True,\n    )\n    age: Optional[int] = Field(\n        None, examples=[13, 20], json_schema_extra={'example': 12}\n    )\n</code></pre>","path":["CLI Reference","Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#field-extra-keys-without-x-prefix","level":2,"title":"<code>--field-extra-keys-without-x-prefix</code>","text":"<p>Include specified schema extension keys in Field() without requiring 'x-' prefix.</p> <p>The --field-extra-keys-without-x-prefix option allows you to specify custom schema extension keys that should be included in Pydantic Field() extras without the 'x-' prefix requirement. For example, 'x-repr' in the schema becomes 'repr' in Field(). This is useful for custom schema extensions and vendor-specific metadata.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --field-include-all-keys --field-extra-keys-without-x-prefix x-repr # (1)!\n</code></pre> <ol> <li> <code>--field-extra-keys-without-x-prefix</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Extras\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\",\n      \"description\": \"normal key\",\n      \"key1\": 123,\n      \"key2\": 456,\n      \"$exclude\": 123,\n      \"invalid-key-1\": \"abc\",\n      \"-invalid+key_2\": \"efg\",\n      \"$comment\": \"comment\",\n      \"$id\": \"#name\",\n      \"register\": \"hij\",\n      \"schema\": \"klm\",\n      \"x-repr\": true,\n      \"x-abc\": true,\n      \"example\": \"example\",\n      \"readOnly\": true\n    },\n    \"age\": {\n      \"type\": \"integer\",\n      \"example\": 12,\n      \"writeOnly\": true,\n      \"examples\": [\n        13,\n        20\n      ]\n    }\n  }\n}\n</code></pre> Output Pydantic v1Pydantic v2 <pre><code># generated by datamodel-codegen:\n#   filename:  extras.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Extras(BaseModel):\n    name: Optional[str] = Field(\n        None,\n        description='normal key',\n        example='example',\n        field_comment='comment',\n        field_exclude=123,\n        field_invalid_key_2='efg',\n        invalid_key_1='abc',\n        key1=123,\n        key2=456,\n        readOnly=True,\n        register_='hij',\n        repr=True,\n        schema_='klm',\n        x_abc=True,\n    )\n    age: Optional[int] = Field(None, example=12, examples=[13, 20], writeOnly=True)\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  extras.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Extras(BaseModel):\n    name: Optional[str] = Field(\n        None,\n        description='normal key',\n        examples=['example'],\n        json_schema_extra={\n            'key1': 123,\n            'key2': 456,\n            '$exclude': 123,\n            'invalid-key-1': 'abc',\n            '-invalid+key_2': 'efg',\n            '$comment': 'comment',\n            'register': 'hij',\n            'schema': 'klm',\n            'x-abc': True,\n            'readOnly': True,\n        },\n        repr=True,\n    )\n    age: Optional[int] = Field(\n        None, examples=[13, 20], json_schema_extra={'example': 12, 'writeOnly': True}\n    )\n</code></pre>","path":["CLI Reference","Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#field-include-all-keys","level":2,"title":"<code>--field-include-all-keys</code>","text":"<p>Include all schema keys in Field() json_schema_extra.</p> <p>The <code>--field-include-all-keys</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --field-include-all-keys # (1)!\n</code></pre> <ol> <li> <code>--field-include-all-keys</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Person\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"firstName\": {\n      \"type\": \"string\",\n      \"description\": \"The person's first name.\"\n    },\n    \"lastName\": {\n      \"type\": [\"string\", \"null\"],\n      \"description\": \"The person's last name.\"\n    },\n    \"age\": {\n      \"description\": \"Age in years which must be equal to or greater than zero.\",\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"friends\": {\n      \"type\": \"array\"\n    },\n    \"comment\": {\n      \"type\": \"null\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  person.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Any, List, Optional\n\nfrom pydantic import BaseModel, Field, conint\n\n\nclass Person(BaseModel):\n    firstName: Optional[str] = Field(None, description=\"The person's first name.\")\n    lastName: Optional[str] = Field(None, description=\"The person's last name.\")\n    age: Optional[conint(ge=0)] = Field(\n        None, description='Age in years which must be equal to or greater than zero.'\n    )\n    friends: Optional[List[Any]] = None\n    comment: None = None\n</code></pre>","path":["CLI Reference","Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#no-alias","level":2,"title":"<code>--no-alias</code>","text":"<p>Disable Field alias generation for non-Python-safe property names.</p> <p>The <code>--no-alias</code> flag disables automatic alias generation when JSON property names contain characters invalid in Python (like hyphens). Without this flag, fields are renamed to Python-safe names with <code>Field(alias='original-name')</code>. With this flag, only Python-safe names are used without aliases.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --no-alias # (1)!\n</code></pre> <ol> <li> <code>--no-alias</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Person\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"first-name\": {\n      \"type\": \"string\"\n    },\n    \"last-name\": {\n      \"type\": \"string\"\n    },\n    \"email_address\": {\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\"first-name\", \"last-name\"]\n}\n</code></pre> Output With OptionWithout Option <pre><code># generated by datamodel-codegen:\n#   filename:  no_alias.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Person(BaseModel):\n    first_name: str\n    last_name: str\n    email_address: Optional[str] = None\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  no_alias.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Person(BaseModel):\n    first_name: str = Field(..., alias='first-name')\n    last_name: str = Field(..., alias='last-name')\n    email_address: Optional[str] = None\n</code></pre>","path":["CLI Reference","Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#original-field-name-delimiter","level":2,"title":"<code>--original-field-name-delimiter</code>","text":"<p>Specify delimiter for original field names when using snake-case conversion.</p> <p>The <code>--original-field-name-delimiter</code> option works with <code>--snake-case-field</code> to specify the delimiter used in original field names. This is useful when field names contain delimiters like spaces or hyphens that should be treated as word boundaries during snake_case conversion.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --snake-case-field --original-field-name-delimiter \" \" # (1)!\n</code></pre> <ol> <li> <code>--original-field-name-delimiter</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"SpaceIF\": {\n      \"$ref\": \"#/definitions/SpaceIF\"\n    }\n  },\n  \"definitions\": {\n    \"SpaceIF\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"Space Field\"\n      ]\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  space_field_enum.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass SpaceIF(Enum):\n    space_field = 'Space Field'\n\n\nclass Model(BaseModel):\n    space_if: Optional[SpaceIF] = Field(None, alias='SpaceIF')\n</code></pre>","path":["CLI Reference","Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#remove-special-field-name-prefix","level":2,"title":"<code>--remove-special-field-name-prefix</code>","text":"<p>Remove the special prefix from field names.</p> <p>The <code>--remove-special-field-name-prefix</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --remove-special-field-name-prefix # (1)!\n</code></pre> <ol> <li> <code>--remove-special-field-name-prefix</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n    \"$id\": \"schema_v2.json\",\n    \"$schema\": \"http://json-schema.org/schema#\",\n\n    \"type\": \"object\",\n    \"properties\": {\n        \"@id\": {\n            \"type\": \"string\",\n            \"format\": \"uri\",\n            \"pattern\": \"^http.*$\",\n            \"title\": \"Id must be presesnt and must be a URI\"\n        },\n        \"@type\": { \"type\": \"string\" },\n        \"@+!type\": { \"type\": \"string\" },\n        \"@-!type\": { \"type\": \"string\" },\n        \"profile\": { \"type\": \"string\" }\n    },\n    \"required\": [\"@id\", \"@type\"]\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  special_prefix_model.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Model(BaseModel):\n    id: AnyUrl = Field(..., alias='@id', title='Id must be presesnt and must be a URI')\n    type: str = Field(..., alias='@type')\n    type_1: Optional[str] = Field(None, alias='@+!type')\n    type_2: Optional[str] = Field(None, alias='@-!type')\n    profile: Optional[str] = None\n</code></pre>","path":["CLI Reference","Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#set-default-enum-member","level":2,"title":"<code>--set-default-enum-member</code>","text":"<p>Set the first enum member as the default value for enum fields.</p> <p>The <code>--set-default-enum-member</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --reuse-model --set-default-enum-member # (1)!\n</code></pre> <ol> <li> <code>--set-default-enum-member</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema\",\n  \"title\": \"User\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"animal\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"dog\",\n        \"cat\",\n        \"snake\"\n      ],\n      \"default\": \"dog\"\n    },\n    \"pet\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"dog\",\n        \"cat\",\n        \"snake\"\n      ],\n      \"default\": \"cat\"\n    },\n    \"redistribute\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\",\n        \"enum\": [\n          \"static\",\n          \"connected\"\n        ]\n      }\n    }\n  },\n  \"definitions\": {\n    \"redistribute\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\",\n        \"enum\": [\n          \"static\",\n          \"connected\"\n        ]\n      },\n      \"description\": \"Redistribute type for routes.\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  duplicate_enum.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Animal(Enum):\n    dog = 'dog'\n    cat = 'cat'\n    snake = 'snake'\n\n\nclass RedistributeEnum(Enum):\n    static = 'static'\n    connected = 'connected'\n\n\nclass User(BaseModel):\n    name: Optional[str] = None\n    animal: Optional[Animal] = Animal.dog\n    pet: Optional[Animal] = Animal.cat\n    redistribute: Optional[List[RedistributeEnum]] = None\n\n\nclass Redistribute(BaseModel):\n    __root__: List[RedistributeEnum] = Field(\n        ..., description='Redistribute type for routes.'\n    )\n</code></pre>","path":["CLI Reference","Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#snake-case-field","level":2,"title":"<code>--snake-case-field</code>","text":"<p>Convert field names to snake_case format.</p> <p>The <code>--snake-case-field</code> flag converts camelCase or PascalCase field names to snake_case format in the generated Python code, following Python naming conventions (PEP 8).</p> <p>Related: <code>--capitalize-enum-members</code></p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --snake-case-field # (1)!\n</code></pre> <ol> <li> <code>--snake-case-field</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"InvalidEnum\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"1 value\",\n    \" space\",\n    \"*- special\",\n    \"schema\",\n    \"MRO\",\n    \"mro\"\n  ]\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  invalid_enum_name.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\n\n\nclass InvalidEnum(Enum):\n    field_1_value = '1 value'\n    field_space = ' space'\n    field___special = '*- special'\n    schema = 'schema'\n    mro_1 = 'MRO'\n    mro_ = 'mro'\n</code></pre>","path":["CLI Reference","Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#special-field-name-prefix","level":2,"title":"<code>--special-field-name-prefix</code>","text":"<p>Prefix to add to special field names (like reserved keywords).</p> <p>The <code>--special-field-name-prefix</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --special-field-name-prefix special # (1)!\n</code></pre> <ol> <li> <code>--special-field-name-prefix</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"string\",\n  \"enum\": [\n    true,\n    false,\n    \"\",\n    \"\\n\",\n    \"\\r\\n\",\n    \"\\t\",\n    \"\\b\",\n    null,\n    \"\\\\\"\n  ]\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  special_enum.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass ModelEnum(Enum):\n    True_ = True\n    False_ = False\n    special_ = ''\n    special__1 = '\\n'\n    special__ = '\\r\\n'\n    special__2 = '\\t'\n    special__3 = '\\b'\n    special__4 = '\\\\'\n\n\nclass Model(BaseModel):\n    __root__: Optional[ModelEnum] = None\n</code></pre>","path":["CLI Reference","Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#use-attribute-docstrings","level":2,"title":"<code>--use-attribute-docstrings</code>","text":"<p>Generate field descriptions as attribute docstrings instead of Field descriptions.</p> <p>The <code>--use-attribute-docstrings</code> flag places field descriptions in Python docstring format (PEP 224 attribute docstrings) rather than in Field(..., description=...). This provides better IDE support for hovering over attributes. Requires <code>--use-field-description</code> to be enabled.</p> <p>Related: <code>--use-field-description</code></p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --output-model-type pydantic_v2.BaseModel --use-field-description --use-attribute-docstrings # (1)!\n</code></pre> <ol> <li> <code>--use-attribute-docstrings</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"object\",\n  \"title\": \"Person\",\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\",\n      \"description\": \"The person's full name\"\n    },\n    \"age\": {\n      \"type\": \"integer\",\n      \"description\": \"The person's age in years\"\n    }\n  },\n  \"required\": [\"name\"]\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  use_attribute_docstrings_test.json\n#   timestamp: 1985-10-26T08:21:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Person(BaseModel):\n    model_config = ConfigDict(\n        use_attribute_docstrings=True,\n    )\n    name: str\n    \"\"\"\n    The person's full name\n    \"\"\"\n    age: Optional[int] = None\n    \"\"\"\n    The person's age in years\n    \"\"\"\n</code></pre>","path":["CLI Reference","Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#use-enum-values-in-discriminator","level":2,"title":"<code>--use-enum-values-in-discriminator</code>","text":"<p>Use enum values in discriminator mappings for union types.</p> <p>The <code>--use-enum-values-in-discriminator</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-enum-values-in-discriminator --output-model-type pydantic_v2.BaseModel # (1)!\n</code></pre> <ol> <li> <code>--use-enum-values-in-discriminator</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ncomponents:\n  schemas:\n    Request:\n      oneOf:\n        - $ref: '#/components/schemas/RequestV1'\n        - $ref: '#/components/schemas/RequestV2'\n      discriminator:\n        propertyName: version\n        mapping:\n          v1: '#/components/schemas/RequestV1'\n          v2: '#/components/schemas/RequestV2'\n\n    RequestVersionEnum:\n      type: string\n      description: this is not included!\n      title: no title!\n      enum:\n        - v1\n        - v2\n    RequestBase:\n      properties:\n        version:\n          $ref: '#/components/schemas/RequestVersionEnum'\n      required:\n        - version\n\n    RequestV1:\n      allOf:\n        - $ref: '#/components/schemas/RequestBase'\n      properties:\n        request_id:\n          type: string\n          title: test title\n          description: there is description\n      required:\n        - request_id\n    RequestV2:\n      allOf:\n        - $ref: '#/components/schemas/RequestBase'\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  discriminator_enum.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, RootModel\n\n\nclass RequestVersionEnum(Enum):\n    v1 = 'v1'\n    v2 = 'v2'\n\n\nclass RequestBase(BaseModel):\n    version: RequestVersionEnum\n\n\nclass RequestV1(RequestBase):\n    request_id: str = Field(..., description='there is description', title='test title')\n    version: Literal[RequestVersionEnum.v1]\n\n\nclass RequestV2(RequestBase):\n    version: Literal[RequestVersionEnum.v2]\n\n\nclass Request(RootModel[Union[RequestV1, RequestV2]]):\n    root: Union[RequestV1, RequestV2] = Field(..., discriminator='version')\n</code></pre>","path":["CLI Reference","Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#use-field-description","level":2,"title":"<code>--use-field-description</code>","text":"<p>Include schema descriptions as Field docstrings.</p> <p>The <code>--use-field-description</code> flag extracts the <code>description</code> property from schema fields and includes them as docstrings or Field descriptions in the generated models, preserving documentation from the original schema.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-type-alias --use-field-description # (1)!\n</code></pre> <ol> <li> <code>--use-field-description</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"definitions\": {\n    \"SimpleString\": {\n      \"type\": \"string\"\n    },\n    \"UnionType\": {\n      \"anyOf\": [\n        {\"type\": \"string\"},\n        {\"type\": \"integer\"}\n      ]\n    },\n    \"ArrayType\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"}\n    },\n    \"AnnotatedType\": {\n      \"title\": \"MyAnnotatedType\",\n      \"description\": \"An annotated union type\",\n      \"anyOf\": [\n        {\"type\": \"string\"},\n        {\"type\": \"boolean\"}\n      ]\n    },\n    \"ModelWithTypeAliasField\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"simple_field\": {\"$ref\": \"#/definitions/SimpleString\"},\n        \"union_field\": {\"$ref\": \"#/definitions/UnionType\"},\n        \"array_field\": {\"$ref\": \"#/definitions/ArrayType\"},\n        \"annotated_field\": {\"$ref\": \"#/definitions/AnnotatedType\"}\n      }\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  type_alias.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Annotated, Any, List, Optional, Union\n\nfrom pydantic import BaseModel, Field\nfrom typing_extensions import TypeAlias\n\nModel: TypeAlias = Any\n\n\nSimpleString: TypeAlias = str\n\n\nUnionType: TypeAlias = Union[str, int]\n\n\nArrayType: TypeAlias = List[str]\n\n\nAnnotatedType: TypeAlias = Annotated[\n    Union[str, bool], Field(..., title='MyAnnotatedType')\n]\n\"\"\"\nAn annotated union type\n\"\"\"\n\n\nclass ModelWithTypeAliasField(BaseModel):\n    simple_field: Optional[SimpleString] = None\n    union_field: Optional[UnionType] = None\n    array_field: Optional[ArrayType] = None\n    annotated_field: Optional[AnnotatedType] = None\n</code></pre>","path":["CLI Reference","Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#use-inline-field-description","level":2,"title":"<code>--use-inline-field-description</code>","text":"<p>Add field descriptions as inline comments.</p> <p>The <code>--use-inline-field-description</code> flag adds the <code>description</code> property from schema fields as inline comments after each field definition. This provides documentation without using Field() wrappers.</p> <p>Related: <code>--use-field-description</code>, <code>--use-schema-description</code></p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-inline-field-description # (1)!\n</code></pre> <ol> <li> <code>--use-inline-field-description</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: \"error result.\\nNow with multi-line docstrings.\"\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: \"To be used as a dataset parameter value.\\nNow also with multi-line docstrings.\"\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  api_multiline_docstrings.yaml\n#   timestamp: 2022-11-11T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(BaseModel):\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None,\n        description='To be used as a dataset parameter value.\\nNow also with multi-line docstrings.',\n    )\n    \"\"\"\n    To be used as a dataset parameter value.\n    Now also with multi-line docstrings.\n    \"\"\"\n\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    \"\"\"To be used as a version parameter value\"\"\"\n\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    \"\"\"The URL describing the dataset's fields\"\"\"\n\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n    \"\"\"A URL to the API console for each API\"\"\"\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#use-schema-description","level":2,"title":"<code>--use-schema-description</code>","text":"<p>Use schema description as class docstring.</p> <p>The <code>--use-schema-description</code> flag extracts the <code>description</code> property from schema definitions and adds it as a docstring to the generated class. This is useful for preserving documentation from your schema in the generated code.</p> <p>Related: <code>--use-field-description</code>, <code>--use-inline-field-description</code></p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-schema-description # (1)!\n</code></pre> <ol> <li> <code>--use-schema-description</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: \"error result.\\nNow with multi-line docstrings.\"\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: \"To be used as a dataset parameter value.\\nNow also with multi-line docstrings.\"\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  api_multiline_docstrings.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(BaseModel):\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    \"\"\"\n    error result.\n    Now with multi-line docstrings.\n    \"\"\"\n\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None,\n        description='To be used as a dataset parameter value.\\nNow also with multi-line docstrings.',\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    \"\"\"\n    Event object\n    \"\"\"\n\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#use-title-as-name","level":2,"title":"<code>--use-title-as-name</code>","text":"<p>Use schema title as the generated class name.</p> <p>The <code>--use-title-as-name</code> flag uses the <code>title</code> property from the schema as the class name instead of deriving it from the property name or path. This is useful when schemas have descriptive titles that should be preserved.</p> <p>Related: <code>--class-name</code></p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-title-as-name # (1)!\n</code></pre> <ol> <li> <code>--use-title-as-name</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"definitions\": {\n    \"ProcessingStatus\": {\n      \"title\": \"Processing Status Title\",\n      \"enum\": [\n        \"COMPLETED\",\n        \"PENDING\",\n        \"FAILED\"\n      ],\n      \"type\": \"string\",\n      \"description\": \"The processing status\"\n    },\n    \"kind\": {\n      \"type\": \"string\"\n    },\n    \"ExtendedProcessingTask\": {\n      \"title\": \"Extended Processing Task Title\",\n      \"oneOf\": [\n        {\n          \"$ref\": \"#\"\n        },\n        {\n          \"type\": \"object\",\n          \"title\": \"NestedCommentTitle\",\n          \"properties\": {\n            \"comment\": {\n              \"type\": \"string\"\n            }\n          }\n        }\n      ]\n    },\n    \"ExtendedProcessingTasks\": {\n      \"title\": \"Extended Processing Tasks Title\",\n      \"type\": \"array\",\n      \"items\": [\n        {\n          \"$ref\": \"#/definitions/ExtendedProcessingTask\"\n        }\n      ]\n    },\n    \"ProcessingTask\": {\n      \"title\": \"Processing Task Title\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"processing_status_union\": {\n          \"title\": \"Processing Status Union Title\",\n          \"oneOf\": [\n            {\n              \"title\": \"Processing Status Detail\",\n              \"type\": \"object\",\n              \"properties\": {\n                \"id\": {\n                  \"type\": \"integer\"\n                },\n                \"description\": {\n                  \"type\": \"string\"\n                }\n              }\n            },\n            {\n              \"$ref\": \"#/definitions/ExtendedProcessingTask\"\n            },\n            {\n              \"$ref\": \"#/definitions/ProcessingStatus\"\n            }\n          ],\n          \"default\": \"COMPLETED\"\n        },\n        \"processing_status\": {\n          \"$ref\": \"#/definitions/ProcessingStatus\",\n          \"default\": \"COMPLETED\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"kind\": {\n          \"$ref\": \"#/definitions/kind\"\n        }\n      }\n    }\n  },\n  \"title\": \"Processing Tasks Title\",\n  \"type\": \"array\",\n      \"items\": [\n        {\n          \"$ref\": \"#/definitions/ProcessingTask\"\n        }\n      ]\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  titles.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import List, Optional, Union\n\nfrom pydantic import BaseModel, Field\n\n\nclass ProcessingStatusTitle(Enum):\n    COMPLETED = 'COMPLETED'\n    PENDING = 'PENDING'\n    FAILED = 'FAILED'\n\n\nclass Kind(BaseModel):\n    __root__: str\n\n\nclass NestedCommentTitle(BaseModel):\n    comment: Optional[str] = None\n\n\nclass ProcessingStatusDetail(BaseModel):\n    id: Optional[int] = None\n    description: Optional[str] = None\n\n\nclass ProcessingTasksTitle(BaseModel):\n    __root__: List[ProcessingTaskTitle] = Field(..., title='Processing Tasks Title')\n\n\nclass ExtendedProcessingTask(BaseModel):\n    __root__: Union[ProcessingTasksTitle, NestedCommentTitle] = Field(\n        ..., title='Extended Processing Task Title'\n    )\n\n\nclass ExtendedProcessingTasksTitle(BaseModel):\n    __root__: List[ExtendedProcessingTask] = Field(\n        ..., title='Extended Processing Tasks Title'\n    )\n\n\nclass ProcessingTaskTitle(BaseModel):\n    processing_status_union: Optional[\n        Union[ProcessingStatusDetail, ExtendedProcessingTask, ProcessingStatusTitle]\n    ] = Field('COMPLETED', title='Processing Status Union Title')\n    processing_status: Optional[ProcessingStatusTitle] = 'COMPLETED'\n    name: Optional[str] = None\n    kind: Optional[Kind] = None\n\n\nProcessingTasksTitle.update_forward_refs()\n</code></pre>","path":["CLI Reference","Field Customization"],"tags":[]},{"location":"cli-reference/general-options/","level":1,"title":"General Options","text":"","path":["CLI Reference","General Options"],"tags":[]},{"location":"cli-reference/general-options/#options","level":2,"title":"Options","text":"Option Description <code>--all-exports-collision-strategy</code> Handle name collisions when exporting recursive module hiera... <code>--all-exports-scope</code> Generate all exports for child modules in init.py fi... <code>--check</code> Verify generated code matches existing output without modify... <code>--disable-warnings</code> Suppress warning messages during code generation. <code>--generate-cli-command</code> Generate CLI command from pyproject.toml configuration. <code>--generate-pyproject-config</code> Generate pyproject.toml configuration from CLI arguments. <code>--http-headers</code> Fetch schema from URL with custom HTTP headers. <code>--http-ignore-tls</code> Disable TLS certificate verification for HTTPS requests. <code>--http-query-parameters</code> Add query parameters to HTTP requests for remote schemas. <code>--ignore-pyproject</code> Ignore pyproject.toml configuration file. <code>--shared-module-name</code> Customize the name of the shared module for deduplicated mod...","path":["CLI Reference","General Options"],"tags":[]},{"location":"cli-reference/general-options/#all-exports-collision-strategy","level":2,"title":"<code>--all-exports-collision-strategy</code>","text":"<p>Handle name collisions when exporting recursive module hierarchies.</p> <p>The <code>--all-exports-collision-strategy</code> flag determines how to resolve naming conflicts when using <code>--all-exports-scope=recursive</code>. The 'minimal-prefix' strategy adds the minimum module path prefix needed to disambiguate colliding names, while 'full-prefix' uses the complete module path. Requires <code>--all-exports-scope=recursive</code>.</p> <p>Related: <code>--all-exports-scope</code></p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --all-exports-scope recursive --all-exports-collision-strategy minimal-prefix # (1)!\n</code></pre> <ol> <li> <code>--all-exports-collision-strategy</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Modular Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/collections.Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/collections.Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    models.Species:\n      type: string\n      enum:\n        - dog\n        - cat\n        - snake\n    models.Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        tag:\n          type: string\n        species:\n          $ref: '#/components/schemas/models.Species'\n    models.User:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        tag:\n          type: string\n    collections.Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/models.Pet\"\n    collections.Users:\n      type: array\n      items:\n        $ref: \"#/components/schemas/models.User\"\n    optional:\n      type: string\n    Id:\n      type: string\n    collections.Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    collections.apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n          stage:\n            type: string\n            enum: [\n              \"test\",\n              \"dev\",\n              \"stg\",\n              \"prod\"\n            ]\n    models.Event:\n      type: object\n      properties:\n        name:\n          anyOf:\n            - type: string\n            - type: number\n            - type: integer\n            - type: boolean\n            - type: object\n            - type: array\n              items:\n                type: string\n    Result:\n      type: object\n      properties:\n        event:\n          $ref: '#/components/schemas/models.Event'\n    foo.bar.Thing:\n      properties:\n        attributes:\n          type: object\n    foo.bar.Thang:\n      properties:\n        attributes:\n          type: array\n          items:\n            type: object\n    foo.bar.Clone:\n      allOf:\n        - $ref: '#/components/schemas/foo.bar.Thing'\n        - type: object\n          properties:\n            others:\n              type: object\n              properties:\n                 name:\n                   type: string\n\n    foo.Tea:\n      properties:\n        flavour:\n          type: string\n        id:\n          $ref: '#/components/schemas/Id'\n    Source:\n      properties:\n        country:\n          type: string\n    foo.Cocoa:\n      properties:\n        quality:\n          type: integer\n    bar.Field:\n      type: string\n      example: green\n    woo.boo.Chocolate:\n      properties:\n        flavour:\n          type: string\n        source:\n          $ref: '#/components/schemas/Source'\n        cocoa:\n          $ref: '#/components/schemas/foo.Cocoa'\n        field:\n          $ref: '#/components/schemas/bar.Field'\n    differentTea:\n      type: object\n      properties:\n        foo:\n          $ref: '#/components/schemas/foo.Tea'\n        nested:\n          $ref: '#/components/schemas/nested.foo.Tea'\n    nested.foo.Tea:\n      properties:\n        flavour:\n          type: string\n        id:\n          $ref: '#/components/schemas/Id'\n        self:\n          $ref: '#/components/schemas/nested.foo.Tea'\n        optional:\n          type: array\n          items:\n            $ref: '#/components/schemas/optional'\n    nested.foo.TeaClone:\n      properties:\n        flavour:\n          type: string\n        id:\n          $ref: '#/components/schemas/Id'\n        self:\n          $ref: '#/components/schemas/nested.foo.Tea'\n        optional:\n          type: array\n          items:\n            $ref: '#/components/schemas/optional'\n    nested.foo.List:\n      type: array\n      items:\n        $ref: '#/components/schemas/nested.foo.Tea'\n</code></pre> Output <pre><code># __init__.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom ._internal import DifferentTea, Error, Id, OptionalModel, Result, Source\n\n__all__ = [\"DifferentTea\", \"Error\", \"Id\", \"OptionalModel\", \"Result\", \"Source\"]\n\n# _internal.py\n# generated by datamodel-codegen:\n#   filename:  _internal\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel\n\nfrom . import models\n\n\nclass OptionalModel(BaseModel):\n    __root__: str\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Result(BaseModel):\n    event: Optional[models.Event] = None\n\n\nclass Source(BaseModel):\n    country: Optional[str] = None\n\n\nclass DifferentTea(BaseModel):\n    foo: Optional[Tea] = None\n    nested: Optional[Tea_1] = None\n\n\nclass Tea(BaseModel):\n    flavour: Optional[str] = None\n    id: Optional[Id] = None\n\n\nclass Cocoa(BaseModel):\n    quality: Optional[int] = None\n\n\nclass Tea_1(BaseModel):\n    flavour: Optional[str] = None\n    id: Optional[Id] = None\n    self: Optional[Tea_1] = None\n    optional: Optional[List[OptionalModel]] = None\n\n\nclass TeaClone(BaseModel):\n    flavour: Optional[str] = None\n    id: Optional[Id] = None\n    self: Optional[Tea_1] = None\n    optional: Optional[List[OptionalModel]] = None\n\n\nclass ListModel(BaseModel):\n    __root__: List[Tea_1]\n\n\nTea_1.update_forward_refs()\n\n# bar.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel, Field\n\n\nclass FieldModel(BaseModel):\n    __root__: str = Field(..., example='green')\n\n# collections.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\nfrom . import models\n\n\nclass Pets(BaseModel):\n    __root__: List[models.Pet]\n\n\nclass Users(BaseModel):\n    __root__: List[models.User]\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Stage(Enum):\n    test = 'test'\n    dev = 'dev'\n    stg = 'stg'\n    prod = 'prod'\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n    stage: Optional[Stage] = None\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n# foo/__init__.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom .._internal import Cocoa, Tea\n\n__all__ = [\"Cocoa\", \"Tea\"]\n\n# foo/bar.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom __future__ import annotations\n\nfrom typing import Any, Dict, List, Optional\n\nfrom pydantic import BaseModel\n\n\nclass Thing(BaseModel):\n    attributes: Optional[Dict[str, Any]] = None\n\n\nclass Thang(BaseModel):\n    attributes: Optional[List[Dict[str, Any]]] = None\n\n\nclass Others(BaseModel):\n    name: Optional[str] = None\n\n\nclass Clone(Thing):\n    others: Optional[Others] = None\n\n# models.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Union\n\nfrom pydantic import BaseModel\n\n\nclass Species(Enum):\n    dog = 'dog'\n    cat = 'cat'\n    snake = 'snake'\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n    species: Optional[Species] = None\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Event(BaseModel):\n    name: Optional[Union[str, float, int, bool, Dict[str, Any], List[str]]] = None\n\n# nested/__init__.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\n# nested/foo.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom .._internal import ListModel\nfrom .._internal import Tea_1 as Tea\nfrom .._internal import TeaClone\n\n__all__ = [\"ListModel\", \"Tea\", \"TeaClone\"]\n\n# woo/__init__.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom __future__ import annotations\n\nfrom .boo import Chocolate\n\n__all__ = [\n    \"Chocolate\",\n]\n\n# woo/boo.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\nfrom .. import bar\nfrom .._internal import Cocoa, Source\n\n\nclass Chocolate(BaseModel):\n    flavour: Optional[str] = None\n    source: Optional[Source] = None\n    cocoa: Optional[Cocoa] = None\n    field: Optional[bar.FieldModel] = None\n</code></pre>","path":["CLI Reference","General Options"],"tags":[]},{"location":"cli-reference/general-options/#all-exports-scope","level":2,"title":"<code>--all-exports-scope</code>","text":"<p>Generate all exports for child modules in init.py files.</p> <p>The <code>--all-exports-scope=children</code> flag adds all to each init.py containing exports from direct child modules. This improves IDE autocomplete and explicit exports. Use 'recursive' to include all descendant exports with collision handling.</p> <p>Related: <code>--all-exports-collision-strategy</code></p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --all-exports-scope children # (1)!\n</code></pre> <ol> <li> <code>--all-exports-scope</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Modular Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/collections.Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/collections.Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    models.Species:\n      type: string\n      enum:\n        - dog\n        - cat\n        - snake\n    models.Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        tag:\n          type: string\n        species:\n          $ref: '#/components/schemas/models.Species'\n    models.User:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        tag:\n          type: string\n    collections.Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/models.Pet\"\n    collections.Users:\n      type: array\n      items:\n        $ref: \"#/components/schemas/models.User\"\n    optional:\n      type: string\n    Id:\n      type: string\n    collections.Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    collections.apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n          stage:\n            type: string\n            enum: [\n              \"test\",\n              \"dev\",\n              \"stg\",\n              \"prod\"\n            ]\n    models.Event:\n      type: object\n      properties:\n        name:\n          anyOf:\n            - type: string\n            - type: number\n            - type: integer\n            - type: boolean\n            - type: object\n            - type: array\n              items:\n                type: string\n    Result:\n      type: object\n      properties:\n        event:\n          $ref: '#/components/schemas/models.Event'\n    foo.bar.Thing:\n      properties:\n        attributes:\n          type: object\n    foo.bar.Thang:\n      properties:\n        attributes:\n          type: array\n          items:\n            type: object\n    foo.bar.Clone:\n      allOf:\n        - $ref: '#/components/schemas/foo.bar.Thing'\n        - type: object\n          properties:\n            others:\n              type: object\n              properties:\n                 name:\n                   type: string\n\n    foo.Tea:\n      properties:\n        flavour:\n          type: string\n        id:\n          $ref: '#/components/schemas/Id'\n    Source:\n      properties:\n        country:\n          type: string\n    foo.Cocoa:\n      properties:\n        quality:\n          type: integer\n    bar.Field:\n      type: string\n      example: green\n    woo.boo.Chocolate:\n      properties:\n        flavour:\n          type: string\n        source:\n          $ref: '#/components/schemas/Source'\n        cocoa:\n          $ref: '#/components/schemas/foo.Cocoa'\n        field:\n          $ref: '#/components/schemas/bar.Field'\n    differentTea:\n      type: object\n      properties:\n        foo:\n          $ref: '#/components/schemas/foo.Tea'\n        nested:\n          $ref: '#/components/schemas/nested.foo.Tea'\n    nested.foo.Tea:\n      properties:\n        flavour:\n          type: string\n        id:\n          $ref: '#/components/schemas/Id'\n        self:\n          $ref: '#/components/schemas/nested.foo.Tea'\n        optional:\n          type: array\n          items:\n            $ref: '#/components/schemas/optional'\n    nested.foo.TeaClone:\n      properties:\n        flavour:\n          type: string\n        id:\n          $ref: '#/components/schemas/Id'\n        self:\n          $ref: '#/components/schemas/nested.foo.Tea'\n        optional:\n          type: array\n          items:\n            $ref: '#/components/schemas/optional'\n    nested.foo.List:\n      type: array\n      items:\n        $ref: '#/components/schemas/nested.foo.Tea'\n</code></pre> Output <pre><code># __init__.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom ._internal import DifferentTea, Error, Id, OptionalModel, Result, Source\n\n__all__ = [\"DifferentTea\", \"Error\", \"Id\", \"OptionalModel\", \"Result\", \"Source\"]\n\n# _internal.py\n# generated by datamodel-codegen:\n#   filename:  _internal\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel\n\nfrom . import models\n\n\nclass OptionalModel(BaseModel):\n    __root__: str\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Result(BaseModel):\n    event: Optional[models.Event] = None\n\n\nclass Source(BaseModel):\n    country: Optional[str] = None\n\n\nclass DifferentTea(BaseModel):\n    foo: Optional[Tea] = None\n    nested: Optional[Tea_1] = None\n\n\nclass Tea(BaseModel):\n    flavour: Optional[str] = None\n    id: Optional[Id] = None\n\n\nclass Cocoa(BaseModel):\n    quality: Optional[int] = None\n\n\nclass Tea_1(BaseModel):\n    flavour: Optional[str] = None\n    id: Optional[Id] = None\n    self: Optional[Tea_1] = None\n    optional: Optional[List[OptionalModel]] = None\n\n\nclass TeaClone(BaseModel):\n    flavour: Optional[str] = None\n    id: Optional[Id] = None\n    self: Optional[Tea_1] = None\n    optional: Optional[List[OptionalModel]] = None\n\n\nclass ListModel(BaseModel):\n    __root__: List[Tea_1]\n\n\nTea_1.update_forward_refs()\n\n# bar.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel, Field\n\n\nclass FieldModel(BaseModel):\n    __root__: str = Field(..., example='green')\n\n# collections.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\nfrom . import models\n\n\nclass Pets(BaseModel):\n    __root__: List[models.Pet]\n\n\nclass Users(BaseModel):\n    __root__: List[models.User]\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Stage(Enum):\n    test = 'test'\n    dev = 'dev'\n    stg = 'stg'\n    prod = 'prod'\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n    stage: Optional[Stage] = None\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n# foo/__init__.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom .._internal import Cocoa, Tea\n\n__all__ = [\"Cocoa\", \"Tea\"]\n\n# foo/bar.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom __future__ import annotations\n\nfrom typing import Any, Dict, List, Optional\n\nfrom pydantic import BaseModel\n\n\nclass Thing(BaseModel):\n    attributes: Optional[Dict[str, Any]] = None\n\n\nclass Thang(BaseModel):\n    attributes: Optional[List[Dict[str, Any]]] = None\n\n\nclass Others(BaseModel):\n    name: Optional[str] = None\n\n\nclass Clone(Thing):\n    others: Optional[Others] = None\n\n# models.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Union\n\nfrom pydantic import BaseModel\n\n\nclass Species(Enum):\n    dog = 'dog'\n    cat = 'cat'\n    snake = 'snake'\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n    species: Optional[Species] = None\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Event(BaseModel):\n    name: Optional[Union[str, float, int, bool, Dict[str, Any], List[str]]] = None\n\n# nested/__init__.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\n# nested/foo.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom .._internal import ListModel\nfrom .._internal import Tea_1 as Tea\nfrom .._internal import TeaClone\n\n__all__ = [\"ListModel\", \"Tea\", \"TeaClone\"]\n\n# woo/__init__.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom __future__ import annotations\n\nfrom .boo import Chocolate\n\n__all__ = [\n    \"Chocolate\",\n]\n\n# woo/boo.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\nfrom .. import bar\nfrom .._internal import Cocoa, Source\n\n\nclass Chocolate(BaseModel):\n    flavour: Optional[str] = None\n    source: Optional[Source] = None\n    cocoa: Optional[Cocoa] = None\n    field: Optional[bar.FieldModel] = None\n</code></pre>","path":["CLI Reference","General Options"],"tags":[]},{"location":"cli-reference/general-options/#check","level":2,"title":"<code>--check</code>","text":"<p>Verify generated code matches existing output without modifying files.</p> <p>The <code>--check</code> flag compares the generated output with existing files and exits with a non-zero status if they differ. Useful for CI/CD validation to ensure schemas and generated code stay in sync. Works with both single files and directory outputs.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --disable-timestamp --check # (1)!\n</code></pre> <ol> <li> <code>--check</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Person\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"firstName\": {\n      \"type\": \"string\",\n      \"description\": \"The person's first name.\"\n    },\n    \"lastName\": {\n      \"type\": [\"string\", \"null\"],\n      \"description\": \"The person's last name.\"\n    },\n    \"age\": {\n      \"description\": \"Age in years which must be equal to or greater than zero.\",\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"friends\": {\n      \"type\": \"array\"\n    },\n    \"comment\": {\n      \"type\": \"null\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  person.json\n\nfrom __future__ import annotations\n\nfrom typing import Any, List, Optional\n\nfrom pydantic import BaseModel, Field, conint\n\n\nclass Person(BaseModel):\n    firstName: Optional[str] = Field(None, description=\"The person's first name.\")\n    lastName: Optional[str] = Field(None, description=\"The person's last name.\")\n    age: Optional[conint(ge=0)] = Field(\n        None, description='Age in years which must be equal to or greater than zero.'\n    )\n    friends: Optional[List[Any]] = None\n    comment: None = None\n</code></pre>","path":["CLI Reference","General Options"],"tags":[]},{"location":"cli-reference/general-options/#disable-warnings","level":2,"title":"<code>--disable-warnings</code>","text":"<p>Suppress warning messages during code generation.</p> <p>The --disable-warnings option silences all warning messages that the generator might emit during processing (e.g., about unsupported features, ambiguous schemas, or potential issues). Useful for clean output in CI/CD pipelines.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --disable-warnings # (1)!\n</code></pre> <ol> <li> <code>--disable-warnings</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Pet\",\n  \"allOf\": [\n    {\n      \"$ref\": \"#/definitions/Home\"\n    },\n    {\n      \"$ref\": \"#/definitions/Kind\"\n    },\n    {\n      \"$ref\": \"#/definitions/Id\"\n    },\n    {\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"type\": \"string\"\n        }\n      }\n    }\n  ],\n  \"type\": [\n    \"object\"\n  ],\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"age\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"definitions\": {\n    \"Home\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"address\": {\n          \"type\": \"string\"\n        },\n        \"zip\": {\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"Kind\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"description\": {\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"Id\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"id\": {\n          \"type\": \"integer\"\n        }\n      }\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  all_of_with_object.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Home(BaseModel):\n    address: Optional[str] = None\n    zip: Optional[str] = None\n\n\nclass Kind(BaseModel):\n    description: Optional[str] = None\n\n\nclass Id(BaseModel):\n    id: Optional[int] = None\n\n\nclass Pet(Home, Kind, Id):\n    name: Optional[str] = None\n    age: Optional[int] = None\n</code></pre>","path":["CLI Reference","General Options"],"tags":[]},{"location":"cli-reference/general-options/#generate-cli-command","level":2,"title":"<code>--generate-cli-command</code>","text":"<p>Generate CLI command from pyproject.toml configuration.</p> <p>The <code>--generate-cli-command</code> flag reads your pyproject.toml configuration and outputs the equivalent CLI command. This is useful for debugging configuration issues or sharing commands with others.</p> <p>Usage</p> <pre><code>datamodel-codegen --generate-cli-command # (1)!\n</code></pre> <ol> <li> <code>--generate-cli-command</code> - the option documented here</li> </ol> Configuration (pyproject.toml) <pre><code>[tool.datamodel-codegen]\ninput = \"schema.yaml\"\noutput = \"model.py\"\n</code></pre> Output <pre><code>datamodel-codegen --input schema.yaml --output model.py\n</code></pre>","path":["CLI Reference","General Options"],"tags":[]},{"location":"cli-reference/general-options/#generate-pyproject-config","level":2,"title":"<code>--generate-pyproject-config</code>","text":"<p>Generate pyproject.toml configuration from CLI arguments.</p> <p>The <code>--generate-pyproject-config</code> flag outputs a pyproject.toml configuration snippet based on the provided CLI arguments. This is useful for converting a working CLI command into a reusable configuration file.</p> <p>See Also</p> <p>For pyproject.toml configuration guide, see pyproject.toml Configuration.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --generate-pyproject-config --input schema.yaml --output model.py # (1)!\n</code></pre> <ol> <li> <code>--generate-pyproject-config</code> - the option documented here</li> </ol> Output <pre><code>[tool.datamodel-codegen]\ninput = \"schema.yaml\"\noutput = \"model.py\"\n</code></pre>","path":["CLI Reference","General Options"],"tags":[]},{"location":"cli-reference/general-options/#http-headers","level":2,"title":"<code>--http-headers</code>","text":"<p>Fetch schema from URL with custom HTTP headers.</p> <p>The <code>--url</code> flag specifies a remote URL to fetch the schema from instead of a local file. The <code>--http-headers</code> flag adds custom HTTP headers to the request, useful for authentication (e.g., Bearer tokens) or custom API requirements. Format: <code>HeaderName:HeaderValue</code>.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --url https://api.example.com/schema.json --http-headers \"Authorization:Bearer token\" # (1)!\n</code></pre> <ol> <li> <code>--http-headers</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Pet\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"tag\": {\n      \"type\": \"string\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  https://api.example.com/schema.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    id: Optional[int] = None\n    name: Optional[str] = None\n    tag: Optional[str] = None\n</code></pre>","path":["CLI Reference","General Options"],"tags":[]},{"location":"cli-reference/general-options/#http-ignore-tls","level":2,"title":"<code>--http-ignore-tls</code>","text":"<p>Disable TLS certificate verification for HTTPS requests.</p> <p>The <code>--http-ignore-tls</code> flag disables SSL/TLS certificate verification when fetching schemas from HTTPS URLs. This is useful for development environments with self-signed certificates. Not recommended for production.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --url https://api.example.com/schema.json --http-ignore-tls # (1)!\n</code></pre> <ol> <li> <code>--http-ignore-tls</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Pet\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"tag\": {\n      \"type\": \"string\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  https://api.example.com/schema.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    id: Optional[int] = None\n    name: Optional[str] = None\n    tag: Optional[str] = None\n</code></pre>","path":["CLI Reference","General Options"],"tags":[]},{"location":"cli-reference/general-options/#http-query-parameters","level":2,"title":"<code>--http-query-parameters</code>","text":"<p>Add query parameters to HTTP requests for remote schemas.</p> <p>The <code>--http-query-parameters</code> flag adds query parameters to HTTP requests when fetching schemas from URLs. Useful for APIs that require version or format parameters. Format: <code>key=value</code>. Multiple parameters can be specified: <code>--http-query-parameters version=v2 format=json</code>.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --url https://api.example.com/schema.json --http-query-parameters version=v2 format=json # (1)!\n</code></pre> <ol> <li> <code>--http-query-parameters</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Pet\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"tag\": {\n      \"type\": \"string\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  https://api.example.com/schema.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    id: Optional[int] = None\n    name: Optional[str] = None\n    tag: Optional[str] = None\n</code></pre>","path":["CLI Reference","General Options"],"tags":[]},{"location":"cli-reference/general-options/#ignore-pyproject","level":2,"title":"<code>--ignore-pyproject</code>","text":"<p>Ignore pyproject.toml configuration file.</p> <p>The <code>--ignore-pyproject</code> flag tells datamodel-codegen to ignore any [tool.datamodel-codegen] configuration in pyproject.toml. This is useful when you want to override project defaults with CLI arguments, or when testing without project configuration.</p> <p>See Also</p> <p>For pyproject.toml configuration guide, see pyproject.toml Configuration.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --ignore-pyproject # (1)!\n</code></pre> <ol> <li> <code>--ignore-pyproject</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"firstName\": {\"type\": \"string\"},\n    \"lastName\": {\"type\": \"string\"}\n  }\n}\n</code></pre> Output With OptionWithout Option <pre><code># generated by datamodel-codegen:\n#   filename:  schema.json\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    firstName: Optional[str] = None\n    lastName: Optional[str] = None\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  schema.json\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    first_name: Optional[str] = Field(None, alias='firstName')\n    last_name: Optional[str] = Field(None, alias='lastName')\n</code></pre>","path":["CLI Reference","General Options"],"tags":[]},{"location":"cli-reference/general-options/#shared-module-name","level":2,"title":"<code>--shared-module-name</code>","text":"<p>Customize the name of the shared module for deduplicated models.</p> <p>The <code>--shared-module-name</code> flag sets the name of the shared module created when using <code>--reuse-model</code> with <code>--reuse-scope=tree</code>. This module contains deduplicated models that are referenced from multiple files. Default is <code>shared</code>. Use this if your schema already has a file named <code>shared</code>.</p> <p>Note: This option only affects modular output with tree-level model reuse.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --shared-module-name my_shared # (1)!\n</code></pre> <ol> <li> <code>--shared-module-name</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Pet\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"tag\": {\n      \"type\": \"string\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  pet_simple.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    id: Optional[int] = None\n    name: Optional[str] = None\n    tag: Optional[str] = None\n</code></pre>","path":["CLI Reference","General Options"],"tags":[]},{"location":"cli-reference/model-customization/","level":1,"title":"Model Customization","text":"","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#options","level":2,"title":"Options","text":"Option Description <code>--allow-extra-fields</code> Allow extra fields in generated Pydantic models (extra='allo... <code>--allow-population-by-field-name</code> Allow Pydantic model population by field name (not just alia... <code>--base-class</code> Specify a custom base class for generated models. <code>--class-name</code> Override the auto-generated class name with a custom name. <code>--collapse-root-models</code> Inline root model definitions instead of creating separate w... <code>--dataclass-arguments</code> Customize dataclass decorator arguments via JSON dictionary.... <code>--enable-faux-immutability</code> Enable faux immutability in Pydantic v1 models (allow_mutati... <code>--force-optional</code> Force all fields to be Optional regardless of required statu... <code>--frozen-dataclasses</code> Generate frozen dataclasses with optional keyword-only field... <code>--keep-model-order</code> Keep model definition order as specified in schema. <code>--keyword-only</code> Generate dataclasses with keyword-only fields (Python 3.10+)... <code>--output-model-type</code> Select the output model type (Pydantic v1/v2, dataclasses, T... <code>--parent-scoped-naming</code> Namespace models by their parent scope to avoid naming confl... <code>--reuse-model</code> Reuse identical model definitions instead of generating dupl... <code>--reuse-scope</code> Scope for model reuse detection (root or tree). <code>--skip-root-model</code> Skip generation of root model when schema contains nested de... <code>--strict-nullable</code> Strictly handle nullable types in OpenAPI schemas. <code>--strip-default-none</code> Remove fields with None as default value from generated mode... <code>--target-python-version</code> Target Python version for generated code syntax and imports.... <code>--union-mode</code> Union mode for combining anyOf/oneOf schemas (smart or left_... <code>--use-default</code> Use default values from schema in generated models. <code>--use-default-kwarg</code> Use default= keyword argument instead of positional argument... <code>--use-frozen-field</code> Generate frozen (immutable) field definitions for readOnly p... <code>--use-one-literal-as-default</code> Use single literal value as default when enum has only one o... <code>--use-serialize-as-any</code> Wrap fields with subtypes in Pydantic's SerializeAsAny. <code>--use-subclass-enum</code> Generate typed Enum subclasses for enums with specific field...","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#allow-extra-fields","level":2,"title":"<code>--allow-extra-fields</code>","text":"<p>Allow extra fields in generated Pydantic models (extra='allow').</p> <p>The <code>--allow-extra-fields</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --allow-extra-fields # (1)!\n</code></pre> <ol> <li> <code>--allow-extra-fields</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: error result\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output Pydantic v1Pydantic v2 <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Extra, Field\n\n\nclass Pet(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    __root__: List[Pet]\n\n\nclass User(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    __root__: str\n\n\nclass Rules(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    event: Optional[Event] = None\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, ConfigDict, Field, RootModel\n\n\nclass Pet(BaseModel):\n    model_config = ConfigDict(\n        extra='allow',\n    )\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(RootModel[List[Pet]]):\n    root: List[Pet]\n\n\nclass User(BaseModel):\n    model_config = ConfigDict(\n        extra='allow',\n    )\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(RootModel[List[User]]):\n    root: List[User]\n\n\nclass Id(RootModel[str]):\n    root: str\n\n\nclass Rules(RootModel[List[str]]):\n    root: List[str]\n\n\nclass Error(BaseModel):\n    model_config = ConfigDict(\n        extra='allow',\n    )\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    model_config = ConfigDict(\n        extra='allow',\n    )\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(RootModel[List[Api]]):\n    root: List[Api]\n\n\nclass Event(BaseModel):\n    model_config = ConfigDict(\n        extra='allow',\n    )\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    model_config = ConfigDict(\n        extra='allow',\n    )\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#allow-population-by-field-name","level":2,"title":"<code>--allow-population-by-field-name</code>","text":"<p>Allow Pydantic model population by field name (not just alias).</p> <p>The <code>--allow-population-by-field-name</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --allow-population-by-field-name # (1)!\n</code></pre> <ol> <li> <code>--allow-population-by-field-name</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: error result\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output Pydantic v1Pydantic v2 <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    class Config:\n        allow_population_by_field_name = True\n\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    class Config:\n        allow_population_by_field_name = True\n\n    __root__: List[Pet]\n\n\nclass User(BaseModel):\n    class Config:\n        allow_population_by_field_name = True\n\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(BaseModel):\n    class Config:\n        allow_population_by_field_name = True\n\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    class Config:\n        allow_population_by_field_name = True\n\n    __root__: str\n\n\nclass Rules(BaseModel):\n    class Config:\n        allow_population_by_field_name = True\n\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    class Config:\n        allow_population_by_field_name = True\n\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    class Config:\n        allow_population_by_field_name = True\n\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    class Config:\n        allow_population_by_field_name = True\n\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    class Config:\n        allow_population_by_field_name = True\n\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    class Config:\n        allow_population_by_field_name = True\n\n    event: Optional[Event] = None\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, ConfigDict, Field, RootModel\n\n\nclass Pet(BaseModel):\n    model_config = ConfigDict(\n        populate_by_name=True,\n    )\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(RootModel[List[Pet]]):\n    model_config = ConfigDict(\n        populate_by_name=True,\n    )\n    root: List[Pet]\n\n\nclass User(BaseModel):\n    model_config = ConfigDict(\n        populate_by_name=True,\n    )\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(RootModel[List[User]]):\n    model_config = ConfigDict(\n        populate_by_name=True,\n    )\n    root: List[User]\n\n\nclass Id(RootModel[str]):\n    model_config = ConfigDict(\n        populate_by_name=True,\n    )\n    root: str\n\n\nclass Rules(RootModel[List[str]]):\n    model_config = ConfigDict(\n        populate_by_name=True,\n    )\n    root: List[str]\n\n\nclass Error(BaseModel):\n    model_config = ConfigDict(\n        populate_by_name=True,\n    )\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    model_config = ConfigDict(\n        populate_by_name=True,\n    )\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(RootModel[List[Api]]):\n    model_config = ConfigDict(\n        populate_by_name=True,\n    )\n    root: List[Api]\n\n\nclass Event(BaseModel):\n    model_config = ConfigDict(\n        populate_by_name=True,\n    )\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    model_config = ConfigDict(\n        populate_by_name=True,\n    )\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#base-class","level":2,"title":"<code>--base-class</code>","text":"<p>Specify a custom base class for generated models.</p> <p>The <code>--base-class</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --base-class custom_module.Base # (1)!\n</code></pre> <ol> <li> <code>--base-class</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: error result\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, Field\n\nfrom custom_module import Base\n\n\nclass Pet(Base):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(Base):\n    __root__: List[Pet]\n\n\nclass User(Base):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(Base):\n    __root__: List[User]\n\n\nclass Id(Base):\n    __root__: str\n\n\nclass Rules(Base):\n    __root__: List[str]\n\n\nclass Error(Base):\n    code: int\n    message: str\n\n\nclass Api(Base):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(Base):\n    __root__: List[Api]\n\n\nclass Event(Base):\n    name: Optional[str] = None\n\n\nclass Result(Base):\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#class-name","level":2,"title":"<code>--class-name</code>","text":"<p>Override the auto-generated class name with a custom name.</p> <p>The --class-name option allows you to specify a custom class name for the generated model. This is useful when the schema title is invalid as a Python class name (e.g., starts with a number) or when you want to use a different naming convention than what's in the schema.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --class-name ValidModelName # (1)!\n</code></pre> <ol> <li> <code>--class-name</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"1 xyz\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"firstName\": {\n      \"type\": \"string\",\n      \"description\": \"The person's first name.\"\n    },\n    \"lastName\": {\n      \"type\": \"string\",\n      \"description\": \"The person's last name.\"\n    },\n    \"age\": {\n      \"description\": \"Age in years which must be equal to or greater than zero.\",\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"friends\": {\n      \"type\": \"array\"\n    },\n    \"comment\": {\n      \"type\": \"null\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  invalid_model_name.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Any, List, Optional\n\nfrom pydantic import BaseModel, Field, conint\n\n\nclass ValidModelName(BaseModel):\n    firstName: Optional[str] = Field(None, description=\"The person's first name.\")\n    lastName: Optional[str] = Field(None, description=\"The person's last name.\")\n    age: Optional[conint(ge=0)] = Field(\n        None, description='Age in years which must be equal to or greater than zero.'\n    )\n    friends: Optional[List[Any]] = None\n    comment: None = None\n</code></pre>","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#collapse-root-models","level":2,"title":"<code>--collapse-root-models</code>","text":"<p>Inline root model definitions instead of creating separate wrapper classes.</p> <p>The <code>--collapse-root-models</code> option generates simpler output by inlining root models directly instead of creating separate wrapper types. This shows how different output model types (Pydantic v1/v2, dataclass, TypedDict, msgspec) handle const fields.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --collapse-root-models # (1)!\n</code></pre> <ol> <li> <code>--collapse-root-models</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: '3.0.2'\ncomponents:\n  schemas:\n    ApiVersion:\n      description: The version of this API\n      type: string\n      const: v1\n    Api:\n      type: object\n      required:\n        - version\n      properties:\n        version:\n          $ref: \"#/components/schemas/ApiVersion\"\n</code></pre> Output Pydantic v1Pydantic v2dataclassTypedDictmsgspecWithout Option (Baseline) <pre><code># generated by datamodel-codegen:\n#   filename:  const.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel, Field\n\n\nclass Api(BaseModel):\n    version: str = Field('v1', const=True, description='The version of this API')\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  const.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import BaseModel, Field\n\n\nclass Api(BaseModel):\n    version: Literal['v1'] = Field(..., description='The version of this API')\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  const.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import Literal\n\n\n@dataclass\nclass Api:\n    version: Literal['v1']\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  const.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Literal, TypedDict\n\n\nclass Api(TypedDict):\n    version: Literal['v1']\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  const.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Annotated, Literal\n\nfrom msgspec import Meta, Struct\n\n\nclass Api(Struct):\n    version: Annotated[Literal['v1'], Meta(description='The version of this API')]\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  const.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel, Field\n\n\nclass ApiVersion(BaseModel):\n    __root__: str = Field('v1', const=True, description='The version of this API')\n\n\nclass Api(BaseModel):\n    version: ApiVersion\n</code></pre>","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#dataclass-arguments","level":2,"title":"<code>--dataclass-arguments</code>","text":"<p>Customize dataclass decorator arguments via JSON dictionary.</p> <p>The <code>--dataclass-arguments</code> flag accepts custom dataclass arguments as a JSON dictionary (e.g., '{\"frozen\": true, \"kw_only\": true, \"slots\": true, \"order\": true}'). This overrides individual flags like --frozen-dataclasses and provides fine-grained control over dataclass generation.</p> <p>Related: <code>--frozen</code>, <code>--keyword-only</code></p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --output-model-type dataclasses.dataclass --dataclass-arguments \"{\"slots\": true, \"order\": true}\" # (1)!\n</code></pre> <ol> <li> <code>--dataclass-arguments</code> - the option documented here</li> </ol> Input Schema <pre><code>type Person {\n    id: ID!\n    name: String!\n    height: Int\n    mass: Int\n    hair_color: String\n    skin_color: String\n    eye_color: String\n    birth_year: String\n    gender: String\n\n    # Relationships\n    homeworld_id: ID\n    homeworld: Planet\n    species: [Species!]!\n    species_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n    starships: [Starship!]!\n    starships_ids: [ID!]!\n    vehicles: [Vehicle!]!\n    vehicles_ids: [ID!]!\n}\n\ntype Planet {\n    id: ID!\n    name: String!\n    rotation_period: String\n    orbital_period: String\n    diameter: String\n    climate: String\n    gravity: String\n    terrain: String\n    surface_water: String\n    population: String\n\n    # Relationships\n    residents: [Person!]!\n    residents_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n}\n\ntype Species {\n    id: ID!\n    name: String!\n    classification: String\n    designation: String\n    average_height: String\n    skin_colors: String\n    hair_colors: String\n    eye_colors: String\n    average_lifespan: String\n    language: String\n\n    # Relationships\n    people: [Person!]!\n    people_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n}\n\ntype Vehicle {\n    id: ID!\n    name: String!\n    model: String\n    manufacturer: String\n    cost_in_credits: String\n    length: String\n    max_atmosphering_speed: String\n    crew: String\n    passengers: String\n    cargo_capacity: String\n    consumables: String\n    vehicle_class: String\n\n    # Relationships\n    pilots: [Person!]!\n    pilots_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n}\n\ntype Starship {\n    id: ID!\n    name: String!\n    model: String\n    manufacturer: String\n    cost_in_credits: String\n    length: String\n    max_atmosphering_speed: String\n    crew: String\n    passengers: String\n    cargo_capacity: String\n    consumables: String\n    hyperdrive_rating: String\n    MGLT: String\n    starship_class: String\n\n    # Relationships\n    pilots: [Person!]!\n    pilots_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n}\n\ntype Film {\n  id: ID!\n  title: String!\n  episode_id: Int!\n  opening_crawl: String!\n  director: String!\n  producer: String\n  release_date: String!\n\n  # Relationships\n  characters: [Person!]!\n  characters_ids: [ID!]!\n  planets: [Planet!]!\n  planets_ids: [ID!]!\n  starships: [Starship!]!\n  starships_ids: [ID!]!\n  vehicles: [Vehicle!]!\n  vehicles_ids: [ID!]!\n  species: [Species!]!\n  species_ids: [ID!]!\n}\n\ntype Query {\n  planet(id: ID!): Planet\n  listPlanets(page: Int): [Planet!]!\n  person(id: ID!): Person\n  listPeople(page: Int): [Person!]!\n  species(id: ID!): Species\n  listSpecies(page: Int): [Species!]!\n  film(id: ID!): Film\n  listFilms(page: Int): [Film!]!\n  starship(id: ID!): Starship\n  listStarships(page: Int): [Starship!]!\n  vehicle(id: ID!): Vehicle\n  listVehicles(page: Int): [Vehicle!]!\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  simple-star-wars.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import List, Literal, Optional\n\nfrom typing_extensions import TypeAlias\n\nBoolean: TypeAlias = bool\n\"\"\"\nThe `Boolean` scalar type represents `true` or `false`.\n\"\"\"\n\n\nID: TypeAlias = str\n\"\"\"\nThe `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `\"4\"`) or integer (such as `4`) input value will be accepted as an ID.\n\"\"\"\n\n\nInt: TypeAlias = int\n\"\"\"\nThe `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\n\"\"\"\n\n\nString: TypeAlias = str\n\"\"\"\nThe `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\n\"\"\"\n\n\n@dataclass(order=True, slots=True)\nclass Film:\n    characters: List[Person]\n    characters_ids: List[ID]\n    director: String\n    episode_id: Int\n    id: ID\n    opening_crawl: String\n    planets: List[Planet]\n    planets_ids: List[ID]\n    release_date: String\n    species: List[Species]\n    species_ids: List[ID]\n    starships: List[Starship]\n    starships_ids: List[ID]\n    title: String\n    vehicles: List[Vehicle]\n    vehicles_ids: List[ID]\n    producer: Optional[String] = None\n    typename__: Optional[Literal['Film']] = 'Film'\n\n\n@dataclass(order=True, slots=True)\nclass Person:\n    films: List[Film]\n    films_ids: List[ID]\n    id: ID\n    name: String\n    species: List[Species]\n    species_ids: List[ID]\n    starships: List[Starship]\n    starships_ids: List[ID]\n    vehicles: List[Vehicle]\n    vehicles_ids: List[ID]\n    birth_year: Optional[String] = None\n    eye_color: Optional[String] = None\n    gender: Optional[String] = None\n    hair_color: Optional[String] = None\n    height: Optional[Int] = None\n    homeworld: Optional[Planet] = None\n    homeworld_id: Optional[ID] = None\n    mass: Optional[Int] = None\n    skin_color: Optional[String] = None\n    typename__: Optional[Literal['Person']] = 'Person'\n\n\n@dataclass(order=True, slots=True)\nclass Planet:\n    films: List[Film]\n    films_ids: List[ID]\n    id: ID\n    name: String\n    residents: List[Person]\n    residents_ids: List[ID]\n    climate: Optional[String] = None\n    diameter: Optional[String] = None\n    gravity: Optional[String] = None\n    orbital_period: Optional[String] = None\n    population: Optional[String] = None\n    rotation_period: Optional[String] = None\n    surface_water: Optional[String] = None\n    terrain: Optional[String] = None\n    typename__: Optional[Literal['Planet']] = 'Planet'\n\n\n@dataclass(order=True, slots=True)\nclass Species:\n    films: List[Film]\n    films_ids: List[ID]\n    id: ID\n    name: String\n    people: List[Person]\n    people_ids: List[ID]\n    average_height: Optional[String] = None\n    average_lifespan: Optional[String] = None\n    classification: Optional[String] = None\n    designation: Optional[String] = None\n    eye_colors: Optional[String] = None\n    hair_colors: Optional[String] = None\n    language: Optional[String] = None\n    skin_colors: Optional[String] = None\n    typename__: Optional[Literal['Species']] = 'Species'\n\n\n@dataclass(order=True, slots=True)\nclass Starship:\n    films: List[Film]\n    films_ids: List[ID]\n    id: ID\n    name: String\n    pilots: List[Person]\n    pilots_ids: List[ID]\n    MGLT: Optional[String] = None\n    cargo_capacity: Optional[String] = None\n    consumables: Optional[String] = None\n    cost_in_credits: Optional[String] = None\n    crew: Optional[String] = None\n    hyperdrive_rating: Optional[String] = None\n    length: Optional[String] = None\n    manufacturer: Optional[String] = None\n    max_atmosphering_speed: Optional[String] = None\n    model: Optional[String] = None\n    passengers: Optional[String] = None\n    starship_class: Optional[String] = None\n    typename__: Optional[Literal['Starship']] = 'Starship'\n\n\n@dataclass(order=True, slots=True)\nclass Vehicle:\n    films: List[Film]\n    films_ids: List[ID]\n    id: ID\n    name: String\n    pilots: List[Person]\n    pilots_ids: List[ID]\n    cargo_capacity: Optional[String] = None\n    consumables: Optional[String] = None\n    cost_in_credits: Optional[String] = None\n    crew: Optional[String] = None\n    length: Optional[String] = None\n    manufacturer: Optional[String] = None\n    max_atmosphering_speed: Optional[String] = None\n    model: Optional[String] = None\n    passengers: Optional[String] = None\n    vehicle_class: Optional[String] = None\n    typename__: Optional[Literal['Vehicle']] = 'Vehicle'\n</code></pre>","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#enable-faux-immutability","level":2,"title":"<code>--enable-faux-immutability</code>","text":"<p>Enable faux immutability in Pydantic v1 models (allow_mutation=False).</p> <p>The <code>--enable-faux-immutability</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --enable-faux-immutability # (1)!\n</code></pre> <ol> <li> <code>--enable-faux-immutability</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: error result\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output Pydantic v1Pydantic v2 <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    class Config:\n        allow_mutation = False\n\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    class Config:\n        allow_mutation = False\n\n    __root__: List[Pet]\n\n\nclass User(BaseModel):\n    class Config:\n        allow_mutation = False\n\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(BaseModel):\n    class Config:\n        allow_mutation = False\n\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    class Config:\n        allow_mutation = False\n\n    __root__: str\n\n\nclass Rules(BaseModel):\n    class Config:\n        allow_mutation = False\n\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    class Config:\n        allow_mutation = False\n\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    class Config:\n        allow_mutation = False\n\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    class Config:\n        allow_mutation = False\n\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    class Config:\n        allow_mutation = False\n\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    class Config:\n        allow_mutation = False\n\n    event: Optional[Event] = None\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, ConfigDict, Field, RootModel\n\n\nclass Pet(BaseModel):\n    model_config = ConfigDict(\n        frozen=True,\n    )\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(RootModel[List[Pet]]):\n    model_config = ConfigDict(\n        frozen=True,\n    )\n    root: List[Pet]\n\n\nclass User(BaseModel):\n    model_config = ConfigDict(\n        frozen=True,\n    )\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(RootModel[List[User]]):\n    model_config = ConfigDict(\n        frozen=True,\n    )\n    root: List[User]\n\n\nclass Id(RootModel[str]):\n    model_config = ConfigDict(\n        frozen=True,\n    )\n    root: str\n\n\nclass Rules(RootModel[List[str]]):\n    model_config = ConfigDict(\n        frozen=True,\n    )\n    root: List[str]\n\n\nclass Error(BaseModel):\n    model_config = ConfigDict(\n        frozen=True,\n    )\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    model_config = ConfigDict(\n        frozen=True,\n    )\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(RootModel[List[Api]]):\n    model_config = ConfigDict(\n        frozen=True,\n    )\n    root: List[Api]\n\n\nclass Event(BaseModel):\n    model_config = ConfigDict(\n        frozen=True,\n    )\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    model_config = ConfigDict(\n        frozen=True,\n    )\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#force-optional","level":2,"title":"<code>--force-optional</code>","text":"<p>Force all fields to be Optional regardless of required status.</p> <p>The <code>--force-optional</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --force-optional # (1)!\n</code></pre> <ol> <li> <code>--force-optional</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: error result\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: Optional[int] = 1\n    name: Optional[str] = None\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: Optional[List[Pet]] = None\n\n\nclass User(BaseModel):\n    id: Optional[int] = None\n    name: Optional[str] = None\n    tag: Optional[str] = None\n\n\nclass Users(BaseModel):\n    __root__: Optional[List[User]] = None\n\n\nclass Id(BaseModel):\n    __root__: Optional[str] = None\n\n\nclass Rules(BaseModel):\n    __root__: Optional[List[str]] = None\n\n\nclass Error(BaseModel):\n    code: Optional[int] = None\n    message: Optional[str] = None\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: Optional[List[Api]] = None\n\n\nclass Event(BaseModel):\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#frozen-dataclasses","level":2,"title":"<code>--frozen-dataclasses</code>","text":"<p>Generate frozen dataclasses with optional keyword-only fields.</p> <p>The <code>--frozen-dataclasses</code> flag generates dataclass instances that are immutable (frozen=True). Combined with <code>--keyword-only</code> (Python 3.10+), all fields become keyword-only arguments.</p> <p>Related: <code>--keyword-only</code>, <code>--output-model-type</code></p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --output-model-type dataclasses.dataclass --frozen-dataclasses # (1)!\n</code></pre> <ol> <li> <code>--frozen-dataclasses</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"object\",\n  \"title\": \"User\",\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"age\": {\n      \"type\": \"integer\"\n    },\n    \"email\": {\n      \"type\": \"string\",\n      \"format\": \"email\"\n    }\n  },\n  \"required\": [\"name\", \"age\"]\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  simple_frozen_test.json\n#   timestamp: 1985-10-26T08:21:00+00:00\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import Optional\n\n\n@dataclass(frozen=True)\nclass User:\n    name: str\n    age: int\n    email: Optional[str] = None\n</code></pre>","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#keep-model-order","level":2,"title":"<code>--keep-model-order</code>","text":"<p>Keep model definition order as specified in schema.</p> <p>The <code>--keep-model-order</code> flag preserves the original definition order from the schema instead of reordering models based on dependencies. This is useful when the order of model definitions matters for documentation or readability.</p> <p>Related: <code>--collapse-root-models</code></p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --keep-model-order # (1)!\n</code></pre> <ol> <li> <code>--keep-model-order</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n    \"title\": \"PersonsBestFriend\",\n    \"description\": \"This is the main model.\",\n    \"type\": \"object\",\n    \"properties\": {\n      \"people\": {\n        \"title\": \"People\",\n        \"type\": \"array\",\n        \"items\": {\n          \"$ref\": \"#/definitions/Person\"\n        }\n      },\n      \"dogs\": {\n        \"title\": \"Dogs\",\n        \"type\": \"array\",\n        \"items\": {\n          \"$ref\": \"#/definitions/Dog\"\n        }\n      },\n      \"dog_base\": {\n        \"$ref\": \"#/definitions/DogBase\"\n      },\n      \"dog_relationships\": {\n        \"$ref\": \"#/definitions/DogRelationships\"\n      },\n      \"person_base\": {\n        \"$ref\": \"#/definitions/PersonBase\"\n      },\n      \"person_relationships\": {\n        \"$ref\": \"#/definitions/PersonRelationships\"\n      }\n    },\n    \"definitions\": {\n      \"Person\": {\n        \"title\": \"Person\",\n        \"allOf\": [\n            {\"$ref\": \"#/definitions/PersonBase\"},\n            {\"$ref\": \"#/definitions/PersonRelationships\"}\n        ]\n      },\n      \"Dog\": {\n        \"title\": \"Dog\",\n        \"allOf\": [\n            {\"$ref\": \"#/definitions/DogBase\"},\n            {\"$ref\": \"#/definitions/DogRelationships\"}\n        ]\n      },\n      \"DogBase\": {\n        \"title\": \"DogBase\",\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"title\": \"Name\",\n            \"type\": \"string\"\n          },\n          \"woof\": {\n            \"title\": \"Woof\",\n            \"default\": true,\n            \"type\": \"boolean\"\n          }\n        }\n      },\n      \"DogRelationships\": {\n        \"title\": \"DogRelationships\",\n        \"type\": \"object\",\n        \"properties\": {\n          \"people\": {\n            \"title\": \"People\",\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/definitions/Person\"\n            }\n          }\n        }\n      },\n      \"PersonBase\": {\n        \"title\": \"PersonBase\",\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"title\": \"Name\",\n            \"type\": \"string\"\n          }\n        }\n      },\n      \"PersonRelationships\": {\n        \"title\": \"PersonRelationships\",\n        \"type\": \"object\",\n        \"properties\": {\n          \"people\": {\n            \"title\": \"People\",\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/definitions/Person\"\n            }\n          }\n        }\n      }\n    }\n  }\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  inheritance_forward_ref.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass DogBase(BaseModel):\n    name: Optional[str] = Field(None, title='Name')\n    woof: Optional[bool] = Field(True, title='Woof')\n\n\nclass DogRelationships(BaseModel):\n    people: Optional[List[Person]] = Field(None, title='People')\n\n\nclass Dog(DogBase, DogRelationships):\n    pass\n\n\nclass PersonBase(BaseModel):\n    name: Optional[str] = Field(None, title='Name')\n\n\nclass PersonRelationships(BaseModel):\n    people: Optional[List[Person]] = Field(None, title='People')\n\n\nclass Person(PersonBase, PersonRelationships):\n    pass\n\n\nclass PersonsBestFriend(BaseModel):\n    people: Optional[List[Person]] = Field(None, title='People')\n    dogs: Optional[List[Dog]] = Field(None, title='Dogs')\n    dog_base: Optional[DogBase] = None\n    dog_relationships: Optional[DogRelationships] = None\n    person_base: Optional[PersonBase] = None\n    person_relationships: Optional[PersonRelationships] = None\n\n\nDogRelationships.update_forward_refs()\nDog.update_forward_refs()\nPersonRelationships.update_forward_refs()\nPerson.update_forward_refs()\nPersonsBestFriend.update_forward_refs()\n</code></pre>","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#keyword-only","level":2,"title":"<code>--keyword-only</code>","text":"<p>Generate dataclasses with keyword-only fields (Python 3.10+).</p> <p>The <code>--keyword-only</code> flag generates dataclasses where all fields must be specified as keyword arguments (kw_only=True). This is only available for Python 3.10+. When combined with <code>--frozen</code>, it creates immutable dataclasses with keyword-only arguments, improving code clarity and preventing positional argument errors.</p> <p>Related: <code>--frozen</code>, <code>--target-python-version</code>, <code>--output-model-type</code></p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --output-model-type dataclasses.dataclass --frozen --keyword-only --target-python-version 3.10 # (1)!\n</code></pre> <ol> <li> <code>--keyword-only</code> - the option documented here</li> </ol> Input Schema <pre><code>type Person {\n    id: ID!\n    name: String!\n    height: Int\n    mass: Int\n    hair_color: String\n    skin_color: String\n    eye_color: String\n    birth_year: String\n    gender: String\n\n    # Relationships\n    homeworld_id: ID\n    homeworld: Planet\n    species: [Species!]!\n    species_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n    starships: [Starship!]!\n    starships_ids: [ID!]!\n    vehicles: [Vehicle!]!\n    vehicles_ids: [ID!]!\n}\n\ntype Planet {\n    id: ID!\n    name: String!\n    rotation_period: String\n    orbital_period: String\n    diameter: String\n    climate: String\n    gravity: String\n    terrain: String\n    surface_water: String\n    population: String\n\n    # Relationships\n    residents: [Person!]!\n    residents_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n}\n\ntype Species {\n    id: ID!\n    name: String!\n    classification: String\n    designation: String\n    average_height: String\n    skin_colors: String\n    hair_colors: String\n    eye_colors: String\n    average_lifespan: String\n    language: String\n\n    # Relationships\n    people: [Person!]!\n    people_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n}\n\ntype Vehicle {\n    id: ID!\n    name: String!\n    model: String\n    manufacturer: String\n    cost_in_credits: String\n    length: String\n    max_atmosphering_speed: String\n    crew: String\n    passengers: String\n    cargo_capacity: String\n    consumables: String\n    vehicle_class: String\n\n    # Relationships\n    pilots: [Person!]!\n    pilots_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n}\n\ntype Starship {\n    id: ID!\n    name: String!\n    model: String\n    manufacturer: String\n    cost_in_credits: String\n    length: String\n    max_atmosphering_speed: String\n    crew: String\n    passengers: String\n    cargo_capacity: String\n    consumables: String\n    hyperdrive_rating: String\n    MGLT: String\n    starship_class: String\n\n    # Relationships\n    pilots: [Person!]!\n    pilots_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n}\n\ntype Film {\n  id: ID!\n  title: String!\n  episode_id: Int!\n  opening_crawl: String!\n  director: String!\n  producer: String\n  release_date: String!\n\n  # Relationships\n  characters: [Person!]!\n  characters_ids: [ID!]!\n  planets: [Planet!]!\n  planets_ids: [ID!]!\n  starships: [Starship!]!\n  starships_ids: [ID!]!\n  vehicles: [Vehicle!]!\n  vehicles_ids: [ID!]!\n  species: [Species!]!\n  species_ids: [ID!]!\n}\n\ntype Query {\n  planet(id: ID!): Planet\n  listPlanets(page: Int): [Planet!]!\n  person(id: ID!): Person\n  listPeople(page: Int): [Person!]!\n  species(id: ID!): Species\n  listSpecies(page: Int): [Species!]!\n  film(id: ID!): Film\n  listFilms(page: Int): [Film!]!\n  starship(id: ID!): Starship\n  listStarships(page: Int): [Starship!]!\n  vehicle(id: ID!): Vehicle\n  listVehicles(page: Int): [Vehicle!]!\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  simple-star-wars.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import List, Literal, Optional, TypeAlias\n\nBoolean: TypeAlias = bool\n\"\"\"\nThe `Boolean` scalar type represents `true` or `false`.\n\"\"\"\n\n\nID: TypeAlias = str\n\"\"\"\nThe `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `\"4\"`) or integer (such as `4`) input value will be accepted as an ID.\n\"\"\"\n\n\nInt: TypeAlias = int\n\"\"\"\nThe `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\n\"\"\"\n\n\nString: TypeAlias = str\n\"\"\"\nThe `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\n\"\"\"\n\n\n@dataclass(frozen=True, kw_only=True)\nclass Film:\n    characters: List[Person]\n    characters_ids: List[ID]\n    director: String\n    episode_id: Int\n    id: ID\n    opening_crawl: String\n    planets: List[Planet]\n    planets_ids: List[ID]\n    release_date: String\n    species: List[Species]\n    species_ids: List[ID]\n    starships: List[Starship]\n    starships_ids: List[ID]\n    title: String\n    vehicles: List[Vehicle]\n    vehicles_ids: List[ID]\n    producer: Optional[String] = None\n    typename__: Optional[Literal['Film']] = 'Film'\n\n\n@dataclass(frozen=True, kw_only=True)\nclass Person:\n    films: List[Film]\n    films_ids: List[ID]\n    id: ID\n    name: String\n    species: List[Species]\n    species_ids: List[ID]\n    starships: List[Starship]\n    starships_ids: List[ID]\n    vehicles: List[Vehicle]\n    vehicles_ids: List[ID]\n    birth_year: Optional[String] = None\n    eye_color: Optional[String] = None\n    gender: Optional[String] = None\n    hair_color: Optional[String] = None\n    height: Optional[Int] = None\n    homeworld: Optional[Planet] = None\n    homeworld_id: Optional[ID] = None\n    mass: Optional[Int] = None\n    skin_color: Optional[String] = None\n    typename__: Optional[Literal['Person']] = 'Person'\n\n\n@dataclass(frozen=True, kw_only=True)\nclass Planet:\n    films: List[Film]\n    films_ids: List[ID]\n    id: ID\n    name: String\n    residents: List[Person]\n    residents_ids: List[ID]\n    climate: Optional[String] = None\n    diameter: Optional[String] = None\n    gravity: Optional[String] = None\n    orbital_period: Optional[String] = None\n    population: Optional[String] = None\n    rotation_period: Optional[String] = None\n    surface_water: Optional[String] = None\n    terrain: Optional[String] = None\n    typename__: Optional[Literal['Planet']] = 'Planet'\n\n\n@dataclass(frozen=True, kw_only=True)\nclass Species:\n    films: List[Film]\n    films_ids: List[ID]\n    id: ID\n    name: String\n    people: List[Person]\n    people_ids: List[ID]\n    average_height: Optional[String] = None\n    average_lifespan: Optional[String] = None\n    classification: Optional[String] = None\n    designation: Optional[String] = None\n    eye_colors: Optional[String] = None\n    hair_colors: Optional[String] = None\n    language: Optional[String] = None\n    skin_colors: Optional[String] = None\n    typename__: Optional[Literal['Species']] = 'Species'\n\n\n@dataclass(frozen=True, kw_only=True)\nclass Starship:\n    films: List[Film]\n    films_ids: List[ID]\n    id: ID\n    name: String\n    pilots: List[Person]\n    pilots_ids: List[ID]\n    MGLT: Optional[String] = None\n    cargo_capacity: Optional[String] = None\n    consumables: Optional[String] = None\n    cost_in_credits: Optional[String] = None\n    crew: Optional[String] = None\n    hyperdrive_rating: Optional[String] = None\n    length: Optional[String] = None\n    manufacturer: Optional[String] = None\n    max_atmosphering_speed: Optional[String] = None\n    model: Optional[String] = None\n    passengers: Optional[String] = None\n    starship_class: Optional[String] = None\n    typename__: Optional[Literal['Starship']] = 'Starship'\n\n\n@dataclass(frozen=True, kw_only=True)\nclass Vehicle:\n    films: List[Film]\n    films_ids: List[ID]\n    id: ID\n    name: String\n    pilots: List[Person]\n    pilots_ids: List[ID]\n    cargo_capacity: Optional[String] = None\n    consumables: Optional[String] = None\n    cost_in_credits: Optional[String] = None\n    crew: Optional[String] = None\n    length: Optional[String] = None\n    manufacturer: Optional[String] = None\n    max_atmosphering_speed: Optional[String] = None\n    model: Optional[String] = None\n    passengers: Optional[String] = None\n    vehicle_class: Optional[String] = None\n    typename__: Optional[Literal['Vehicle']] = 'Vehicle'\n</code></pre>","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#output-model-type","level":2,"title":"<code>--output-model-type</code>","text":"<p>Select the output model type (Pydantic v1/v2, dataclasses, TypedDict, msgspec).</p> <p>The <code>--output-model-type</code> flag specifies which Python data model framework to use for the generated code. Supported values include <code>pydantic.BaseModel</code>, <code>pydantic_v2.BaseModel</code>, <code>dataclasses.dataclass</code>, <code>typing.TypedDict</code>, and <code>msgspec.Struct</code>.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --output-model-type pydantic.BaseModel # (1)!\n</code></pre> <ol> <li> <code>--output-model-type</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n    \"$schema\": \"http://json-schema.org/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"my_obj\": {\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"items\": {\n                        \"type\": [\n                            \"array\",\n                            \"null\"\n                        ]\n                    }\n                },\n                \"required\": [\n                    \"items\"\n                ]\n            }\n        }\n    },\n    \"required\": [\n        \"my_obj\"\n    ]\n}\n</code></pre> Output Pydantic v1Pydantic v2 <pre><code># generated by datamodel-codegen:\n#   filename:  null_and_array.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Any, List, Optional\n\nfrom pydantic import BaseModel\n\n\nclass MyObjItem(BaseModel):\n    items: Optional[List[Any]]\n\n\nclass Model(BaseModel):\n    my_obj: List[MyObjItem]\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  null_and_array.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Any, List, Optional\n\nfrom pydantic import BaseModel\n\n\nclass MyObjItem(BaseModel):\n    items: Optional[List[Any]] = None\n\n\nclass Model(BaseModel):\n    my_obj: List[MyObjItem]\n</code></pre>","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#parent-scoped-naming","level":2,"title":"<code>--parent-scoped-naming</code>","text":"<p>Namespace models by their parent scope to avoid naming conflicts.</p> <p>The <code>--parent-scoped-naming</code> flag prefixes model names with their parent scope (operation/path/parameter) to prevent name collisions when the same model name appears in different contexts within an OpenAPI specification.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --parent-scoped-naming --use-operation-id-as-name --openapi-scopes paths schemas parameters # (1)!\n</code></pre> <ol> <li> <code>--parent-scoped-naming</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: Get pet\n      operationId: getPets\n      responses:\n        '200':\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pet\"\n  /cars:\n    get:\n      summary: Get car\n      operationId: getCar\n      responses:\n        '200':\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Cars\"\n\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n        - type\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        tag:\n          type: string\n        type:\n          type: string\n          enum: [ 'pet' ]\n        details:\n          type: object\n          properties:\n            race: { type: string }\n    Car:\n      required:\n        - id\n        - name\n        - type\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        tag:\n          type: string\n        type:\n          type: string\n          enum: [ 'car' ]\n        details:\n          type: object\n          properties:\n            brand: { type: string }\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  duplicate_models2.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Any, Optional\n\nfrom pydantic import BaseModel, RootModel\n\n\nclass PetType(Enum):\n    pet = 'pet'\n\n\nclass PetDetails(BaseModel):\n    race: Optional[str] = None\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n    type: PetType\n    details: Optional[PetDetails] = None\n\n\nclass CarType(Enum):\n    car = 'car'\n\n\nclass CarDetails(BaseModel):\n    brand: Optional[str] = None\n\n\nclass Car(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n    type: CarType\n    details: Optional[CarDetails] = None\n\n\nclass Cars(RootModel[Any]):\n    root: Any\n</code></pre>","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#reuse-model","level":2,"title":"<code>--reuse-model</code>","text":"<p>Reuse identical model definitions instead of generating duplicates.</p> <p>The <code>--reuse-model</code> flag detects identical enum or model definitions across the schema and generates a single shared definition, reducing code duplication in the output.</p> <p>Related: <code>--collapse-root-models</code></p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --reuse-model # (1)!\n</code></pre> <ol> <li> <code>--reuse-model</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema\",\n  \"title\": \"User\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"animal\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"dog\",\n        \"cat\",\n        \"snake\"\n      ],\n      \"default\": \"dog\"\n    },\n    \"pet\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"dog\",\n        \"cat\",\n        \"snake\"\n      ],\n      \"default\": \"cat\"\n    },\n    \"redistribute\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\",\n        \"enum\": [\n          \"static\",\n          \"connected\"\n        ]\n      }\n    }\n  },\n  \"definitions\": {\n    \"redistribute\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\",\n        \"enum\": [\n          \"static\",\n          \"connected\"\n        ]\n      },\n      \"description\": \"Redistribute type for routes.\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  duplicate_enum.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Animal(Enum):\n    dog = 'dog'\n    cat = 'cat'\n    snake = 'snake'\n\n\nclass RedistributeEnum(Enum):\n    static = 'static'\n    connected = 'connected'\n\n\nclass User(BaseModel):\n    name: Optional[str] = None\n    animal: Optional[Animal] = 'dog'\n    pet: Optional[Animal] = 'cat'\n    redistribute: Optional[List[RedistributeEnum]] = None\n\n\nclass Redistribute(BaseModel):\n    __root__: List[RedistributeEnum] = Field(\n        ..., description='Redistribute type for routes.'\n    )\n</code></pre>","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#reuse-scope","level":2,"title":"<code>--reuse-scope</code>","text":"<p>Scope for model reuse detection (root or tree).</p> <p>The <code>--reuse-scope</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --reuse-model --reuse-scope tree # (1)!\n</code></pre> <ol> <li> <code>--reuse-scope</code> - the option documented here</li> </ol> Input Schema <pre><code># schema_a.json\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"data\": { \"$ref\": \"#/$defs/SharedModel\" }\n  },\n  \"$defs\": {\n    \"SharedModel\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"id\": { \"type\": \"integer\" },\n        \"name\": { \"type\": \"string\" }\n      }\n    }\n  }\n}\n\n# schema_b.json\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"info\": { \"$ref\": \"#/$defs/SharedModel\" }\n  },\n  \"$defs\": {\n    \"SharedModel\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"id\": { \"type\": \"integer\" },\n        \"name\": { \"type\": \"string\" }\n      }\n    }\n  }\n}\n</code></pre> Output <pre><code># __init__.py\n# generated by datamodel-codegen:\n#   filename:  reuse_scope_tree\n#   timestamp: 2019-07-26T00:00:00+00:00\n\n# schema_a.py\n# generated by datamodel-codegen:\n#   filename:  reuse_scope_tree\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\nfrom .shared import SharedModel as SharedModel_1\n\n\nclass SharedModel(SharedModel_1):\n    pass\n\n\nclass Model(BaseModel):\n    data: Optional[SharedModel] = None\n\n# schema_b.py\n# generated by datamodel-codegen:\n#   filename:  schema_b.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\nfrom . import shared\n\n\nclass Model(BaseModel):\n    info: Optional[shared.SharedModel] = None\n\n# shared.py\n# generated by datamodel-codegen:\n#   filename:  shared.py\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass SharedModel(BaseModel):\n    id: Optional[int] = None\n    name: Optional[str] = None\n</code></pre>","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#skip-root-model","level":2,"title":"<code>--skip-root-model</code>","text":"<p>Skip generation of root model when schema contains nested definitions.</p> <p>The <code>--skip-root-model</code> flag prevents generating a model for the root schema object when the schema primarily contains reusable definitions. This is useful when the root object is just a container for $defs and not a meaningful model itself.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --output-model-type pydantic_v2.BaseModel --skip-root-model # (1)!\n</code></pre> <ol> <li> <code>--skip-root-model</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"_Placeholder\",\n  \"type\": \"null\",\n  \"$defs\": {\n    \"Person\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\"type\": \"string\"},\n        \"age\": {\"type\": \"integer\"}\n      },\n      \"required\": [\"name\"]\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  skip_root_model_test.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Person(BaseModel):\n    name: str\n    age: Optional[int] = None\n</code></pre>","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#strict-nullable","level":2,"title":"<code>--strict-nullable</code>","text":"<p>Strictly handle nullable types in OpenAPI schemas.</p> <p>The <code>--strict-nullable</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --strict-nullable # (1)!\n</code></pre> <ol> <li> <code>--strict-nullable</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: 3.0.3\ninfo:\n  version: 1.0.0\n  title: testapi\n  license:\n    name: proprietary\nservers: []\npaths: {}\ncomponents:\n  schemas:\n    TopLevel:\n      type: object\n      properties:\n        cursors:\n          type: object\n          properties:\n            prev:\n              type: string\n              nullable: true\n            next:\n              type: string\n              default: last\n            index:\n              type: number\n            tag:\n              type: string\n          required:\n          - prev\n          - index\n      required:\n      - cursors\n    User:\n      type: object\n      properties:\n        info:\n          type: object\n          properties:\n            name:\n              type: string\n          required:\n            - name\n      required:\n        - info\n    apis:\n      type: array\n      nullable: true\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n            nullable: true\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n            nullable: true\n    email:\n      type: array\n      items:\n        type: object\n        properties:\n          author:\n            type: string\n          address:\n            type: string\n            description: email address\n          description:\n            type: string\n            default: empty\n          tag:\n            type: string\n        required:\n          - author\n          - address\n    id:\n      type: integer\n      default: 1\n    description:\n      type: string\n      nullable: true\n      default: example\n    name:\n      type: string\n      nullable: true\n    tag:\n      type: string\n    notes:\n      type: object\n      properties:\n        comments:\n          type: array\n          items:\n              type: string\n          default_factory: list\n          nullable: false\n    options:\n      type: object\n      properties:\n        comments:\n          type: array\n          items:\n              type: string\n              nullable: true\n        oneOfComments:\n           type: array\n           items:\n               oneOf:\n                - type: string\n                - type: number\n               nullable: true\n      required:\n        - comments\n        - oneOfComments\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  nullable.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional, Union\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Cursors(BaseModel):\n    prev: Optional[str] = Field(...)\n    next: str = 'last'\n    index: float\n    tag: Optional[str] = None\n\n\nclass TopLevel(BaseModel):\n    cursors: Cursors\n\n\nclass Info(BaseModel):\n    name: str\n\n\nclass User(BaseModel):\n    info: Info\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: Optional[List[Api]] = Field(...)\n\n\nclass EmailItem(BaseModel):\n    author: str\n    address: str = Field(..., description='email address')\n    description: str = 'empty'\n    tag: Optional[str] = None\n\n\nclass Email(BaseModel):\n    __root__: List[EmailItem]\n\n\nclass Id(BaseModel):\n    __root__: int\n\n\nclass Description(BaseModel):\n    __root__: Optional[str] = 'example'\n\n\nclass Name(BaseModel):\n    __root__: Optional[str] = None\n\n\nclass Tag(BaseModel):\n    __root__: str\n\n\nclass Notes(BaseModel):\n    comments: List[str] = Field(default_factory=list)\n\n\nclass Options(BaseModel):\n    comments: List[Optional[str]]\n    oneOfComments: List[Union[Optional[str], Optional[float]]]\n</code></pre>","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#strip-default-none","level":2,"title":"<code>--strip-default-none</code>","text":"<p>Remove fields with None as default value from generated models.</p> <p>The <code>--strip-default-none</code> option removes fields that have None as their default value from the generated models. This results in cleaner model definitions by excluding optional fields that default to None.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --strip-default-none # (1)!\n</code></pre> <ol> <li> <code>--strip-default-none</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: error result\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str]\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str]\n\n\nclass Users(BaseModel):\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    name: Optional[str]\n\n\nclass Result(BaseModel):\n    event: Optional[Event]\n</code></pre>","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#target-python-version","level":2,"title":"<code>--target-python-version</code>","text":"<p>Target Python version for generated code syntax and imports.</p> <p>The <code>--target-python-version</code> flag controls Python version-specific syntax:</p> <ul> <li>Python 3.9: Uses <code>Optional[X]</code> for optional types, <code>typing.Dict/List</code></li> <li>Python 3.10+: Can use <code>X | None</code> union operator, built-in <code>dict/list</code></li> </ul> <p>This affects import statements and type annotation syntax in generated code.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --target-python-version 3.9 --use-standard-collections # (1)!\n</code></pre> <ol> <li> <code>--target-python-version</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Person\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"firstName\": {\n      \"type\": \"string\",\n      \"description\": \"The person's first name.\"\n    },\n    \"lastName\": {\n      \"type\": [\"string\", \"null\"],\n      \"description\": \"The person's last name.\"\n    },\n    \"age\": {\n      \"description\": \"Age in years which must be equal to or greater than zero.\",\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"friends\": {\n      \"type\": \"array\"\n    },\n    \"comment\": {\n      \"type\": \"null\"\n    }\n  }\n}\n</code></pre> Output Python 3.9Python 3.10 <pre><code># generated by datamodel-codegen:\n#   filename:  person.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Any, Optional\n\nfrom pydantic import BaseModel, Field, conint\n\n\nclass Person(BaseModel):\n    firstName: Optional[str] = Field(None, description=\"The person's first name.\")\n    lastName: Optional[str] = Field(None, description=\"The person's last name.\")\n    age: Optional[conint(ge=0)] = Field(\n        None, description='Age in years which must be equal to or greater than zero.'\n    )\n    friends: Optional[list[Any]] = None\n    comment: None = None\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  person.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Any\n\nfrom pydantic import BaseModel, Field, conint\n\n\nclass Person(BaseModel):\n    firstName: str | None = Field(None, description=\"The person's first name.\")\n    lastName: str | None = Field(None, description=\"The person's last name.\")\n    age: conint(ge=0) | None = Field(\n        None, description='Age in years which must be equal to or greater than zero.'\n    )\n    friends: list[Any] | None = None\n    comment: None = None\n</code></pre>","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#union-mode","level":2,"title":"<code>--union-mode</code>","text":"<p>Union mode for combining anyOf/oneOf schemas (smart or left_to_right).</p> <p>The <code>--union-mode</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --union-mode left_to_right --output-model-type pydantic_v2.BaseModel # (1)!\n</code></pre> <ol> <li> <code>--union-mode</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"type\": \"object\",\n    \"title\": \"My schema\",\n    \"additionalProperties\": true,\n    \"properties\": {\n        \"AddressLine1\": { \"type\": \"string\" },\n        \"AddressLine2\": { \"type\": \"string\" },\n        \"City\":         { \"type\": \"string\" }\n    },\n    \"required\": [ \"AddressLine1\" ],\n    \"anyOf\": [\n        {\n            \"type\": \"object\",\n            \"properties\": {\n                \"State\":   { \"type\": \"string\" },\n                \"ZipCode\": { \"type\": \"string\" }\n            },\n            \"required\": [ \"ZipCode\" ]\n        },\n        {\n            \"type\": \"object\",\n            \"properties\": {\n                \"County\":   { \"type\": \"string\" },\n                \"PostCode\": { \"type\": \"string\" }\n            },\n            \"required\": [ \"PostCode\" ]\n        },\n        { \"$ref\": \"#/definitions/US\" }\n    ],\n    \"definitions\": {\n        \"US\":  {\n            \"type\": \"object\",\n            \"properties\": {\n                \"County\":   { \"type\": \"string\" },\n                \"PostCode\": { \"type\": \"string\" }\n            },\n            \"required\": [ \"PostCode\" ]\n        }\n    }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  combine_any_of_object.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional, Union\n\nfrom pydantic import BaseModel, ConfigDict, Field, RootModel\n\n\nclass MySchema1(BaseModel):\n    model_config = ConfigDict(\n        extra='allow',\n    )\n    AddressLine1: str\n    AddressLine2: Optional[str] = None\n    City: Optional[str] = None\n    State: Optional[str] = None\n    ZipCode: str\n\n\nclass MySchema2(BaseModel):\n    model_config = ConfigDict(\n        extra='allow',\n    )\n    AddressLine1: str\n    AddressLine2: Optional[str] = None\n    City: Optional[str] = None\n    County: Optional[str] = None\n    PostCode: str\n\n\nclass US(BaseModel):\n    County: Optional[str] = None\n    PostCode: str\n\n\nclass MySchema3(US):\n    model_config = ConfigDict(\n        extra='allow',\n    )\n    AddressLine1: str\n    AddressLine2: Optional[str] = None\n    City: Optional[str] = None\n\n\nclass MySchema(RootModel[Union[MySchema1, MySchema2, MySchema3]]):\n    root: Union[MySchema1, MySchema2, MySchema3] = Field(\n        ..., title='My schema', union_mode='left_to_right'\n    )\n</code></pre>","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#use-default","level":2,"title":"<code>--use-default</code>","text":"<p>Use default values from schema in generated models.</p> <p>The <code>--use-default</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --output-model-type pydantic_v2.BaseModel --use-default # (1)!\n</code></pre> <ol> <li> <code>--use-default</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"title\": \"Use default with const\",\n    \"properties\": {\n        \"foo\": {\n            \"const\": \"foo\"\n        }\n    }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  use_default_with_const.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import BaseModel\n\n\nclass UseDefaultWithConst(BaseModel):\n    foo: Literal['foo'] = 'foo'\n</code></pre>","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#use-default-kwarg","level":2,"title":"<code>--use-default-kwarg</code>","text":"<p>Use default= keyword argument instead of positional argument for fields with defaults.</p> <p>The <code>--use-default-kwarg</code> flag generates Field() declarations using <code>default=</code> as a keyword argument instead of a positional argument for fields that have default values.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-default-kwarg # (1)!\n</code></pre> <ol> <li> <code>--use-default-kwarg</code> - the option documented here</li> </ol> Input Schema <pre><code>type A {\n    field: String!\n    optionalField: String\n    listField: [String!]!\n    listOptionalField: [String]!\n    optionalListField: [String!]\n    optionalListOptionalField: [String]\n    listListField:[[String!]!]!\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  annotated.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Literal, Optional\n\nfrom pydantic import BaseModel, Field\nfrom typing_extensions import TypeAlias\n\nBoolean: TypeAlias = bool\n\"\"\"\nThe `Boolean` scalar type represents `true` or `false`.\n\"\"\"\n\n\nString: TypeAlias = str\n\"\"\"\nThe `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\n\"\"\"\n\n\nclass A(BaseModel):\n    field: String\n    listField: List[String]\n    listListField: List[List[String]]\n    listOptionalField: List[Optional[String]]\n    optionalField: Optional[String] = None\n    optionalListField: Optional[List[String]] = None\n    optionalListOptionalField: Optional[List[Optional[String]]] = None\n    typename__: Optional[Literal['A']] = Field(default='A', alias='__typename')\n</code></pre>","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#use-frozen-field","level":2,"title":"<code>--use-frozen-field</code>","text":"<p>Generate frozen (immutable) field definitions for readOnly properties.</p> <p>The <code>--use-frozen-field</code> flag generates frozen field definitions: - Pydantic v1: <code>Field(allow_mutation=False)</code> - Pydantic v2: <code>Field(frozen=True)</code> - Dataclasses: silently ignored (no frozen fields generated)</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-frozen-field # (1)!\n</code></pre> <ol> <li> <code>--use-frozen-field</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"User\",\n  \"type\": \"object\",\n  \"required\": [\"id\", \"name\", \"password\"],\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\",\n      \"description\": \"Server-generated ID\",\n      \"readOnly\": true\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"password\": {\n      \"type\": \"string\",\n      \"description\": \"User password\",\n      \"writeOnly\": true\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\",\n      \"readOnly\": true\n    }\n  }\n}\n</code></pre> Output Pydantic v1Pydantic v2dataclass <pre><code># generated by datamodel-codegen:\n#   filename:  use_frozen_field.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    class Config:\n        validate_assignment = True\n\n    id: int = Field(..., allow_mutation=False, description='Server-generated ID')\n    name: str\n    password: str = Field(..., description='User password')\n    created_at: Optional[datetime] = Field(None, allow_mutation=False)\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  use_frozen_field.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import AwareDatetime, BaseModel, Field\n\n\nclass User(BaseModel):\n    id: int = Field(..., description='Server-generated ID', frozen=True)\n    name: str\n    password: str = Field(..., description='User password')\n    created_at: Optional[AwareDatetime] = Field(None, frozen=True)\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  use_frozen_field.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import Optional\n\n\n@dataclass\nclass User:\n    id: int\n    name: str\n    password: str\n    created_at: Optional[str] = None\n</code></pre>","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#use-one-literal-as-default","level":2,"title":"<code>--use-one-literal-as-default</code>","text":"<p>Use single literal value as default when enum has only one option.</p> <p>The <code>--use-one-literal-as-default</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-one-literal-as-default --enum-field-as-literal one # (1)!\n</code></pre> <ol> <li> <code>--use-one-literal-as-default</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n        - number\n        - boolean\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        tag:\n          type: string\n        kind:\n          type: string\n          enum: ['dog', 'cat']\n        type:\n          type: string\n          enum: [ 'animal' ]\n        number:\n          type: integer\n          enum: [ 1 ]\n        boolean:\n          type: boolean\n          enum: [ true ]\n\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    animal:\n      type: object\n      properties:\n        kind:\n          type: string\n          enum: ['snake', 'rabbit']\n    Error:\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    EnumObject:\n      type: object\n      properties:\n        type:\n          enum: ['a', 'b']\n          type: string\n    EnumRoot:\n      enum: ['a', 'b']\n      type: string\n    IntEnum:\n      enum: [1,2]\n      type: number\n    AliasEnum:\n      enum: [1,2,3]\n      type: number\n      x-enum-varnames: ['a', 'b', 'c']\n    MultipleTypeEnum:\n      enum: [ \"red\", \"amber\", \"green\", null, 42 ]\n    singleEnum:\n      enum: [ \"pet\" ]\n      type: string\n    arrayEnum:\n      type: array\n      items: [\n        { enum: [ \"cat\" ] },\n        { enum: [ \"dog\"]}\n      ]\n    nestedNullableEnum:\n      type: object\n      properties:\n        nested_version:\n          type: string\n          nullable: true\n          default: RC1\n          description: nullable enum\n          example: RC2\n          enum:\n            - RC1\n            - RC1N\n            - RC2\n            - RC2N\n            - RC3\n            - RC4\n            - null\n    version:\n      type: string\n      nullable: true\n      default: RC1\n      description: nullable enum\n      example: RC2\n      enum:\n      - RC1\n      - RC1N\n      - RC2\n      - RC2N\n      - RC3\n      - RC4\n      - null\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  enum_models.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import List, Literal, Optional, Union\n\nfrom pydantic import BaseModel, Field\n\n\nclass Kind(Enum):\n    dog = 'dog'\n    cat = 'cat'\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n    kind: Optional[Kind] = None\n    type: Optional[Literal['animal']] = None\n    number: Literal[1] = 1\n    boolean: Literal[True] = True\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass Kind1(Enum):\n    snake = 'snake'\n    rabbit = 'rabbit'\n\n\nclass Animal(BaseModel):\n    kind: Optional[Kind1] = None\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Type(Enum):\n    a = 'a'\n    b = 'b'\n\n\nclass EnumObject(BaseModel):\n    type: Optional[Type] = None\n\n\nclass EnumRoot(Enum):\n    a = 'a'\n    b = 'b'\n\n\nclass IntEnum(Enum):\n    number_1 = 1\n    number_2 = 2\n\n\nclass AliasEnum(Enum):\n    a = 1\n    b = 2\n    c = 3\n\n\nclass MultipleTypeEnum(Enum):\n    red = 'red'\n    amber = 'amber'\n    green = 'green'\n    NoneType_None = None\n    int_42 = 42\n\n\nclass SingleEnum(BaseModel):\n    __root__: Literal['pet'] = 'pet'\n\n\nclass ArrayEnum(BaseModel):\n    __root__: List[Union[Literal['cat'], Literal['dog']]]\n\n\nclass NestedVersionEnum(Enum):\n    RC1 = 'RC1'\n    RC1N = 'RC1N'\n    RC2 = 'RC2'\n    RC2N = 'RC2N'\n    RC3 = 'RC3'\n    RC4 = 'RC4'\n\n\nclass NestedVersion(BaseModel):\n    __root__: Optional[NestedVersionEnum] = Field(\n        'RC1', description='nullable enum', example='RC2'\n    )\n\n\nclass NestedNullableEnum(BaseModel):\n    nested_version: Optional[NestedVersion] = Field(\n        default_factory=lambda: NestedVersion.parse_obj('RC1'),\n        description='nullable enum',\n        example='RC2',\n    )\n\n\nclass VersionEnum(Enum):\n    RC1 = 'RC1'\n    RC1N = 'RC1N'\n    RC2 = 'RC2'\n    RC2N = 'RC2N'\n    RC3 = 'RC3'\n    RC4 = 'RC4'\n\n\nclass Version(BaseModel):\n    __root__: Optional[VersionEnum] = Field(\n        'RC1', description='nullable enum', example='RC2'\n    )\n</code></pre>","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#use-serialize-as-any","level":2,"title":"<code>--use-serialize-as-any</code>","text":"<p>Wrap fields with subtypes in Pydantic's SerializeAsAny.</p> <p>The <code>--use-serialize-as-any</code> flag applies Pydantic v2's SerializeAsAny wrapper to fields that have subtype relationships, ensuring proper serialization of polymorphic types and inheritance hierarchies.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-serialize-as-any # (1)!\n</code></pre> <ol> <li> <code>--use-serialize-as-any</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: SerializeAsAny Test\n  description: Test schema for SerializeAsAny annotation on types with subtypes\npaths: {}\ncomponents:\n  schemas:\n    User:\n      type: object\n      description: Base user model\n      properties:\n        name:\n          type: string\n          description: User's name\n      required:\n        - name\n\n    AdminUser:\n      allOf:\n        - $ref: '#/components/schemas/User'\n        - type: object\n          description: Admin user with additional permissions\n          properties:\n            admin_level:\n              type: integer\n              description: Admin permission level\n          required:\n            - admin_level\n\n    Container:\n      type: object\n      description: Container that holds user references\n      properties:\n        admin_user_field:\n          $ref: '#/components/schemas/AdminUser'\n          description: Field that should not use SerializeAsAny\n        user_field:\n          $ref: '#/components/schemas/User'\n          description: Field that should use SerializeAsAny\n        user_list:\n          type: array\n          description: List of users that should use SerializeAsAny\n          items:\n            $ref: '#/components/schemas/User'\n      required:\n        - user_field\n        - user_list\n        - admin_user_field\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  serialize_as_any.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List\n\nfrom pydantic import BaseModel, Field, SerializeAsAny\n\n\nclass User(BaseModel):\n    name: str = Field(..., description=\"User's name\")\n\n\nclass AdminUser(User):\n    admin_level: int = Field(..., description='Admin permission level')\n\n\nclass Container(BaseModel):\n    admin_user_field: AdminUser = Field(\n        ..., description='Field that should not use SerializeAsAny'\n    )\n    user_field: SerializeAsAny[User] = Field(\n        ..., description='Field that should use SerializeAsAny'\n    )\n    user_list: List[SerializeAsAny[User]] = Field(\n        ..., description='List of users that should use SerializeAsAny'\n    )\n</code></pre>","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#use-subclass-enum","level":2,"title":"<code>--use-subclass-enum</code>","text":"<p>Generate typed Enum subclasses for enums with specific field types.</p> <p>The <code>--use-subclass-enum</code> flag generates Enum classes as subclasses of the appropriate field type (int, float, bytes, str) when an enum has a specific type, providing better type safety and IDE support.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-subclass-enum # (1)!\n</code></pre> <ol> <li> <code>--use-subclass-enum</code> - the option documented here</li> </ol> Input Schema <pre><code>\"Employee shift status\"\nenum EmployeeShiftStatus {\n  \"not on shift\"\n  NOT_ON_SHIFT\n  \"on shift\"\n  ON_SHIFT\n}\n\nenum Color {\n  RED\n  GREEN\n  BLUE\n}\n\nenum EnumWithOneField {\n    FIELD\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  enums.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\n\nfrom typing_extensions import TypeAlias\n\nBoolean: TypeAlias = bool\n\"\"\"\nThe `Boolean` scalar type represents `true` or `false`.\n\"\"\"\n\n\nString: TypeAlias = str\n\"\"\"\nThe `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\n\"\"\"\n\n\nclass Color(str, Enum):\n    BLUE = 'BLUE'\n    GREEN = 'GREEN'\n    RED = 'RED'\n\n\nclass EmployeeShiftStatus(str, Enum):\n    \"\"\"\n    Employee shift status\n    \"\"\"\n\n    NOT_ON_SHIFT = 'NOT_ON_SHIFT'\n    ON_SHIFT = 'ON_SHIFT'\n\n\nclass EnumWithOneField(str, Enum):\n    FIELD = 'FIELD'\n</code></pre>","path":["CLI Reference","Model Customization"],"tags":[]},{"location":"cli-reference/openapi-only-options/","level":1,"title":"OpenAPI-only Options","text":"<p>Related Documentation</p> <p>For OpenAPI usage guide and examples, see Generate from OpenAPI.</p>","path":["CLI Reference","OpenAPI-only Options"],"tags":[]},{"location":"cli-reference/openapi-only-options/#options","level":2,"title":"Options","text":"Option Description <code>--include-path-parameters</code> Include OpenAPI path parameters in generated parameter model... <code>--openapi-scopes</code> Specify OpenAPI scopes to generate (schemas, paths, paramete... <code>--read-only-write-only-model-type</code> Generate separate request and response models for readOnly/w... <code>--use-operation-id-as-name</code> Use OpenAPI operationId as the generated function/class name... <code>--validation</code> Enable validation constraints (deprecated, use --field-const...","path":["CLI Reference","OpenAPI-only Options"],"tags":[]},{"location":"cli-reference/openapi-only-options/#include-path-parameters","level":2,"title":"<code>--include-path-parameters</code>","text":"<p>Include OpenAPI path parameters in generated parameter models.</p> <p>The <code>--include-path-parameters</code> flag adds path parameters (like /users/{userId}) to the generated request parameter models. By default, only query parameters are included. Use this with <code>--openapi-scopes parameters</code> to generate parameter models that include both path and query parameters.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --include-path-parameters --openapi-scopes schemas paths parameters # (1)!\n</code></pre> <ol> <li> <code>--include-path-parameters</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: API with Path Parameters\npaths:\n  /users/{userId}/posts/{postId}:\n    get:\n      summary: Get a specific post by user\n      operationId: getUserPost\n      parameters:\n        - name: userId\n          in: path\n          required: true\n          schema:\n            type: integer\n        - name: postId\n          in: path\n          required: true\n          schema:\n            type: string\n        - name: includeComments\n          in: query\n          required: false\n          schema:\n            type: boolean\n      responses:\n        '200':\n          description: A post\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Post\"\ncomponents:\n  schemas:\n    Post:\n      type: object\n      properties:\n        id:\n          type: string\n        title:\n          type: string\n        content:\n          type: string\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  include_path_parameters.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Post(BaseModel):\n    id: Optional[str] = None\n    title: Optional[str] = None\n    content: Optional[str] = None\n\n\nclass UsersUserIdPostsPostIdGetParameters(BaseModel):\n    userId: int\n    postId: str\n    includeComments: Optional[bool] = None\n</code></pre>","path":["CLI Reference","OpenAPI-only Options"],"tags":[]},{"location":"cli-reference/openapi-only-options/#openapi-scopes","level":2,"title":"<code>--openapi-scopes</code>","text":"<p>Specify OpenAPI scopes to generate (schemas, paths, parameters).</p> <p>The <code>--openapi-scopes</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --openapi-scopes paths schemas # (1)!\n</code></pre> <ol> <li> <code>--openapi-scopes</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\n  description: |\n    This description is for testing\n    multi-line\n    description\n\nservers:\n  - url: http://petstore.swagger.io/v1\nsecurity:\n  - BearerAuth: []\npaths:\n  /pets:\n    $ref: '#/components/pathItems/Pets'\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pet\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    put:\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      summary: update a pet\n      tags:\n        - pets\n      requestBody:\n        required: false\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/PetForm'\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\n  /food:\n    post:\n      summary: Create a food\n      tags:\n        - pets\n      requestBody:\n        required: true\n        content:\n          application/problem+json:\n            schema:\n              type: string\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/problem+json:\n              schema:\n                type: string\n  /food/{food_id}:\n    get:\n      summary: Info for a specific pet\n      operationId: showFoodById\n      tags:\n        - foods\n      parameters:\n        - name: food_id\n          in: path\n          description: The id of the food to retrieve\n          schema:\n            type: string\n        - name: message_texts\n          in: query\n          required: false\n          explode: true\n          schema:\n            type: array\n            items:\n              type: string\n      responses:\n        '200':\n          description: OK\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  type: integer\n              examples:\n                example-1:\n                  value:\n                    - 0\n                    - 1\n                    - 3\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\n  /foo:\n    get:\n      tags:\n        - foo\n      responses:\n        '200':\n          description: OK\n          content:\n            application/json:\n              schema:\n                type: string\n    parameters:\n    - $ref: '#/components/parameters/MyParam'\n  /bar:\n    post:\n      summary: Create a bar\n      tags:\n        - bar\n      requestBody:\n        content:\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: '#/components/schemas/PetForm'\n  /user:\n    get:\n      tags:\n        - user\n      responses:\n        '200':\n          description: OK\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  timestamp:\n                    type: string\n                    format: date-time\n                  name:\n                    type: string\n                  age:\n                    type: string\n                required:\n                  - name\n                  - timestamp\n    post:\n      tags:\n        - user\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                timestamp:\n                  type: string\n                  format: date-time\n                name:\n                  type: string\n                age:\n                  type: string\n              required:\n                - name\n                - timestamp\n      responses:\n        '201':\n          description: OK\n  /users:\n    get:\n      tags:\n        - user\n      responses:\n        '200':\n          description: OK\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  type: object\n                  properties:\n                    timestamp:\n                      type: string\n                      format: date-time\n                    name:\n                      type: string\n                    age:\n                      type: string\n                  required:\n                    - name\n                    - timestamp\n    post:\n      tags:\n        - user\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              type: array\n              items:\n                type: object\n                properties:\n                  timestamp:\n                    type: string\n                    format: date-time\n                  name:\n                    type: string\n                  age:\n                    type: string\n                required:\n                  - name\n                  - timestamp\n      responses:\n        '201':\n          description: OK\ncomponents:\n  parameters:\n    MyParam:\n      name: foo\n      in: query\n      schema:\n        type: string\n  securitySchemes:\n    BearerAuth:\n      type: http\n      scheme: bearer\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        tag:\n          type: string\n    Error:\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    PetForm:\n      title: PetForm\n      type: object\n      properties:\n        name:\n          type: string\n        age:\n          type: integer\n  pathItems:\n    Pets:\n      get:\n        summary: List all pets\n        operationId: listPets\n        tags:\n          - pets\n        security: []\n        parameters:\n          - name: limit\n            in: query\n            description: How many items to return at one time (max 100)\n            required: false\n            schema:\n              default: 0\n              type: integer\n              format: int32\n          - name: HomeAddress\n            in: query\n            required: false\n            schema:\n              default: 'Unknown'\n              type: string\n          - name: kind\n            in: query\n            required: false\n            schema:\n              default: dog\n              type: string\n        responses:\n          '200':\n            description: A paged array of pets\n            headers:\n              x-next:\n                description: A link to the next page of responses\n                schema:\n                  type: string\n            content:\n              application/json:\n                schema:\n                  type: array\n                  items:\n                  - $ref: \"#/components/schemas/Pet\"\n          default:\n            description: unexpected error\n            content:\n              application/json:\n                schema:\n                  $ref: \"#/components/schemas/Error\"\n      post:\n        summary: Create a pet\n        tags:\n          - pets\n        requestBody:\n          required: true\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/PetForm'\n        responses:\n          '201':\n            description: Null response\n          default:\n            description: unexpected error\n            content:\n              application/json:\n                schema:\n                  $ref: \"#/components/schemas/Error\"\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  body_and_parameters.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass PetForm(BaseModel):\n    name: Optional[str] = None\n    age: Optional[int] = None\n\n\nclass PetsGetResponse(BaseModel):\n    __root__: List[Pet]\n\n\nclass FoodFoodIdGetResponse(BaseModel):\n    __root__: List[int]\n\n\nclass UserGetResponse(BaseModel):\n    timestamp: datetime\n    name: str\n    age: Optional[str] = None\n\n\nclass UserPostRequest(BaseModel):\n    timestamp: datetime\n    name: str\n    age: Optional[str] = None\n\n\nclass UsersGetResponseItem(BaseModel):\n    timestamp: datetime\n    name: str\n    age: Optional[str] = None\n\n\nclass UsersGetResponse(BaseModel):\n    __root__: List[UsersGetResponseItem]\n\n\nclass UsersPostRequestItem(BaseModel):\n    timestamp: datetime\n    name: str\n    age: Optional[str] = None\n\n\nclass UsersPostRequest(BaseModel):\n    __root__: List[UsersPostRequestItem]\n</code></pre>","path":["CLI Reference","OpenAPI-only Options"],"tags":[]},{"location":"cli-reference/openapi-only-options/#read-only-write-only-model-type","level":2,"title":"<code>--read-only-write-only-model-type</code>","text":"<p>Generate separate request and response models for readOnly/writeOnly fields.</p> <p>The <code>--read-only-write-only-model-type</code> option controls how models with readOnly or writeOnly properties are generated. The 'request-response' mode creates separate Request and Response variants for each schema that contains readOnly or writeOnly fields, allowing proper type validation for API requests and responses without a shared base model.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --output-model-type pydantic_v2.BaseModel --read-only-write-only-model-type request-response # (1)!\n</code></pre> <ol> <li> <code>--read-only-write-only-model-type</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  title: Read Only Write Only Test API\n  version: \"1.0\"\npaths: {}\ncomponents:\n  schemas:\n    User:\n      type: object\n      required:\n        - id\n        - name\n        - password\n      properties:\n        id:\n          type: integer\n          readOnly: true\n        name:\n          type: string\n        password:\n          type: string\n          writeOnly: true\n        created_at:\n          type: string\n          format: date-time\n          readOnly: true\n        secret_token:\n          type: string\n          writeOnly: true\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  read_only_write_only.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import AwareDatetime, BaseModel\n\n\nclass UserRequest(BaseModel):\n    name: str\n    password: str\n    secret_token: Optional[str] = None\n\n\nclass UserResponse(BaseModel):\n    id: int\n    name: str\n    created_at: Optional[AwareDatetime] = None\n</code></pre>","path":["CLI Reference","OpenAPI-only Options"],"tags":[]},{"location":"cli-reference/openapi-only-options/#use-operation-id-as-name","level":2,"title":"<code>--use-operation-id-as-name</code>","text":"<p>Use OpenAPI operationId as the generated function/class name.</p> <p>The <code>--use-operation-id-as-name</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-operation-id-as-name --openapi-scopes paths schemas parameters # (1)!\n</code></pre> <ol> <li> <code>--use-operation-id-as-name</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: error result\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(BaseModel):\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n\n\nclass ListPetsParametersQuery(BaseModel):\n    limit: Optional[int] = None\n</code></pre>","path":["CLI Reference","OpenAPI-only Options"],"tags":[]},{"location":"cli-reference/openapi-only-options/#validation","level":2,"title":"<code>--validation</code>","text":"<p>Enable validation constraints (deprecated, use --field-constraints).</p> <p>The <code>--validation</code> flag configures the code generation behavior.</p> <p>Deprecated: Use --field-constraints instead</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --validation # (1)!\n</code></pre> <ol> <li> <code>--validation</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: error result\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(BaseModel):\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","OpenAPI-only Options"],"tags":[]},{"location":"cli-reference/quick-reference/","level":1,"title":"Quick Reference","text":"<p>All CLI options in one page for easy Ctrl+F searching.</p> <p>Click any option to see detailed documentation with examples.</p> <pre><code>datamodel-codegen [OPTIONS]\n</code></pre>","path":["CLI Reference","Quick Reference"],"tags":[]},{"location":"cli-reference/quick-reference/#all-options-by-category","level":2,"title":"All Options by Category","text":"","path":["CLI Reference","Quick Reference"],"tags":[]},{"location":"cli-reference/quick-reference/#base-options","level":3,"title":"Base Options","text":"Option Description <code>--encoding</code> Specify character encoding for input and output files. <code>--input</code> Specify the input schema file path. <code>--input-file-type</code> Specify the input file type for code generation. <code>--output</code> Specify the destination path for generated Python code. <code>--url</code> Fetch schema from URL with custom HTTP headers.","path":["CLI Reference","Quick Reference"],"tags":[]},{"location":"cli-reference/quick-reference/#typing-customization","level":3,"title":"Typing Customization","text":"Option Description <code>--allof-merge-mode</code> Merge constraints from root model references in allOf schemas. <code>--disable-future-imports</code> Prevent automatic addition of future imports in generated code. <code>--enum-field-as-literal</code> Convert all enum fields to Literal types instead of Enum classes. <code>--no-use-specialized-enum</code> Disable specialized Enum classes for Python 3.11+ code generation. <code>--output-datetime-class</code> Specify datetime class type for date-time schema fields. <code>--strict-types</code> Enable strict type validation for specified Python types. <code>--type-mappings</code> Override default type mappings for schema formats. <code>--use-annotated</code> Test GraphQL annotated types with standard collections and union operator. <code>--use-decimal-for-multiple-of</code> Generate Decimal types for fields with multipleOf constraint. <code>--use-generic-container-types</code> Use typing.Dict/List instead of dict/list for container types. <code>--use-non-positive-negative-number-constrained-types</code> Use NonPositive/NonNegative types for number constraints. <code>--use-pendulum</code> Use pendulum types for date/time fields instead of datetime module. <code>--use-standard-collections</code> Use built-in dict/list instead of typing.Dict/List. <code>--use-type-alias</code> Use TypeAlias instead of root models for type definitions (experimental). <code>--use-union-operator</code> Test GraphQL annotated types with standard collections and union operator. <code>--use-unique-items-as-set</code> Generate set types for arrays with uniqueItems constraint.","path":["CLI Reference","Quick Reference"],"tags":[]},{"location":"cli-reference/quick-reference/#field-customization","level":3,"title":"Field Customization","text":"Option Description <code>--aliases</code> Apply custom field and class name aliases from JSON file. <code>--capitalize-enum-members</code> Capitalize enum member names to UPPER_CASE format. <code>--empty-enum-field-name</code> Name for empty string enum field values. <code>--extra-fields</code> Configure how generated models handle extra fields not defined in schema. <code>--field-constraints</code> Generate Field() with validation constraints from schema. <code>--field-extra-keys</code> Include specific extra keys in Field() definitions. <code>--field-extra-keys-without-x-prefix</code> Include specified schema extension keys in Field() without requiring 'x-' prefix... <code>--field-include-all-keys</code> Include all schema keys in Field() json_schema_extra. <code>--no-alias</code> Disable Field alias generation for non-Python-safe property names. <code>--original-field-name-delimiter</code> Specify delimiter for original field names when using snake-case conversion. <code>--remove-special-field-name-prefix</code> Remove the special prefix from field names. <code>--set-default-enum-member</code> Set the first enum member as the default value for enum fields. <code>--snake-case-field</code> Convert field names to snake_case format. <code>--special-field-name-prefix</code> Prefix to add to special field names (like reserved keywords). <code>--use-attribute-docstrings</code> Generate field descriptions as attribute docstrings instead of Field description... <code>--use-enum-values-in-discriminator</code> Use enum values in discriminator mappings for union types. <code>--use-field-description</code> Include schema descriptions as Field docstrings. <code>--use-inline-field-description</code> Add field descriptions as inline comments. <code>--use-schema-description</code> Use schema description as class docstring. <code>--use-title-as-name</code> Use schema title as the generated class name.","path":["CLI Reference","Quick Reference"],"tags":[]},{"location":"cli-reference/quick-reference/#model-customization","level":3,"title":"Model Customization","text":"Option Description <code>--allow-extra-fields</code> Allow extra fields in generated Pydantic models (extra='allow'). <code>--allow-population-by-field-name</code> Allow Pydantic model population by field name (not just alias). <code>--base-class</code> Specify a custom base class for generated models. <code>--class-name</code> Override the auto-generated class name with a custom name. <code>--collapse-root-models</code> Inline root model definitions instead of creating separate wrapper classes. <code>--dataclass-arguments</code> Customize dataclass decorator arguments via JSON dictionary. <code>--enable-faux-immutability</code> Enable faux immutability in Pydantic v1 models (allow_mutation=False). <code>--force-optional</code> Force all fields to be Optional regardless of required status. <code>--frozen-dataclasses</code> Generate frozen dataclasses with optional keyword-only fields. <code>--keep-model-order</code> Keep model definition order as specified in schema. <code>--keyword-only</code> Generate dataclasses with keyword-only fields (Python 3.10+). <code>--output-model-type</code> Select the output model type (Pydantic v1/v2, dataclasses, TypedDict, msgspec). <code>--parent-scoped-naming</code> Namespace models by their parent scope to avoid naming conflicts. <code>--reuse-model</code> Reuse identical model definitions instead of generating duplicates. <code>--reuse-scope</code> Scope for model reuse detection (root or tree). <code>--skip-root-model</code> Skip generation of root model when schema contains nested definitions. <code>--strict-nullable</code> Strictly handle nullable types in OpenAPI schemas. <code>--strip-default-none</code> Remove fields with None as default value from generated models. <code>--target-python-version</code> Target Python version for generated code syntax and imports. <code>--union-mode</code> Union mode for combining anyOf/oneOf schemas (smart or left_to_right). <code>--use-default</code> Use default values from schema in generated models. <code>--use-default-kwarg</code> Use default= keyword argument instead of positional argument for fields with def... <code>--use-frozen-field</code> Generate frozen (immutable) field definitions for readOnly properties. <code>--use-one-literal-as-default</code> Use single literal value as default when enum has only one option. <code>--use-serialize-as-any</code> Wrap fields with subtypes in Pydantic's SerializeAsAny. <code>--use-subclass-enum</code> Generate typed Enum subclasses for enums with specific field types.","path":["CLI Reference","Quick Reference"],"tags":[]},{"location":"cli-reference/quick-reference/#template-customization","level":3,"title":"Template Customization","text":"Option Description <code>--additional-imports</code> Add custom imports to generated output files. <code>--custom-file-header</code> Add custom header text to the generated file. <code>--custom-file-header-path</code> Add custom header content from file to generated code. <code>--custom-formatters</code> Apply custom Python code formatters to generated output. <code>--custom-formatters-kwargs</code> Pass custom arguments to custom formatters via JSON file. <code>--custom-template-dir</code> Use custom Jinja2 templates for model generation. <code>--disable-appending-item-suffix</code> Disable appending 'Item' suffix to array item types. <code>--disable-timestamp</code> Disable timestamp in generated file header for reproducible output. <code>--enable-version-header</code> Include tool version information in file header. <code>--extra-template-data</code> Pass custom template variables from JSON file for code generation. <code>--formatters</code> Specify code formatters to apply to generated output. <code>--treat-dot-as-module</code> Treat dots in schema names as module separators. <code>--use-double-quotes</code> Use double quotes for string literals in generated code. <code>--use-exact-imports</code> Import exact types instead of modules. <code>--wrap-string-literal</code> Wrap long string literals across multiple lines.","path":["CLI Reference","Quick Reference"],"tags":[]},{"location":"cli-reference/quick-reference/#openapi-only-options","level":3,"title":"OpenAPI-only Options","text":"Option Description <code>--include-path-parameters</code> Include OpenAPI path parameters in generated parameter models. <code>--openapi-scopes</code> Specify OpenAPI scopes to generate (schemas, paths, parameters). <code>--read-only-write-only-model-type</code> Generate separate request and response models for readOnly/writeOnly fields. <code>--use-operation-id-as-name</code> Use OpenAPI operationId as the generated function/class name. <code>--validation</code> Enable validation constraints (deprecated, use --field-constraints).","path":["CLI Reference","Quick Reference"],"tags":[]},{"location":"cli-reference/quick-reference/#general-options","level":3,"title":"General Options","text":"Option Description <code>--all-exports-collision-strategy</code> Handle name collisions when exporting recursive module hierarchies. <code>--all-exports-scope</code> Generate all exports for child modules in init.py files. <code>--check</code> Verify generated code matches existing output without modifying files. <code>--disable-warnings</code> Suppress warning messages during code generation. <code>--generate-cli-command</code> Generate CLI command from pyproject.toml configuration. <code>--generate-pyproject-config</code> Generate pyproject.toml configuration from CLI arguments. <code>--http-headers</code> Fetch schema from URL with custom HTTP headers. <code>--http-ignore-tls</code> Disable TLS certificate verification for HTTPS requests. <code>--http-query-parameters</code> Add query parameters to HTTP requests for remote schemas. <code>--ignore-pyproject</code> Ignore pyproject.toml configuration file. <code>--shared-module-name</code> Customize the name of the shared module for deduplicated models.","path":["CLI Reference","Quick Reference"],"tags":[]},{"location":"cli-reference/quick-reference/#alphabetical-index","level":2,"title":"Alphabetical Index","text":"<p>All options sorted alphabetically:</p> <ul> <li><code>--additional-imports</code> - Add custom imports to generated output files.</li> <li><code>--aliases</code> - Apply custom field and class name aliases from JSON file.</li> <li><code>--all-exports-collision-strategy</code> - Handle name collisions when exporting recursive module hiera...</li> <li><code>--all-exports-scope</code> - Generate all exports for child modules in init.py fi...</li> <li><code>--allof-merge-mode</code> - Merge constraints from root model references in allOf schema...</li> <li><code>--allow-extra-fields</code> - Allow extra fields in generated Pydantic models (extra='allo...</li> <li><code>--allow-population-by-field-name</code> - Allow Pydantic model population by field name (not just alia...</li> <li><code>--base-class</code> - Specify a custom base class for generated models.</li> <li><code>--capitalize-enum-members</code> - Capitalize enum member names to UPPER_CASE format.</li> <li><code>--check</code> - Verify generated code matches existing output without modify...</li> <li><code>--class-name</code> - Override the auto-generated class name with a custom name.</li> <li><code>--collapse-root-models</code> - Inline root model definitions instead of creating separate w...</li> <li><code>--custom-file-header</code> - Add custom header text to the generated file.</li> <li><code>--custom-file-header-path</code> - Add custom header content from file to generated code.</li> <li><code>--custom-formatters</code> - Apply custom Python code formatters to generated output.</li> <li><code>--custom-formatters-kwargs</code> - Pass custom arguments to custom formatters via JSON file.</li> <li><code>--custom-template-dir</code> - Use custom Jinja2 templates for model generation.</li> <li><code>--dataclass-arguments</code> - Customize dataclass decorator arguments via JSON dictionary.</li> <li><code>--disable-appending-item-suffix</code> - Disable appending 'Item' suffix to array item types.</li> <li><code>--disable-future-imports</code> - Prevent automatic addition of future imports in generate...</li> <li><code>--disable-timestamp</code> - Disable timestamp in generated file header for reproducible ...</li> <li><code>--disable-warnings</code> - Suppress warning messages during code generation.</li> <li><code>--empty-enum-field-name</code> - Name for empty string enum field values.</li> <li><code>--enable-faux-immutability</code> - Enable faux immutability in Pydantic v1 models (allow_mutati...</li> <li><code>--enable-version-header</code> - Include tool version information in file header.</li> <li><code>--encoding</code> - Specify character encoding for input and output files.</li> <li><code>--enum-field-as-literal</code> - Convert all enum fields to Literal types instead of Enum cla...</li> <li><code>--extra-fields</code> - Configure how generated models handle extra fields not defin...</li> <li><code>--extra-template-data</code> - Pass custom template variables from JSON file for code gener...</li> <li><code>--field-constraints</code> - Generate Field() with validation constraints from schema.</li> <li><code>--field-extra-keys</code> - Include specific extra keys in Field() definitions.</li> <li><code>--field-extra-keys-without-x-prefix</code> - Include specified schema extension keys in Field() without r...</li> <li><code>--field-include-all-keys</code> - Include all schema keys in Field() json_schema_extra.</li> <li><code>--force-optional</code> - Force all fields to be Optional regardless of required statu...</li> <li><code>--formatters</code> - Specify code formatters to apply to generated output.</li> <li><code>--frozen-dataclasses</code> - Generate frozen dataclasses with optional keyword-only field...</li> <li><code>--generate-cli-command</code> - Generate CLI command from pyproject.toml configuration.</li> <li><code>--generate-pyproject-config</code> - Generate pyproject.toml configuration from CLI arguments.</li> <li><code>--http-headers</code> - Fetch schema from URL with custom HTTP headers.</li> <li><code>--http-ignore-tls</code> - Disable TLS certificate verification for HTTPS requests.</li> <li><code>--http-query-parameters</code> - Add query parameters to HTTP requests for remote schemas.</li> <li><code>--ignore-pyproject</code> - Ignore pyproject.toml configuration file.</li> <li><code>--include-path-parameters</code> - Include OpenAPI path parameters in generated parameter model...</li> <li><code>--input</code> - Specify the input schema file path.</li> <li><code>--input-file-type</code> - Specify the input file type for code generation.</li> <li><code>--keep-model-order</code> - Keep model definition order as specified in schema.</li> <li><code>--keyword-only</code> - Generate dataclasses with keyword-only fields (Python 3.10+)...</li> <li><code>--no-alias</code> - Disable Field alias generation for non-Python-safe property ...</li> <li><code>--no-use-specialized-enum</code> - Disable specialized Enum classes for Python 3.11+ code gener...</li> <li><code>--openapi-scopes</code> - Specify OpenAPI scopes to generate (schemas, paths, paramete...</li> <li><code>--original-field-name-delimiter</code> - Specify delimiter for original field names when using snake-...</li> <li><code>--output</code> - Specify the destination path for generated Python code.</li> <li><code>--output-datetime-class</code> - Specify datetime class type for date-time schema fields.</li> <li><code>--output-model-type</code> - Select the output model type (Pydantic v1/v2, dataclasses, T...</li> <li><code>--parent-scoped-naming</code> - Namespace models by their parent scope to avoid naming confl...</li> <li><code>--read-only-write-only-model-type</code> - Generate separate request and response models for readOnly/w...</li> <li><code>--remove-special-field-name-prefix</code> - Remove the special prefix from field names.</li> <li><code>--reuse-model</code> - Reuse identical model definitions instead of generating dupl...</li> <li><code>--reuse-scope</code> - Scope for model reuse detection (root or tree).</li> <li><code>--set-default-enum-member</code> - Set the first enum member as the default value for enum fiel...</li> <li><code>--shared-module-name</code> - Customize the name of the shared module for deduplicated mod...</li> <li><code>--skip-root-model</code> - Skip generation of root model when schema contains nested de...</li> <li><code>--snake-case-field</code> - Convert field names to snake_case format.</li> <li><code>--special-field-name-prefix</code> - Prefix to add to special field names (like reserved keywords...</li> <li><code>--strict-nullable</code> - Strictly handle nullable types in OpenAPI schemas.</li> <li><code>--strict-types</code> - Enable strict type validation for specified Python types.</li> <li><code>--strip-default-none</code> - Remove fields with None as default value from generated mode...</li> <li><code>--target-python-version</code> - Target Python version for generated code syntax and imports.</li> <li><code>--treat-dot-as-module</code> - Treat dots in schema names as module separators.</li> <li><code>--type-mappings</code> - Override default type mappings for schema formats.</li> <li><code>--union-mode</code> - Union mode for combining anyOf/oneOf schemas (smart or left_...</li> <li><code>--url</code> - Fetch schema from URL with custom HTTP headers.</li> <li><code>--use-annotated</code> - Test GraphQL annotated types with standard collections and u...</li> <li><code>--use-attribute-docstrings</code> - Generate field descriptions as attribute docstrings instead ...</li> <li><code>--use-decimal-for-multiple-of</code> - Generate Decimal types for fields with multipleOf constraint...</li> <li><code>--use-default</code> - Use default values from schema in generated models.</li> <li><code>--use-default-kwarg</code> - Use default= keyword argument instead of positional argument...</li> <li><code>--use-double-quotes</code> - Use double quotes for string literals in generated code.</li> <li><code>--use-enum-values-in-discriminator</code> - Use enum values in discriminator mappings for union types.</li> <li><code>--use-exact-imports</code> - Import exact types instead of modules.</li> <li><code>--use-field-description</code> - Include schema descriptions as Field docstrings.</li> <li><code>--use-frozen-field</code> - Generate frozen (immutable) field definitions for readOnly p...</li> <li><code>--use-generic-container-types</code> - Use typing.Dict/List instead of dict/list for container type...</li> <li><code>--use-inline-field-description</code> - Add field descriptions as inline comments.</li> <li><code>--use-non-positive-negative-number-constrained-types</code> - Use NonPositive/NonNegative types for number constraints.</li> <li><code>--use-one-literal-as-default</code> - Use single literal value as default when enum has only one o...</li> <li><code>--use-operation-id-as-name</code> - Use OpenAPI operationId as the generated function/class name...</li> <li><code>--use-pendulum</code> - Use pendulum types for date/time fields instead of datetime ...</li> <li><code>--use-schema-description</code> - Use schema description as class docstring.</li> <li><code>--use-serialize-as-any</code> - Wrap fields with subtypes in Pydantic's SerializeAsAny.</li> <li><code>--use-standard-collections</code> - Use built-in dict/list instead of typing.Dict/List.</li> <li><code>--use-subclass-enum</code> - Generate typed Enum subclasses for enums with specific field...</li> <li><code>--use-title-as-name</code> - Use schema title as the generated class name.</li> <li><code>--use-type-alias</code> - Use TypeAlias instead of root models for type definitions (e...</li> <li><code>--use-union-operator</code> - Test GraphQL annotated types with standard collections and u...</li> <li><code>--use-unique-items-as-set</code> - Generate set types for arrays with uniqueItems constraint.</li> <li><code>--validation</code> - Enable validation constraints (deprecated, use --field-const...</li> <li><code>--wrap-string-literal</code> - Wrap long string literals across multiple lines.</li> </ul>","path":["CLI Reference","Quick Reference"],"tags":[]},{"location":"cli-reference/template-customization/","level":1,"title":"Template Customization","text":"","path":["CLI Reference","Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#options","level":2,"title":"Options","text":"Option Description <code>--additional-imports</code> Add custom imports to generated output files. <code>--custom-file-header</code> Add custom header text to the generated file. <code>--custom-file-header-path</code> Add custom header content from file to generated code. <code>--custom-formatters</code> Apply custom Python code formatters to generated output. <code>--custom-formatters-kwargs</code> Pass custom arguments to custom formatters via JSON file. <code>--custom-template-dir</code> Use custom Jinja2 templates for model generation. <code>--disable-appending-item-suffix</code> Disable appending 'Item' suffix to array item types. <code>--disable-timestamp</code> Disable timestamp in generated file header for reproducible ... <code>--enable-version-header</code> Include tool version information in file header. <code>--extra-template-data</code> Pass custom template variables from JSON file for code gener... <code>--formatters</code> Specify code formatters to apply to generated output. <code>--treat-dot-as-module</code> Treat dots in schema names as module separators. <code>--use-double-quotes</code> Use double quotes for string literals in generated code. <code>--use-exact-imports</code> Import exact types instead of modules. <code>--wrap-string-literal</code> Wrap long string literals across multiple lines.","path":["CLI Reference","Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#additional-imports","level":2,"title":"<code>--additional-imports</code>","text":"<p>Add custom imports to generated output files.</p> <p>The <code>--additional-imports</code> flag allows you to specify custom imports as a comma-delimited list that will be added to the generated output file. This is useful when using custom types defined in external modules (e.g., \"datetime.datetime,datetime.date,mymodule.myclass.MyCustomPythonClass\").</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --additional-imports datetime.datetime,datetime.date,mymodule.myclass.MyCustomPythonClass # (1)!\n</code></pre> <ol> <li> <code>--additional-imports</code> - the option documented here</li> </ol> Input Schema <pre><code>scalar Date\n\n\"DateTime (ISO8601, example: 2020-01-01T10:11:12+00:00)\"\nscalar DateTime\n\nscalar MyCustomClass\n\ntype A {\n  a: Date!\n  b: DateTime!\n  c: MyCustomClass!\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  additional-imports.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom datetime import date, datetime\nfrom typing import Literal, Optional\n\nfrom mymodule.myclass import MyCustomPythonClass\nfrom pydantic import BaseModel, Field\nfrom typing_extensions import TypeAlias\n\nBoolean: TypeAlias = bool\n\"\"\"\nThe `Boolean` scalar type represents `true` or `false`.\n\"\"\"\n\n\nDate: TypeAlias = date\n\n\nDateTime: TypeAlias = datetime\n\"\"\"\nDateTime (ISO8601, example: 2020-01-01T10:11:12+00:00)\n\"\"\"\n\n\nMyCustomClass: TypeAlias = MyCustomPythonClass\n\n\nString: TypeAlias = str\n\"\"\"\nThe `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\n\"\"\"\n\n\nclass A(BaseModel):\n    a: Date\n    b: DateTime\n    c: MyCustomClass\n    typename__: Optional[Literal['A']] = Field('A', alias='__typename')\n</code></pre>","path":["CLI Reference","Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#custom-file-header","level":2,"title":"<code>--custom-file-header</code>","text":"<p>Add custom header text to the generated file.</p> <p>The <code>--custom-file-header</code> flag replaces the default \"generated by datamodel-codegen\" header with custom text. This is useful for adding copyright notices, license headers, or other metadata to generated files.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --custom-file-header \"# Copyright 2024 MyCompany\" # (1)!\n</code></pre> <ol> <li> <code>--custom-file-header</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Person\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"first-name\": {\n      \"type\": \"string\"\n    },\n    \"last-name\": {\n      \"type\": \"string\"\n    },\n    \"email_address\": {\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\"first-name\", \"last-name\"]\n}\n</code></pre> Output With OptionWithout Option <pre><code># Copyright 2024 MyCompany\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Person(BaseModel):\n    first_name: str = Field(..., alias='first-name')\n    last_name: str = Field(..., alias='last-name')\n    email_address: Optional[str] = None\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  no_alias.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Person(BaseModel):\n    first_name: str = Field(..., alias='first-name')\n    last_name: str = Field(..., alias='last-name')\n    email_address: Optional[str] = None\n</code></pre>","path":["CLI Reference","Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#custom-file-header-path","level":2,"title":"<code>--custom-file-header-path</code>","text":"<p>Add custom header content from file to generated code.</p> <p>The <code>--custom-file-header-path</code> flag allows you to specify a file containing custom header content (like copyright notices, linting directives, or module docstrings) to be inserted at the top of generated Python files.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --custom-file-header-path custom_file_header.txt # (1)!\n</code></pre> <ol> <li> <code>--custom-file-header-path</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: error result\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output <pre><code># multiline custom ;\n# header ;\n# file ;\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(BaseModel):\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#custom-formatters","level":2,"title":"<code>--custom-formatters</code>","text":"<p>Apply custom Python code formatters to generated output.</p> <p>The <code>--custom-formatters</code> flag allows you to specify custom Python functions that will be applied to format the generated code. The formatter is specified as a module path (e.g., \"mymodule.formatter_function\"). This is useful for adding custom comments, modifying code structure, or applying project-specific formatting rules beyond what black/isort provide.</p> <p>See Also</p> <p>For detailed explanation and examples, see Custom Code Formatters.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --custom-formatters tests.data.python.custom_formatters.add_comment # (1)!\n</code></pre> <ol> <li> <code>--custom-formatters</code> - the option documented here</li> </ol> Input Schema <pre><code>scalar Long\n\ntype A {\n  id: ID!\n  duration: Long!\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  custom-scalar-types.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\n# a comment\nfrom __future__ import annotations\n\nfrom typing import Literal, Optional\n\nfrom pydantic import BaseModel, Field\nfrom typing_extensions import TypeAlias\n\nBoolean: TypeAlias = bool\n\"\"\"\nThe `Boolean` scalar type represents `true` or `false`.\n\"\"\"\n\n\nID: TypeAlias = str\n\"\"\"\nThe `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `\"4\"`) or integer (such as `4`) input value will be accepted as an ID.\n\"\"\"\n\n\nLong: TypeAlias = str\n\n\nString: TypeAlias = str\n\"\"\"\nThe `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\n\"\"\"\n\n\nclass A(BaseModel):\n    duration: Long\n    id: ID\n    typename__: Optional[Literal['A']] = Field('A', alias='__typename')\n</code></pre>","path":["CLI Reference","Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#custom-formatters-kwargs","level":2,"title":"<code>--custom-formatters-kwargs</code>","text":"<p>Pass custom arguments to custom formatters via JSON file.</p> <p>The <code>--custom-formatters-kwargs</code> flag accepts a path to a JSON file containing custom configuration for custom formatters (used with --custom-formatters). The file should contain a JSON object mapping formatter names to their kwargs.</p> <p>Note: This option is primarily used with --custom-formatters to pass configuration to user-defined formatter modules.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --custom-formatters-kwargs formatter_kwargs.json # (1)!\n</code></pre> <ol> <li> <code>--custom-formatters-kwargs</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Pet\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"tag\": {\n      \"type\": \"string\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  pet_simple.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    id: Optional[int] = None\n    name: Optional[str] = None\n    tag: Optional[str] = None\n</code></pre>","path":["CLI Reference","Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#custom-template-dir","level":2,"title":"<code>--custom-template-dir</code>","text":"<p>Use custom Jinja2 templates for model generation.</p> <p>The <code>--custom-template-dir</code> option allows you to specify a directory containing custom Jinja2 templates to override the default templates used for generating data models. This enables full customization of the generated code structure and formatting. Use with <code>--extra-template-data</code> to pass additional data to the templates.</p> <p>See Also</p> <p>For detailed explanation and examples, see Custom Templates.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --custom-template-dir templates --extra-template-data openapi/extra_data.json # (1)!\n</code></pre> <ol> <li> <code>--custom-template-dir</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: error result\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 1985-10-26T08:21:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):  # 1 2, 1 2, this is just a pet\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(BaseModel):\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = None\n    apiVersionNumber: Optional[str] = None\n    apiUrl: Optional[AnyUrl] = None\n    apiDocumentationUrl: Optional[AnyUrl] = None\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#disable-appending-item-suffix","level":2,"title":"<code>--disable-appending-item-suffix</code>","text":"<p>Disable appending 'Item' suffix to array item types.</p> <p>The <code>--disable-appending-item-suffix</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --disable-appending-item-suffix --field-constraints # (1)!\n</code></pre> <ol> <li> <code>--disable-appending-item-suffix</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n            minimum: 0\n            maximum: 100\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          minimum: 0\n          maximum: 9223372036854775807\n        name:\n          type: string\n          maxLength: 256\n        tag:\n          type: string\n          maxLength: 64\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n      maxItems: 10\n      minItems: 1\n      uniqueItems: true\n    UID:\n      type: integer\n      minimum: 0\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n          - uid\n        properties:\n          id:\n            type: integer\n            format: int64\n            minimum: 0\n          name:\n            type: string\n            maxLength: 256\n          tag:\n            type: string\n            maxLength: 64\n          uid:\n            $ref: '#/components/schemas/UID'\n          phones:\n            type: array\n            items:\n              type: string\n              minLength: 3\n            maxItems: 10\n          fax:\n            type: array\n            items:\n              type: string\n              minLength: 3\n          height:\n            type:\n              - integer\n              - number\n            minimum: 1\n            maximum: 300\n          weight:\n            type:\n              - number\n              - integer\n            minimum: 1.0\n            maximum: 1000.0\n          age:\n            type: integer\n            minimum: 0.0\n            maximum: 200.0\n            exclusiveMinimum: true\n          rating:\n            type: number\n            minimum: 0\n            exclusiveMinimum: True\n            maximum: 5\n\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            minLength: 1\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  api_constrained.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional, Union\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int = Field(..., ge=0, le=9223372036854775807)\n    name: str = Field(..., max_length=256)\n    tag: Optional[str] = Field(None, max_length=64)\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet] = Field(..., max_items=10, min_items=1, unique_items=True)\n\n\nclass UID(BaseModel):\n    __root__: int = Field(..., ge=0)\n\n\nclass Phone(BaseModel):\n    __root__: str = Field(..., min_length=3)\n\n\nclass Fax(BaseModel):\n    __root__: str = Field(..., min_length=3)\n\n\nclass User(BaseModel):\n    id: int = Field(..., ge=0)\n    name: str = Field(..., max_length=256)\n    tag: Optional[str] = Field(None, max_length=64)\n    uid: UID\n    phones: Optional[List[Phone]] = Field(None, max_items=10)\n    fax: Optional[List[Fax]] = None\n    height: Optional[Union[int, float]] = Field(None, ge=1.0, le=300.0)\n    weight: Optional[Union[float, int]] = Field(None, ge=1.0, le=1000.0)\n    age: Optional[int] = Field(None, gt=0, le=200)\n    rating: Optional[float] = Field(None, gt=0.0, le=5.0)\n\n\nclass Users(BaseModel):\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#disable-timestamp","level":2,"title":"<code>--disable-timestamp</code>","text":"<p>Disable timestamp in generated file header for reproducible output.</p> <p>The <code>--disable-timestamp</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --disable-timestamp # (1)!\n</code></pre> <ol> <li> <code>--disable-timestamp</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Info\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"hostName\": {\n      \"type\": \"string\",\n      \"format\": \"hostname\"\n    },\n    \"arn\": {\n      \"type\": \"string\",\n      \"pattern\": \"(^arn:([^:]*):([^:]*):([^:]*):(|\\\\*|[\\\\d]{12}):(.+)$)|^\\\\*$\"\n    },\n    \"tel\": {\n      \"type\": \"string\",\n      \"pattern\": \"^(\\\\([0-9]{3}\\\\))?[0-9]{3}-[0-9]{4}$\"\n    },\n    \"comment\": {\n        \"type\": \"string\",\n        \"pattern\": \"[^\\b\\f\\n\\r\\t\\\\\\\\a+.?'\\\"|()]+$\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  pattern.json\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, constr\n\n\nclass Info(BaseModel):\n    hostName: Optional[\n        constr(\n            regex=r'^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]{0,61}[A-Za-z0-9])\\Z'\n        )\n    ] = None\n    arn: Optional[\n        constr(regex=r'(^arn:([^:]*):([^:]*):([^:]*):(|\\*|[\\d]{12}):(.+)$)|^\\*$')\n    ] = None\n    tel: Optional[constr(regex=r'^(\\([0-9]{3}\\))?[0-9]{3}-[0-9]{4}$')] = None\n    comment: Optional[constr(regex=r'[^\\b\\f\\n\\r\\t\\\\a+.?\\'\"|()]+$')] = None\n</code></pre>","path":["CLI Reference","Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#enable-version-header","level":2,"title":"<code>--enable-version-header</code>","text":"<p>Include tool version information in file header.</p> <p>The <code>--enable-version-header</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --enable-version-header # (1)!\n</code></pre> <ol> <li> <code>--enable-version-header</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: error result\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n#   version:   0.0.0\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(BaseModel):\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#extra-template-data","level":2,"title":"<code>--extra-template-data</code>","text":"<p>Pass custom template variables from JSON file for code generation.</p> <p>The <code>--extra-template-data</code> flag allows you to provide additional variables (from a JSON file) that can be used in custom templates to configure generated model settings like Config classes, enabling customization beyond standard options.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --extra-template-data openapi/extra_data.json # (1)!\n</code></pre> <ol> <li> <code>--extra-template-data</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: error result\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output Pydantic v1Pydantic v2 <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 1985-10-26T08:21:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):  # 1 2, 1 2, this is just a pet\n    class Config:\n        arbitrary_types_allowed = True\n\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(BaseModel):\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 1985-10-26T08:21:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, ConfigDict, Field, RootModel\n\n\nclass Pet(BaseModel):  # 1 2, 1 2, this is just a pet\n    model_config = ConfigDict(\n        arbitrary_types_allowed=True,\n        coerce_numbers_to_str=True,\n    )\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(RootModel[List[Pet]]):\n    root: List[Pet]\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(RootModel[List[User]]):\n    root: List[User]\n\n\nclass Id(RootModel[str]):\n    root: str\n\n\nclass Rules(RootModel[List[str]]):\n    root: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(RootModel[List[Api]]):\n    root: List[Api]\n\n\nclass Event(BaseModel):\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#formatters","level":2,"title":"<code>--formatters</code>","text":"<p>Specify code formatters to apply to generated output.</p> <p>The <code>--formatters</code> flag specifies which code formatters to apply to the generated Python code. Available formatters are: black, isort, ruff, yapf, autopep8, autoflake. Default is [black, isort]. Use this to customize formatting or disable formatters entirely.</p> <p>See Also</p> <p>For built-in formatting configuration, see Formatting.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --formatters isort # (1)!\n</code></pre> <ol> <li> <code>--formatters</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Pet\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"tag\": {\n      \"type\": \"string\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  pet_simple.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    id: Optional[int] = None\n    name: Optional[str] = None\n    tag: Optional[str] = None\n</code></pre>","path":["CLI Reference","Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#treat-dot-as-module","level":2,"title":"<code>--treat-dot-as-module</code>","text":"<p>Treat dots in schema names as module separators.</p> <p>The <code>--treat-dot-as-module</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --treat-dot-as-module # (1)!\n</code></pre> <ol> <li> <code>--treat-dot-as-module</code> - the option documented here</li> </ol> Input Schema <pre><code># model.schema.json\n{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"User\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"age\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\"name\"]\n}\n</code></pre> Output <pre><code># __init__.py\n# generated by datamodel-codegen:\n#   filename:  treat_dot_as_module_single\n#   timestamp: 2019-07-26T00:00:00+00:00\n\n# model/__init__.py\n# generated by datamodel-codegen:\n#   filename:  treat_dot_as_module_single\n#   timestamp: 2019-07-26T00:00:00+00:00\n\n# model/schema.py\n# generated by datamodel-codegen:\n#   filename:  model.schema.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    name: str\n    age: Optional[int] = None\n</code></pre>","path":["CLI Reference","Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#use-double-quotes","level":2,"title":"<code>--use-double-quotes</code>","text":"<p>Use double quotes for string literals in generated code.</p> <p>The --use-double-quotes option formats all string literals in the generated Python code with double quotes instead of the default single quotes. This helps maintain consistency with codebases that prefer double-quote formatting.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-double-quotes # (1)!\n</code></pre> <ol> <li> <code>--use-double-quotes</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$id\": \"https://example.com/schemas/MapState.json\",\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"MapState\",\n  \"allOf\": [\n    {\n      \"anyOf\": [\n        {\n          \"type\": \"object\",\n          \"properties\": {\n            \"latitude\": {\"type\": \"number\", \"minimum\": -90, \"maximum\": 90},\n            \"longitude\": {\"type\": \"number\", \"minimum\": -180, \"maximum\": 180},\n            \"zoom\": {\"type\": \"number\", \"minimum\": 0, \"maximum\": 25, \"default\": 0},\n            \"bearing\": {\"type\": \"number\"},\n            \"pitch\": {\"type\": \"number\", \"minimum\": 0, \"exclusiveMaximum\": 90},\n            \"dragRotate\": {\"type\": \"boolean\"},\n            \"mapSplitMode\": {\"type\": \"string\", \"const\": \"SINGLE_MAP\"},\n            \"isSplit\": {\"type\": \"boolean\", \"const\": false, \"default\": false}\n          },\n          \"required\": [\"latitude\", \"longitude\", \"pitch\", \"mapSplitMode\"]\n        },\n        {\n          \"type\": \"object\",\n          \"properties\": {\n            \"latitude\": {\"$ref\": \"#/allOf/0/anyOf/0/properties/latitude\"},\n            \"longitude\": {\"$ref\": \"#/allOf/0/anyOf/0/properties/longitude\"},\n            \"zoom\": {\"$ref\": \"#/allOf/0/anyOf/0/properties/zoom\"},\n            \"bearing\": {\"$ref\": \"#/allOf/0/anyOf/0/properties/bearing\"},\n            \"pitch\": {\"$ref\": \"#/allOf/0/anyOf/0/properties/pitch\"},\n            \"dragRotate\": {\"$ref\": \"#/allOf/0/anyOf/0/properties/dragRotate\"},\n            \"mapSplitMode\": {\"type\": \"string\", \"const\": \"SWIPE_COMPARE\"},\n            \"isSplit\": {\"type\": \"boolean\", \"const\": true, \"default\": true}\n          },\n          \"required\": [\"latitude\", \"longitude\", \"pitch\", \"mapSplitMode\"]\n        }\n      ]\n    },\n    {\n      \"anyOf\": [\n        {\n          \"type\": \"object\",\n          \"properties\": {\n            \"mapViewMode\": {\"type\": \"string\", \"const\": \"MODE_2D\"}\n          },\n          \"required\": [\"mapViewMode\"]\n        },\n        {\n          \"type\": \"object\",\n          \"properties\": {\n            \"mapViewMode\": {\"type\": \"string\", \"const\": \"MODE_3D\"}\n          },\n          \"required\": [\"mapViewMode\"]\n        }\n      ]\n    }\n  ]\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  all_of_any_of_base_class_ref.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional, Union\n\nfrom pydantic import BaseModel, Field, confloat\n\n\nclass MapState1(BaseModel):\n    map_view_mode: str = Field(\"MODE_2D\", alias=\"mapViewMode\", const=True)\n\n\nclass MapState2(BaseModel):\n    latitude: Latitude\n    longitude: Longitude\n    zoom: Optional[Zoom] = Field(default_factory=lambda: Zoom.parse_obj(0))\n    bearing: Optional[Bearing] = None\n    pitch: Pitch\n    drag_rotate: Optional[DragRotate] = Field(None, alias=\"dragRotate\")\n    map_split_mode: str = Field(\"SWIPE_COMPARE\", alias=\"mapSplitMode\", const=True)\n    is_split: bool = Field(True, alias=\"isSplit\", const=True)\n\n\nclass MapState3(BaseModel):\n    pass\n\n\nclass MapState4(MapState1, MapState3):\n    pass\n\n\nclass MapState5(MapState2, MapState3):\n    pass\n\n\nclass MapState6(MapState4):\n    pass\n\n\nclass MapState7(MapState5):\n    pass\n\n\nclass MapState(BaseModel):\n    __root__: Union[MapState4, MapState5, MapState6, MapState7] = Field(\n        ..., title=\"MapState\"\n    )\n\n\nclass Bearing(BaseModel):\n    __root__: float\n\n\nclass DragRotate(BaseModel):\n    __root__: bool\n\n\nclass Latitude(BaseModel):\n    __root__: confloat(ge=-90.0, le=90.0)\n\n\nclass Longitude(BaseModel):\n    __root__: confloat(ge=-180.0, le=180.0)\n\n\nclass Pitch(BaseModel):\n    __root__: confloat(ge=0.0, lt=90.0)\n\n\nclass Zoom(BaseModel):\n    __root__: confloat(ge=0.0, le=25.0)\n</code></pre>","path":["CLI Reference","Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#use-exact-imports","level":2,"title":"<code>--use-exact-imports</code>","text":"<p>Import exact types instead of modules.</p> <p>The <code>--use-exact-imports</code> flag changes import style from module imports to exact type imports. For example, instead of <code>from . import foo</code> then <code>foo.Bar</code>, it generates <code>from .foo import Bar</code>. This can make the generated code more explicit and easier to read.</p> <p>Note: This option primarily affects modular output where imports between modules are generated. For single-file output, the difference is minimal.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-exact-imports # (1)!\n</code></pre> <ol> <li> <code>--use-exact-imports</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Pet\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"tag\": {\n      \"type\": \"string\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  pet_simple.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    id: Optional[int] = None\n    name: Optional[str] = None\n    tag: Optional[str] = None\n</code></pre>","path":["CLI Reference","Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#wrap-string-literal","level":2,"title":"<code>--wrap-string-literal</code>","text":"<p>Wrap long string literals across multiple lines.</p> <p>The <code>--wrap-string-literal</code> flag breaks long string literals (like descriptions) across multiple lines for better readability, instead of having very long single-line strings in the generated code.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --wrap-string-literal # (1)!\n</code></pre> <ol> <li> <code>--wrap-string-literal</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"LongDescription\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"summary\": {\n      \"type\": \"string\",\n      \"description\": \"summary for object\"\n    },\n    \"description\": {\n      \"type\": \"string\",\n      \"description\": \"datamodel-code-generator. This code generator creates pydantic model from an openapi file and others.\"\n    },\n    \"multi_line\": {\n      \"description\": \"datamodel-code-generator\\nThis code generator creates pydantic model from an openapi file and others.\\n\\n\\nSupported source types\\nOpenAPI 3 (YAML/JSON, OpenAPI Data Type)\\nJSON Schema (JSON Schema Core/JSON Schema Validation)\\nJSON/YAML/CSV Data (it will be converted to JSON Schema)\\nPython dictionary (it will be converted to JSON Schema)\",\n      \"type\": \"string\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  long_description.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass LongDescription(BaseModel):\n    summary: Optional[str] = Field(None, description='summary for object')\n    description: Optional[str] = Field(\n        None,\n        description=(\n            'datamodel-code-generator. This code generator creates pydantic model from'\n            ' an openapi file and others.'\n        ),\n    )\n    multi_line: Optional[str] = Field(\n        None,\n        description=(\n            'datamodel-code-generator\\nThis code generator creates pydantic model from'\n            ' an openapi file and others.\\n\\n\\nSupported source types\\nOpenAPI 3'\n            ' (YAML/JSON, OpenAPI Data Type)\\nJSON Schema (JSON Schema Core/JSON Schema'\n            ' Validation)\\nJSON/YAML/CSV Data (it will be converted to JSON'\n            ' Schema)\\nPython dictionary (it will be converted to JSON Schema)'\n        ),\n    )\n</code></pre>","path":["CLI Reference","Template Customization"],"tags":[]},{"location":"cli-reference/typing-customization/","level":1,"title":"Typing Customization","text":"","path":["CLI Reference","Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#options","level":2,"title":"Options","text":"Option Description <code>--allof-merge-mode</code> Merge constraints from root model references in allOf schema... <code>--disable-future-imports</code> Prevent automatic addition of future imports in generate... <code>--enum-field-as-literal</code> Convert all enum fields to Literal types instead of Enum cla... <code>--no-use-specialized-enum</code> Disable specialized Enum classes for Python 3.11+ code gener... <code>--output-datetime-class</code> Specify datetime class type for date-time schema fields. <code>--strict-types</code> Enable strict type validation for specified Python types. <code>--type-mappings</code> Override default type mappings for schema formats. <code>--use-annotated</code> Test GraphQL annotated types with standard collections and u... <code>--use-decimal-for-multiple-of</code> Generate Decimal types for fields with multipleOf constraint... <code>--use-generic-container-types</code> Use typing.Dict/List instead of dict/list for container type... <code>--use-non-positive-negative-number-constrained-types</code> Use NonPositive/NonNegative types for number constraints. <code>--use-pendulum</code> Use pendulum types for date/time fields instead of datetime ... <code>--use-standard-collections</code> Use built-in dict/list instead of typing.Dict/List. <code>--use-type-alias</code> Use TypeAlias instead of root models for type definitions (e... <code>--use-union-operator</code> Test GraphQL annotated types with standard collections and u... <code>--use-unique-items-as-set</code> Generate set types for arrays with uniqueItems constraint.","path":["CLI Reference","Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#allof-merge-mode","level":2,"title":"<code>--allof-merge-mode</code>","text":"<p>Merge constraints from root model references in allOf schemas.</p> <p>The <code>--allof-merge-mode constraints</code> merges only constraint properties (minLength, maximum, etc.) from parent schemas referenced in allOf. This ensures child schemas inherit validation constraints while keeping other properties separate.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --allof-merge-mode constraints # (1)!\n</code></pre> <ol> <li> <code>--allof-merge-mode</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"definitions\": {\n    \"StringDatatype\": {\n      \"description\": \"A base string type.\",\n      \"type\": \"string\",\n      \"pattern\": \"^\\\\S(.*\\\\S)?$\"\n    },\n    \"ConstrainedStringDatatype\": {\n      \"description\": \"A constrained string.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/StringDatatype\" },\n        { \"type\": \"string\", \"minLength\": 1, \"pattern\": \"^[A-Z].*\" }\n      ]\n    },\n    \"IntegerDatatype\": {\n      \"description\": \"A whole number.\",\n      \"type\": \"integer\"\n    },\n    \"NonNegativeIntegerDatatype\": {\n      \"description\": \"Non-negative integer.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/IntegerDatatype\" },\n        { \"minimum\": 0 }\n      ]\n    },\n    \"BoundedIntegerDatatype\": {\n      \"description\": \"Integer between 0 and 100.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/IntegerDatatype\" },\n        { \"minimum\": 0, \"maximum\": 100 }\n      ]\n    },\n    \"EmailDatatype\": {\n      \"description\": \"Email with format.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/StringDatatype\" },\n        { \"format\": \"email\" }\n      ]\n    },\n    \"FormattedStringDatatype\": {\n      \"description\": \"A string with email format.\",\n      \"type\": \"string\",\n      \"format\": \"email\"\n    },\n    \"ObjectBase\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"id\": { \"type\": \"integer\" }\n      }\n    },\n    \"ObjectWithAllOf\": {\n      \"description\": \"Object inheritance - not a root model.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/ObjectBase\" },\n        { \"type\": \"object\", \"properties\": { \"name\": { \"type\": \"string\" } } }\n      ]\n    },\n    \"MultiRefAllOf\": {\n      \"description\": \"Multiple refs - not handled by new code.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/StringDatatype\" },\n        { \"$ref\": \"#/definitions/IntegerDatatype\" }\n      ]\n    },\n    \"NoConstraintAllOf\": {\n      \"description\": \"No constraints added.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/StringDatatype\" }\n      ]\n    },\n    \"IncompatibleTypeAllOf\": {\n      \"description\": \"Incompatible types.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/StringDatatype\" },\n        { \"type\": \"boolean\" }\n      ]\n    },\n    \"ConstraintWithProperties\": {\n      \"description\": \"Constraint item has properties.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/StringDatatype\" },\n        { \"properties\": { \"extra\": { \"type\": \"string\" } } }\n      ]\n    },\n    \"ConstraintWithItems\": {\n      \"description\": \"Constraint item has items.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/StringDatatype\" },\n        { \"items\": { \"type\": \"string\" } }\n      ]\n    },\n    \"NumberIntegerCompatible\": {\n      \"description\": \"Number and integer are compatible.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/IntegerDatatype\" },\n        { \"type\": \"number\", \"minimum\": 0 }\n      ]\n    },\n    \"RefWithSchemaKeywords\": {\n      \"description\": \"Ref with additional schema keywords.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/StringDatatype\", \"minLength\": 5 },\n        { \"maxLength\": 100 }\n      ]\n    },\n    \"ArrayDatatype\": {\n      \"type\": \"array\",\n      \"items\": { \"type\": \"string\" }\n    },\n    \"RefToArrayAllOf\": {\n      \"description\": \"Ref to array - not a root model.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/ArrayDatatype\" },\n        { \"minItems\": 1 }\n      ]\n    },\n    \"ObjectNoPropsDatatype\": {\n      \"type\": \"object\"\n    },\n    \"RefToObjectNoPropsAllOf\": {\n      \"description\": \"Ref to object without properties - not a root model.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/ObjectNoPropsDatatype\" },\n        { \"minProperties\": 1 }\n      ]\n    },\n    \"PatternPropsDatatype\": {\n      \"patternProperties\": {\n        \"^S_\": { \"type\": \"string\" }\n      }\n    },\n    \"RefToPatternPropsAllOf\": {\n      \"description\": \"Ref to patternProperties - not a root model.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/PatternPropsDatatype\" },\n        { \"minProperties\": 1 }\n      ]\n    },\n    \"NestedAllOfDatatype\": {\n      \"allOf\": [\n        { \"type\": \"string\" },\n        { \"minLength\": 1 }\n      ]\n    },\n    \"RefToNestedAllOfAllOf\": {\n      \"description\": \"Ref to nested allOf - not a root model.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/NestedAllOfDatatype\" },\n        { \"maxLength\": 100 }\n      ]\n    },\n    \"ConstraintsOnlyDatatype\": {\n      \"description\": \"Constraints only, no type.\",\n      \"minLength\": 1,\n      \"pattern\": \"^[A-Z]\"\n    },\n    \"RefToConstraintsOnlyAllOf\": {\n      \"description\": \"Ref to constraints-only schema.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/ConstraintsOnlyDatatype\" },\n        { \"maxLength\": 100 }\n      ]\n    },\n    \"NoDescriptionAllOf\": {\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/StringDatatype\" },\n        { \"minLength\": 5 }\n      ]\n    },\n    \"EmptyConstraintItemAllOf\": {\n      \"description\": \"AllOf with empty constraint item.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/StringDatatype\" },\n        {},\n        { \"maxLength\": 50 }\n      ]\n    },\n    \"ConflictingFormatAllOf\": {\n      \"description\": \"Conflicting formats - falls back to existing behavior.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/FormattedStringDatatype\" },\n        { \"format\": \"date-time\" }\n      ]\n    }\n  },\n  \"type\": \"object\",\n  \"properties\": {\n    \"name\": { \"$ref\": \"#/definitions/ConstrainedStringDatatype\" },\n    \"count\": { \"$ref\": \"#/definitions/NonNegativeIntegerDatatype\" },\n    \"percentage\": { \"$ref\": \"#/definitions/BoundedIntegerDatatype\" },\n    \"email\": { \"$ref\": \"#/definitions/EmailDatatype\" },\n    \"obj\": { \"$ref\": \"#/definitions/ObjectWithAllOf\" },\n    \"multi\": { \"$ref\": \"#/definitions/MultiRefAllOf\" },\n    \"noconstraint\": { \"$ref\": \"#/definitions/NoConstraintAllOf\" },\n    \"incompatible\": { \"$ref\": \"#/definitions/IncompatibleTypeAllOf\" },\n    \"withprops\": { \"$ref\": \"#/definitions/ConstraintWithProperties\" },\n    \"withitems\": { \"$ref\": \"#/definitions/ConstraintWithItems\" },\n    \"numint\": { \"$ref\": \"#/definitions/NumberIntegerCompatible\" },\n    \"refwithkw\": { \"$ref\": \"#/definitions/RefWithSchemaKeywords\" },\n    \"refarr\": { \"$ref\": \"#/definitions/RefToArrayAllOf\" },\n    \"refobjnoprops\": { \"$ref\": \"#/definitions/RefToObjectNoPropsAllOf\" },\n    \"refpatternprops\": { \"$ref\": \"#/definitions/RefToPatternPropsAllOf\" },\n    \"refnestedallof\": { \"$ref\": \"#/definitions/RefToNestedAllOfAllOf\" },\n    \"refconstraintsonly\": { \"$ref\": \"#/definitions/RefToConstraintsOnlyAllOf\" },\n    \"nodescription\": { \"$ref\": \"#/definitions/NoDescriptionAllOf\" },\n    \"emptyconstraint\": { \"$ref\": \"#/definitions/EmptyConstraintItemAllOf\" },\n    \"conflictingformat\": { \"$ref\": \"#/definitions/ConflictingFormatAllOf\" }\n  }\n}\n</code></pre> Output With OptionWithout Option <pre><code># generated by datamodel-codegen:\n#   filename:  allof_root_model_constraints.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Any, Dict, List, Optional\n\nfrom pydantic import BaseModel, EmailStr, Field, conint, constr\n\n\nclass StringDatatype(BaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$') = Field(\n        ..., description='A base string type.'\n    )\n\n\nclass ConstrainedStringDatatype(BaseModel):\n    __root__: constr(regex=r'(?=^\\S(.*\\S)?$)(?=^[A-Z].*)', min_length=1) = Field(\n        ..., description='A constrained string.'\n    )\n\n\nclass IntegerDatatype(BaseModel):\n    __root__: int = Field(..., description='A whole number.')\n\n\nclass NonNegativeIntegerDatatype(BaseModel):\n    __root__: conint(ge=0) = Field(..., description='Non-negative integer.')\n\n\nclass BoundedIntegerDatatype(BaseModel):\n    __root__: conint(ge=0, le=100) = Field(\n        ..., description='Integer between 0 and 100.'\n    )\n\n\nclass EmailDatatype(BaseModel):\n    __root__: EmailStr = Field(..., description='Email with format.')\n\n\nclass FormattedStringDatatype(BaseModel):\n    __root__: EmailStr = Field(..., description='A string with email format.')\n\n\nclass ObjectBase(BaseModel):\n    id: Optional[int] = None\n\n\nclass ObjectWithAllOf(ObjectBase):\n    name: Optional[str] = None\n\n\nclass MultiRefAllOf(BaseModel):\n    pass\n\n\nclass NoConstraintAllOf(BaseModel):\n    pass\n\n\nclass IncompatibleTypeAllOf(BaseModel):\n    pass\n\n\nclass ConstraintWithProperties(BaseModel):\n    extra: Optional[str] = None\n\n\nclass ConstraintWithItems(BaseModel):\n    pass\n\n\nclass NumberIntegerCompatible(BaseModel):\n    __root__: conint(ge=0) = Field(\n        ..., description='Number and integer are compatible.'\n    )\n\n\nclass RefWithSchemaKeywords(BaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$', min_length=5, max_length=100) = Field(\n        ..., description='Ref with additional schema keywords.'\n    )\n\n\nclass ArrayDatatype(BaseModel):\n    __root__: List[str]\n\n\nclass RefToArrayAllOf(BaseModel):\n    pass\n\n\nclass ObjectNoPropsDatatype(BaseModel):\n    pass\n\n\nclass RefToObjectNoPropsAllOf(ObjectNoPropsDatatype):\n    pass\n\n\nclass PatternPropsDatatype(BaseModel):\n    __root__: Dict[constr(regex=r'^S_'), str]\n\n\nclass RefToPatternPropsAllOf(BaseModel):\n    pass\n\n\nclass NestedAllOfDatatype(BaseModel):\n    pass\n\n\nclass RefToNestedAllOfAllOf(NestedAllOfDatatype):\n    pass\n\n\nclass ConstraintsOnlyDatatype(BaseModel):\n    __root__: Any = Field(..., description='Constraints only, no type.')\n\n\nclass RefToConstraintsOnlyAllOf(BaseModel):\n    __root__: Any = Field(..., description='Ref to constraints-only schema.')\n\n\nclass NoDescriptionAllOf(BaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$', min_length=5) = Field(\n        ..., description='A base string type.'\n    )\n\n\nclass EmptyConstraintItemAllOf(BaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$', max_length=50) = Field(\n        ..., description='AllOf with empty constraint item.'\n    )\n\n\nclass ConflictingFormatAllOf(BaseModel):\n    pass\n\n\nclass Model(BaseModel):\n    name: Optional[ConstrainedStringDatatype] = None\n    count: Optional[NonNegativeIntegerDatatype] = None\n    percentage: Optional[BoundedIntegerDatatype] = None\n    email: Optional[EmailDatatype] = None\n    obj: Optional[ObjectWithAllOf] = None\n    multi: Optional[MultiRefAllOf] = None\n    noconstraint: Optional[NoConstraintAllOf] = None\n    incompatible: Optional[IncompatibleTypeAllOf] = None\n    withprops: Optional[ConstraintWithProperties] = None\n    withitems: Optional[ConstraintWithItems] = None\n    numint: Optional[NumberIntegerCompatible] = None\n    refwithkw: Optional[RefWithSchemaKeywords] = None\n    refarr: Optional[RefToArrayAllOf] = None\n    refobjnoprops: Optional[RefToObjectNoPropsAllOf] = None\n    refpatternprops: Optional[RefToPatternPropsAllOf] = None\n    refnestedallof: Optional[RefToNestedAllOfAllOf] = None\n    refconstraintsonly: Optional[RefToConstraintsOnlyAllOf] = None\n    nodescription: Optional[NoDescriptionAllOf] = None\n    emptyconstraint: Optional[EmptyConstraintItemAllOf] = None\n    conflictingformat: Optional[ConflictingFormatAllOf] = None\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  allof_root_model_constraints.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Any, Dict, List, Optional\n\nfrom pydantic import BaseModel, EmailStr, Field, conint, constr\n\n\nclass StringDatatype(BaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$') = Field(\n        ..., description='A base string type.'\n    )\n\n\nclass ConstrainedStringDatatype(BaseModel):\n    __root__: constr(regex=r'^[A-Z].*', min_length=1) = Field(\n        ..., description='A constrained string.'\n    )\n\n\nclass IntegerDatatype(BaseModel):\n    __root__: int = Field(..., description='A whole number.')\n\n\nclass NonNegativeIntegerDatatype(BaseModel):\n    __root__: conint(ge=0) = Field(..., description='Non-negative integer.')\n\n\nclass BoundedIntegerDatatype(BaseModel):\n    __root__: conint(ge=0, le=100) = Field(\n        ..., description='Integer between 0 and 100.'\n    )\n\n\nclass EmailDatatype(BaseModel):\n    __root__: EmailStr = Field(..., description='Email with format.')\n\n\nclass FormattedStringDatatype(BaseModel):\n    __root__: EmailStr = Field(..., description='A string with email format.')\n\n\nclass ObjectBase(BaseModel):\n    id: Optional[int] = None\n\n\nclass ObjectWithAllOf(ObjectBase):\n    name: Optional[str] = None\n\n\nclass MultiRefAllOf(BaseModel):\n    pass\n\n\nclass NoConstraintAllOf(BaseModel):\n    pass\n\n\nclass IncompatibleTypeAllOf(BaseModel):\n    pass\n\n\nclass ConstraintWithProperties(BaseModel):\n    extra: Optional[str] = None\n\n\nclass ConstraintWithItems(BaseModel):\n    pass\n\n\nclass NumberIntegerCompatible(BaseModel):\n    __root__: conint(ge=0) = Field(\n        ..., description='Number and integer are compatible.'\n    )\n\n\nclass RefWithSchemaKeywords(BaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$', min_length=5, max_length=100) = Field(\n        ..., description='Ref with additional schema keywords.'\n    )\n\n\nclass ArrayDatatype(BaseModel):\n    __root__: List[str]\n\n\nclass RefToArrayAllOf(BaseModel):\n    pass\n\n\nclass ObjectNoPropsDatatype(BaseModel):\n    pass\n\n\nclass RefToObjectNoPropsAllOf(ObjectNoPropsDatatype):\n    pass\n\n\nclass PatternPropsDatatype(BaseModel):\n    __root__: Dict[constr(regex=r'^S_'), str]\n\n\nclass RefToPatternPropsAllOf(BaseModel):\n    pass\n\n\nclass NestedAllOfDatatype(BaseModel):\n    pass\n\n\nclass RefToNestedAllOfAllOf(NestedAllOfDatatype):\n    pass\n\n\nclass ConstraintsOnlyDatatype(BaseModel):\n    __root__: Any = Field(..., description='Constraints only, no type.')\n\n\nclass RefToConstraintsOnlyAllOf(BaseModel):\n    __root__: Any = Field(..., description='Ref to constraints-only schema.')\n\n\nclass NoDescriptionAllOf(BaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$', min_length=5) = Field(\n        ..., description='A base string type.'\n    )\n\n\nclass EmptyConstraintItemAllOf(BaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$', max_length=50) = Field(\n        ..., description='AllOf with empty constraint item.'\n    )\n\n\nclass ConflictingFormatAllOf(BaseModel):\n    pass\n\n\nclass Model(BaseModel):\n    name: Optional[ConstrainedStringDatatype] = None\n    count: Optional[NonNegativeIntegerDatatype] = None\n    percentage: Optional[BoundedIntegerDatatype] = None\n    email: Optional[EmailDatatype] = None\n    obj: Optional[ObjectWithAllOf] = None\n    multi: Optional[MultiRefAllOf] = None\n    noconstraint: Optional[NoConstraintAllOf] = None\n    incompatible: Optional[IncompatibleTypeAllOf] = None\n    withprops: Optional[ConstraintWithProperties] = None\n    withitems: Optional[ConstraintWithItems] = None\n    numint: Optional[NumberIntegerCompatible] = None\n    refwithkw: Optional[RefWithSchemaKeywords] = None\n    refarr: Optional[RefToArrayAllOf] = None\n    refobjnoprops: Optional[RefToObjectNoPropsAllOf] = None\n    refpatternprops: Optional[RefToPatternPropsAllOf] = None\n    refnestedallof: Optional[RefToNestedAllOfAllOf] = None\n    refconstraintsonly: Optional[RefToConstraintsOnlyAllOf] = None\n    nodescription: Optional[NoDescriptionAllOf] = None\n    emptyconstraint: Optional[EmptyConstraintItemAllOf] = None\n    conflictingformat: Optional[ConflictingFormatAllOf] = None\n</code></pre>","path":["CLI Reference","Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#disable-future-imports","level":2,"title":"<code>--disable-future-imports</code>","text":"<p>Prevent automatic addition of future imports in generated code.</p> <p>The --disable-future-imports option stops the generator from adding 'from future import annotations' to the output. This is useful when you need compatibility with tools or environments that don't support postponed evaluation of annotations (PEP 563).</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --disable-future-imports --target-python-version 3.10 # (1)!\n</code></pre> <ol> <li> <code>--disable-future-imports</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"DescriptionType\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"metadata\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/Metadata\"\n      }\n    }\n  },\n  \"definitions\": {\n    \"Metadata\": {\n      \"title\": \"Metadata\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"title\": {\n          \"type\": \"string\"\n        }\n      }\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  keep_model_order_field_references.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel\n\n\nclass Metadata(BaseModel):\n    title: Optional[str] = None\n\n\nclass DescriptionType(BaseModel):\n    metadata: Optional[List[Metadata]] = None\n</code></pre>","path":["CLI Reference","Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#enum-field-as-literal","level":2,"title":"<code>--enum-field-as-literal</code>","text":"<p>Convert all enum fields to Literal types instead of Enum classes.</p> <p>The <code>--enum-field-as-literal all</code> flag converts all enum types to Literal type annotations. This is useful when you want string literal types instead of Enum classes for all enumerations.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --enum-field-as-literal all # (1)!\n</code></pre> <ol> <li> <code>--enum-field-as-literal</code> - the option documented here</li> </ol> Input Schema <pre><code>\"Employee shift status\"\nenum EmployeeShiftStatus {\n  \"not on shift\"\n  NOT_ON_SHIFT\n  \"on shift\"\n  ON_SHIFT\n}\n\nenum Color {\n  RED\n  GREEN\n  BLUE\n}\n\nenum EnumWithOneField {\n    FIELD\n}\n</code></pre> Output With OptionWithout Option <pre><code># generated by datamodel-codegen:\n#   filename:  enums.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import BaseModel\nfrom typing_extensions import TypeAlias\n\nBoolean: TypeAlias = bool\n\"\"\"\nThe `Boolean` scalar type represents `true` or `false`.\n\"\"\"\n\n\nString: TypeAlias = str\n\"\"\"\nThe `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\n\"\"\"\n\n\nclass Color(BaseModel):\n    __root__: Literal['BLUE', 'GREEN', 'RED']\n\n\nclass EmployeeShiftStatus(BaseModel):\n    \"\"\"\n    Employee shift status\n    \"\"\"\n\n    __root__: Literal['NOT_ON_SHIFT', 'ON_SHIFT']\n\n\nclass EnumWithOneField(BaseModel):\n    __root__: Literal['FIELD']\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  enums.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\n\nfrom typing_extensions import TypeAlias\n\nBoolean: TypeAlias = bool\n\"\"\"\nThe `Boolean` scalar type represents `true` or `false`.\n\"\"\"\n\n\nString: TypeAlias = str\n\"\"\"\nThe `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\n\"\"\"\n\n\nclass Color(Enum):\n    BLUE = 'BLUE'\n    GREEN = 'GREEN'\n    RED = 'RED'\n\n\nclass EmployeeShiftStatus(Enum):\n    \"\"\"\n    Employee shift status\n    \"\"\"\n\n    NOT_ON_SHIFT = 'NOT_ON_SHIFT'\n    ON_SHIFT = 'ON_SHIFT'\n\n\nclass EnumWithOneField(Enum):\n    FIELD = 'FIELD'\n</code></pre>","path":["CLI Reference","Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#no-use-specialized-enum","level":2,"title":"<code>--no-use-specialized-enum</code>","text":"<p>Disable specialized Enum classes for Python 3.11+ code generation.</p> <p>The <code>--no-use-specialized-enum</code> flag prevents the generator from using specialized Enum classes (StrEnum, IntEnum) when generating code for Python 3.11+, falling back to standard Enum classes instead.</p> <p>Related: <code>--no-use-specialized-enum</code>, <code>--target-python-version</code></p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --target-python-version 3.11 --no-use-specialized-enum # (1)!\n</code></pre> <ol> <li> <code>--no-use-specialized-enum</code> - the option documented here</li> </ol> Input Schema <pre><code>\"Employee shift status\"\nenum EmployeeShiftStatus {\n  \"not on shift\"\n  NOT_ON_SHIFT\n  \"on shift\"\n  ON_SHIFT\n}\n\nenum Color {\n  RED\n  GREEN\n  BLUE\n}\n\nenum EnumWithOneField {\n    FIELD\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  enums.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import TypeAlias\n\nBoolean: TypeAlias = bool\n\"\"\"\nThe `Boolean` scalar type represents `true` or `false`.\n\"\"\"\n\n\nString: TypeAlias = str\n\"\"\"\nThe `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\n\"\"\"\n\n\nclass Color(Enum):\n    BLUE = 'BLUE'\n    GREEN = 'GREEN'\n    RED = 'RED'\n\n\nclass EmployeeShiftStatus(Enum):\n    \"\"\"\n    Employee shift status\n    \"\"\"\n\n    NOT_ON_SHIFT = 'NOT_ON_SHIFT'\n    ON_SHIFT = 'ON_SHIFT'\n\n\nclass EnumWithOneField(Enum):\n    FIELD = 'FIELD'\n</code></pre>","path":["CLI Reference","Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#output-datetime-class","level":2,"title":"<code>--output-datetime-class</code>","text":"<p>Specify datetime class type for date-time schema fields.</p> <p>The <code>--output-datetime-class</code> flag controls which datetime type to use for fields with date-time format. Options include 'AwareDatetime' for timezone-aware datetimes or 'datetime' for standard Python datetime objects.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --output-datetime-class AwareDatetime # (1)!\n</code></pre> <ol> <li> <code>--output-datetime-class</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ncomponents:\n  schemas:\n    InventoryItem:\n      required:\n#      - id\n#      - name\n      - releaseDate\n      type: object\n      properties:\n#        id:\n#          type: string\n#          format: uuid\n#          example: d290f1ee-6c54-4b01-90e6-d701748f0851\n#        name:\n#          type: string\n#          example: Widget Adapter\n        releaseDate:\n          type: string\n          format: date-time\n          example: 2016-08-29T09:12:33.001Z\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  datetime.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom pydantic import AwareDatetime, BaseModel, Field\n\n\nclass InventoryItem(BaseModel):\n    releaseDate: AwareDatetime = Field(..., examples=['2016-08-29T09:12:33.001Z'])\n</code></pre>","path":["CLI Reference","Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#strict-types","level":2,"title":"<code>--strict-types</code>","text":"<p>Enable strict type validation for specified Python types.</p> <p>The --strict-types option enforces stricter type checking by preventing implicit type coercion for the specified types (str, bytes, int, float, bool). This generates StrictStr, StrictBytes, StrictInt, StrictFloat, and StrictBool types in Pydantic models, ensuring values match exactly without automatic conversion.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --strict-types str bytes int float bool # (1)!\n</code></pre> <ol> <li> <code>--strict-types</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"User\",\n  \"type\": \"object\",\n  \"properties\": {\n        \"name\": {\n          \"type\": \"string\",\n          \"example\": \"ken\"\n        },\n        \"age\": {\n          \"type\": \"integer\"\n        },\n        \"salary\": {\n          \"type\": \"integer\",\n          \"minimum\": 0\n        },\n        \"debt\" : {\n          \"type\": \"integer\",\n          \"maximum\": 0\n        },\n        \"loan\" : {\n          \"type\": \"number\",\n          \"maximum\": 0\n        },\n        \"tel\": {\n          \"type\": \"string\",\n          \"pattern\": \"^(\\\\([0-9]{3}\\\\))?[0-9]{3}-[0-9]{4}$\"\n        },\n        \"height\": {\n          \"type\": \"number\",\n          \"minimum\": 0\n        },\n        \"weight\": {\n          \"type\": \"number\",\n          \"minimum\": 0\n        },\n        \"score\": {\n          \"type\": \"number\",\n          \"minimum\": 1e-08\n        },\n        \"active\": {\n          \"type\": \"boolean\"\n        },\n        \"photo\": {\n          \"type\": \"string\",\n          \"format\": \"binary\",\n          \"minLength\": 100\n        }\n      }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  strict_types.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import (\n    BaseModel,\n    Field,\n    StrictBool,\n    StrictBytes,\n    StrictInt,\n    StrictStr,\n    confloat,\n    conint,\n    constr,\n)\n\n\nclass User(BaseModel):\n    name: Optional[StrictStr] = Field(None, example='ken')\n    age: Optional[StrictInt] = None\n    salary: Optional[conint(ge=0, strict=True)] = None\n    debt: Optional[conint(le=0, strict=True)] = None\n    loan: Optional[confloat(le=0.0, strict=True)] = None\n    tel: Optional[\n        constr(regex=r'^(\\([0-9]{3}\\))?[0-9]{3}-[0-9]{4}$', strict=True)\n    ] = None\n    height: Optional[confloat(ge=0.0, strict=True)] = None\n    weight: Optional[confloat(ge=0.0, strict=True)] = None\n    score: Optional[confloat(ge=1e-08, strict=True)] = None\n    active: Optional[StrictBool] = None\n    photo: Optional[StrictBytes] = None\n</code></pre>","path":["CLI Reference","Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#type-mappings","level":2,"title":"<code>--type-mappings</code>","text":"<p>Override default type mappings for schema formats.</p> <p>The <code>--type-mappings</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --output-model-type pydantic_v2.BaseModel --type-mappings binary=string # (1)!\n</code></pre> <ol> <li> <code>--type-mappings</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"BlobModel\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"content\": {\n      \"type\": \"string\",\n      \"format\": \"binary\",\n      \"description\": \"Binary content that should be mapped to string\"\n    },\n    \"data\": {\n      \"type\": \"string\",\n      \"format\": \"byte\",\n      \"description\": \"Base64 encoded data\"\n    },\n    \"name\": {\n      \"type\": \"string\",\n      \"description\": \"Regular string field\"\n    }\n  },\n  \"required\": [\"content\", \"data\", \"name\"]\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  type_mappings.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom pydantic import Base64Str, BaseModel, Field\n\n\nclass BlobModel(BaseModel):\n    content: str = Field(\n        ..., description='Binary content that should be mapped to string'\n    )\n    data: Base64Str = Field(..., description='Base64 encoded data')\n    name: str = Field(..., description='Regular string field')\n</code></pre>","path":["CLI Reference","Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#use-annotated","level":2,"title":"<code>--use-annotated</code>","text":"<p>Test GraphQL annotated types with standard collections and union operator.</p> <p>Related: <code>--use-standard-collections</code></p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --output-model-type pydantic_v2.BaseModel --use-annotated --use-standard-collections --use-union-operator # (1)!\n</code></pre> <ol> <li> <code>--use-annotated</code> - the option documented here</li> </ol> Input Schema <pre><code>type A {\n    field: String!\n    optionalField: String\n    listField: [String!]!\n    listOptionalField: [String]!\n    optionalListField: [String!]\n    optionalListOptionalField: [String]\n    listListField:[[String!]!]!\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  annotated.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Annotated, Literal\n\nfrom pydantic import BaseModel, Field\nfrom typing_extensions import TypeAliasType\n\nBoolean = TypeAliasType(\"Boolean\", bool)\n\"\"\"\nThe `Boolean` scalar type represents `true` or `false`.\n\"\"\"\n\n\nString = TypeAliasType(\"String\", str)\n\"\"\"\nThe `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\n\"\"\"\n\n\nclass A(BaseModel):\n    field: String\n    listField: list[String]\n    listListField: list[list[String]]\n    listOptionalField: list[String | None]\n    optionalField: String | None = None\n    optionalListField: list[String] | None = None\n    optionalListOptionalField: list[String | None] | None = None\n    typename__: Annotated[Literal['A'] | None, Field(alias='__typename')] = 'A'\n</code></pre>","path":["CLI Reference","Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#use-decimal-for-multiple-of","level":2,"title":"<code>--use-decimal-for-multiple-of</code>","text":"<p>Generate Decimal types for fields with multipleOf constraint.</p> <p>The <code>--use-decimal-for-multiple-of</code> flag generates <code>condecimal</code> or <code>Decimal</code> types for numeric fields that have a <code>multipleOf</code> constraint. This ensures precise decimal arithmetic when validating values against the constraint.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-decimal-for-multiple-of # (1)!\n</code></pre> <ol> <li> <code>--use-decimal-for-multiple-of</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"type\": \"object\",\n  \"properties\": {\n    \"price\": {\n      \"type\": \"number\",\n      \"multipleOf\": 0.01,\n      \"minimum\": 0,\n      \"maximum\": 99999.99\n    },\n    \"quantity\": {\n      \"type\": \"number\",\n      \"multipleOf\": 0.1\n    },\n    \"rate\": {\n      \"type\": \"number\",\n      \"multipleOf\": 0.001,\n      \"exclusiveMinimum\": 0,\n      \"exclusiveMaximum\": 1\n    },\n    \"simple_float\": {\n      \"type\": \"number\",\n      \"minimum\": 0,\n      \"maximum\": 100\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  use_decimal_for_multiple_of.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, condecimal, confloat\n\n\nclass Model(BaseModel):\n    price: Optional[condecimal(ge=0, le=99999.99, multiple_of=0.01)] = None\n    quantity: Optional[condecimal(multiple_of=0.1)] = None\n    rate: Optional[condecimal(multiple_of=0.001, lt=1.0, gt=0.0)] = None\n    simple_float: Optional[confloat(ge=0.0, le=100.0)] = None\n</code></pre>","path":["CLI Reference","Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#use-generic-container-types","level":2,"title":"<code>--use-generic-container-types</code>","text":"<p>Use typing.Dict/List instead of dict/list for container types.</p> <p>The <code>--use-generic-container-types</code> flag generates typing module generic containers (Dict, List, etc.) instead of built-in types. This is useful for Python 3.8 compatibility or when explicit typing imports are preferred.</p> <p>Related: <code>--use-standard-collections</code></p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-generic-container-types # (1)!\n</code></pre> <ol> <li> <code>--use-generic-container-types</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"$id\": \"test.json\",\n  \"description\": \"test\",\n  \"type\": \"object\",\n  \"required\": [\n    \"test_id\",\n    \"test_ip\",\n    \"result\",\n    \"nested_object_result\",\n    \"nested_enum_result\"\n  ],\n  \"properties\": {\n    \"test_id\": {\n      \"type\": \"string\",\n      \"description\": \"test ID\"\n    },\n    \"test_ip\": {\n      \"type\": \"string\",\n      \"description\": \"test IP\"\n    },\n    \"result\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"type\": \"integer\"\n      }\n    },\n    \"nested_object_result\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"status\":{\n            \"type\": \"integer\"\n          }\n        },\n        \"required\": [\"status\"]\n      }\n    },\n    \"nested_enum_result\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"enum\": [\"red\", \"green\"]\n      }\n    },\n    \"all_of_result\" :{\n      \"type\" : \"object\",\n      \"additionalProperties\" :\n      {\n        \"allOf\" : [\n          { \"$ref\" : \"#/definitions/User\" },\n          { \"type\" : \"object\",\n            \"properties\": {\n              \"description\": {\"type\" : \"string\" }\n            }\n          }\n        ]\n      }\n    },\n    \"one_of_result\" :{\n      \"type\" : \"object\",\n      \"additionalProperties\" :\n      {\n        \"oneOf\" : [\n          { \"$ref\" : \"#/definitions/User\" },\n          { \"type\" : \"object\",\n            \"properties\": {\n              \"description\": {\"type\" : \"string\" }\n            }\n          }\n        ]\n      }\n    },\n    \"any_of_result\" :{\n      \"type\" : \"object\",\n      \"additionalProperties\" :\n      {\n        \"anyOf\" : [\n          { \"$ref\" : \"#/definitions/User\" },\n          { \"type\" : \"object\",\n            \"properties\": {\n              \"description\": {\"type\" : \"string\" }\n            }\n          }\n        ]\n      }\n    },\n    \"all_of_with_unknown_object\" :{\n      \"type\" : \"object\",\n      \"additionalProperties\" :\n      {\n        \"allOf\" : [\n          { \"$ref\" : \"#/definitions/User\" },\n          { \"description\": \"TODO\" }\n        ]\n      }\n    },\n    \"objectRef\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"$ref\": \"#/definitions/User\"\n      }\n    },\n    \"deepNestedObjectRef\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"type\": \"object\",\n        \"additionalProperties\": {\n          \"type\": \"object\",\n          \"additionalProperties\": {\n             \"$ref\": \"#/definitions/User\"\n          }\n        }\n      }\n    }\n  },\n  \"definitions\": {\n    \"User\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"type\": \"string\"\n        }\n      }\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  root_model_with_additional_properties.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Mapping, Optional, Union\n\nfrom pydantic import BaseModel, Field\n\n\nclass NestedObjectResult(BaseModel):\n    status: int\n\n\nclass NestedEnumResult(Enum):\n    red = 'red'\n    green = 'green'\n\n\nclass OneOfResult(BaseModel):\n    description: Optional[str] = None\n\n\nclass AnyOfResult(BaseModel):\n    description: Optional[str] = None\n\n\nclass User(BaseModel):\n    name: Optional[str] = None\n\n\nclass AllOfResult(User):\n    description: Optional[str] = None\n\n\nclass Model(BaseModel):\n    test_id: str = Field(..., description='test ID')\n    test_ip: str = Field(..., description='test IP')\n    result: Mapping[str, int]\n    nested_object_result: Mapping[str, NestedObjectResult]\n    nested_enum_result: Mapping[str, NestedEnumResult]\n    all_of_result: Optional[Mapping[str, AllOfResult]] = None\n    one_of_result: Optional[Mapping[str, Union[User, OneOfResult]]] = None\n    any_of_result: Optional[Mapping[str, Union[User, AnyOfResult]]] = None\n    all_of_with_unknown_object: Optional[Mapping[str, User]] = None\n    objectRef: Optional[Mapping[str, User]] = None\n    deepNestedObjectRef: Optional[Mapping[str, Mapping[str, Mapping[str, User]]]] = None\n</code></pre>","path":["CLI Reference","Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#use-non-positive-negative-number-constrained-types","level":2,"title":"<code>--use-non-positive-negative-number-constrained-types</code>","text":"<p>Use NonPositive/NonNegative types for number constraints.</p> <p>The <code>--use-non-positive-negative-number-constrained-types</code> flag generates Pydantic's NonPositiveInt, NonNegativeInt, NonPositiveFloat, and NonNegativeFloat types for fields with minimum: 0 or maximum: 0 constraints, instead of using conint/confloat with ge/le parameters.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-non-positive-negative-number-constrained-types # (1)!\n</code></pre> <ol> <li> <code>--use-non-positive-negative-number-constrained-types</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"NumberConstraints\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"non_negative_count\": {\n      \"type\": \"integer\",\n      \"minimum\": 0,\n      \"description\": \"A count that cannot be negative\"\n    },\n    \"non_positive_balance\": {\n      \"type\": \"integer\",\n      \"maximum\": 0,\n      \"description\": \"A balance that cannot be positive\"\n    },\n    \"non_negative_amount\": {\n      \"type\": \"number\",\n      \"minimum\": 0,\n      \"description\": \"An amount that cannot be negative\"\n    },\n    \"non_positive_score\": {\n      \"type\": \"number\",\n      \"maximum\": 0,\n      \"description\": \"A score that cannot be positive\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  use_non_positive_negative.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import (\n    BaseModel,\n    Field,\n    NonNegativeFloat,\n    NonNegativeInt,\n    NonPositiveFloat,\n    NonPositiveInt,\n)\n\n\nclass NumberConstraints(BaseModel):\n    non_negative_count: Optional[NonNegativeInt] = Field(\n        None, description='A count that cannot be negative'\n    )\n    non_positive_balance: Optional[NonPositiveInt] = Field(\n        None, description='A balance that cannot be positive'\n    )\n    non_negative_amount: Optional[NonNegativeFloat] = Field(\n        None, description='An amount that cannot be negative'\n    )\n    non_positive_score: Optional[NonPositiveFloat] = Field(\n        None, description='A score that cannot be positive'\n    )\n</code></pre>","path":["CLI Reference","Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#use-pendulum","level":2,"title":"<code>--use-pendulum</code>","text":"<p>Use pendulum types for date/time fields instead of datetime module.</p> <p>The <code>--use-pendulum</code> flag generates pendulum library types (DateTime, Date, Time, Duration) instead of standard datetime types. This is useful when working with the pendulum library for enhanced timezone and date handling.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-pendulum # (1)!\n</code></pre> <ol> <li> <code>--use-pendulum</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Event\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"event_date\": {\n      \"type\": \"string\",\n      \"format\": \"date\"\n    },\n    \"duration\": {\n      \"type\": \"string\",\n      \"format\": \"duration\"\n    }\n  },\n  \"required\": [\"name\", \"created_at\"]\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  use_pendulum.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pendulum import Date, DateTime, Duration\nfrom pydantic import BaseModel\n\n\nclass Event(BaseModel):\n    name: str\n    created_at: DateTime\n    event_date: Optional[Date] = None\n    duration: Optional[Duration] = None\n</code></pre>","path":["CLI Reference","Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#use-standard-collections","level":2,"title":"<code>--use-standard-collections</code>","text":"<p>Use built-in dict/list instead of typing.Dict/List.</p> <p>The <code>--use-standard-collections</code> flag generates built-in container types (dict, list) instead of typing module equivalents. This produces cleaner code for Python 3.9+ where built-in types support subscripting.</p> <p>Related: <code>--use-generic-container-types</code></p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-standard-collections # (1)!\n</code></pre> <ol> <li> <code>--use-standard-collections</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"$id\": \"test.json\",\n  \"description\": \"test\",\n  \"type\": \"object\",\n  \"required\": [\n    \"test_id\",\n    \"test_ip\",\n    \"result\",\n    \"nested_object_result\",\n    \"nested_enum_result\"\n  ],\n  \"properties\": {\n    \"test_id\": {\n      \"type\": \"string\",\n      \"description\": \"test ID\"\n    },\n    \"test_ip\": {\n      \"type\": \"string\",\n      \"description\": \"test IP\"\n    },\n    \"result\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"type\": \"integer\"\n      }\n    },\n    \"nested_object_result\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"status\":{\n            \"type\": \"integer\"\n          }\n        },\n        \"required\": [\"status\"]\n      }\n    },\n    \"nested_enum_result\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"enum\": [\"red\", \"green\"]\n      }\n    },\n    \"all_of_result\" :{\n      \"type\" : \"object\",\n      \"additionalProperties\" :\n      {\n        \"allOf\" : [\n          { \"$ref\" : \"#/definitions/User\" },\n          { \"type\" : \"object\",\n            \"properties\": {\n              \"description\": {\"type\" : \"string\" }\n            }\n          }\n        ]\n      }\n    },\n    \"one_of_result\" :{\n      \"type\" : \"object\",\n      \"additionalProperties\" :\n      {\n        \"oneOf\" : [\n          { \"$ref\" : \"#/definitions/User\" },\n          { \"type\" : \"object\",\n            \"properties\": {\n              \"description\": {\"type\" : \"string\" }\n            }\n          }\n        ]\n      }\n    },\n    \"any_of_result\" :{\n      \"type\" : \"object\",\n      \"additionalProperties\" :\n      {\n        \"anyOf\" : [\n          { \"$ref\" : \"#/definitions/User\" },\n          { \"type\" : \"object\",\n            \"properties\": {\n              \"description\": {\"type\" : \"string\" }\n            }\n          }\n        ]\n      }\n    },\n    \"all_of_with_unknown_object\" :{\n      \"type\" : \"object\",\n      \"additionalProperties\" :\n      {\n        \"allOf\" : [\n          { \"$ref\" : \"#/definitions/User\" },\n          { \"description\": \"TODO\" }\n        ]\n      }\n    },\n    \"objectRef\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"$ref\": \"#/definitions/User\"\n      }\n    },\n    \"deepNestedObjectRef\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"type\": \"object\",\n        \"additionalProperties\": {\n          \"type\": \"object\",\n          \"additionalProperties\": {\n             \"$ref\": \"#/definitions/User\"\n          }\n        }\n      }\n    }\n  },\n  \"definitions\": {\n    \"User\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"type\": \"string\"\n        }\n      }\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  root_model_with_additional_properties.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Optional, Union\n\nfrom pydantic import BaseModel, Field\n\n\nclass NestedObjectResult(BaseModel):\n    status: int\n\n\nclass NestedEnumResult(Enum):\n    red = 'red'\n    green = 'green'\n\n\nclass OneOfResult(BaseModel):\n    description: Optional[str] = None\n\n\nclass AnyOfResult(BaseModel):\n    description: Optional[str] = None\n\n\nclass User(BaseModel):\n    name: Optional[str] = None\n\n\nclass AllOfResult(User):\n    description: Optional[str] = None\n\n\nclass Model(BaseModel):\n    test_id: str = Field(..., description='test ID')\n    test_ip: str = Field(..., description='test IP')\n    result: dict[str, int]\n    nested_object_result: dict[str, NestedObjectResult]\n    nested_enum_result: dict[str, NestedEnumResult]\n    all_of_result: Optional[dict[str, AllOfResult]] = None\n    one_of_result: Optional[dict[str, Union[User, OneOfResult]]] = None\n    any_of_result: Optional[dict[str, Union[User, AnyOfResult]]] = None\n    all_of_with_unknown_object: Optional[dict[str, User]] = None\n    objectRef: Optional[dict[str, User]] = None\n    deepNestedObjectRef: Optional[dict[str, dict[str, dict[str, User]]]] = None\n</code></pre>","path":["CLI Reference","Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#use-type-alias","level":2,"title":"<code>--use-type-alias</code>","text":"<p>Use TypeAlias instead of root models for type definitions (experimental).</p> <p>The <code>--use-type-alias</code> flag generates TypeAlias declarations instead of root model classes for certain type definitions. For Python 3.9-3.11, it generates TypeAliasType, and for Python 3.12+, it uses the 'type' statement syntax. This feature is experimental.</p> <p>Related: <code>--target-python-version</code></p> <p>See Also</p> <p>For detailed explanation and examples, see Root Models and Type Aliases.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-type-alias # (1)!\n</code></pre> <ol> <li> <code>--use-type-alias</code> - the option documented here</li> </ol> Input Schema <pre><code>scalar SimpleString\n\ntype Person {\n  name: String!\n  age: Int!\n}\n\ntype Pet {\n  name: String!\n  type: String!\n}\n\nunion UnionType = Person | Pet\n\ntype ModelWithTypeAliasField {\n  simple_field: SimpleString\n  union_field: UnionType\n  string_field: String\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  type_alias.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Literal, Optional, Union\n\nfrom pydantic import BaseModel, Field\nfrom typing_extensions import TypeAlias\n\nBoolean: TypeAlias = bool\n\"\"\"\nThe `Boolean` scalar type represents `true` or `false`.\n\"\"\"\n\n\nInt: TypeAlias = int\n\"\"\"\nThe `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\n\"\"\"\n\n\nSimpleString: TypeAlias = str\n\n\nString: TypeAlias = str\n\"\"\"\nThe `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\n\"\"\"\n\n\nclass Person(BaseModel):\n    age: Int\n    name: String\n    typename__: Optional[Literal['Person']] = Field('Person', alias='__typename')\n\n\nclass Pet(BaseModel):\n    name: String\n    type: String\n    typename__: Optional[Literal['Pet']] = Field('Pet', alias='__typename')\n\n\nUnionType: TypeAlias = Union[\n    'Person',\n    'Pet',\n]\n\n\nclass ModelWithTypeAliasField(BaseModel):\n    simple_field: Optional[SimpleString] = None\n    string_field: Optional[String] = None\n    union_field: Optional[UnionType] = None\n    typename__: Optional[Literal['ModelWithTypeAliasField']] = Field(\n        'ModelWithTypeAliasField', alias='__typename'\n    )\n</code></pre>","path":["CLI Reference","Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#use-union-operator","level":2,"title":"<code>--use-union-operator</code>","text":"<p>Test GraphQL annotated types with standard collections and union operator.</p> <p>Related: <code>--use-standard-collections</code></p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --output-model-type pydantic_v2.BaseModel --use-annotated --use-standard-collections --use-union-operator # (1)!\n</code></pre> <ol> <li> <code>--use-union-operator</code> - the option documented here</li> </ol> Input Schema <pre><code>type A {\n    field: String!\n    optionalField: String\n    listField: [String!]!\n    listOptionalField: [String]!\n    optionalListField: [String!]\n    optionalListOptionalField: [String]\n    listListField:[[String!]!]!\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  annotated.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Annotated, Literal\n\nfrom pydantic import BaseModel, Field\nfrom typing_extensions import TypeAliasType\n\nBoolean = TypeAliasType(\"Boolean\", bool)\n\"\"\"\nThe `Boolean` scalar type represents `true` or `false`.\n\"\"\"\n\n\nString = TypeAliasType(\"String\", str)\n\"\"\"\nThe `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\n\"\"\"\n\n\nclass A(BaseModel):\n    field: String\n    listField: list[String]\n    listListField: list[list[String]]\n    listOptionalField: list[String | None]\n    optionalField: String | None = None\n    optionalListField: list[String] | None = None\n    optionalListOptionalField: list[String | None] | None = None\n    typename__: Annotated[Literal['A'] | None, Field(alias='__typename')] = 'A'\n</code></pre>","path":["CLI Reference","Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#use-unique-items-as-set","level":2,"title":"<code>--use-unique-items-as-set</code>","text":"<p>Generate set types for arrays with uniqueItems constraint.</p> <p>The <code>--use-unique-items-as-set</code> flag generates Python set types instead of list types for JSON Schema arrays that have the uniqueItems constraint set to true, enforcing uniqueness at the type level.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-unique-items-as-set --field-constraints # (1)!\n</code></pre> <ol> <li> <code>--use-unique-items-as-set</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n            minimum: 0\n            maximum: 100\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          minimum: 0\n          maximum: 9223372036854775807\n        name:\n          type: string\n          maxLength: 256\n        tag:\n          type: string\n          maxLength: 64\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n      maxItems: 10\n      minItems: 1\n      uniqueItems: true\n    UID:\n      type: integer\n      minimum: 0\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n          - uid\n        properties:\n          id:\n            type: integer\n            format: int64\n            minimum: 0\n          name:\n            type: string\n            maxLength: 256\n          tag:\n            type: string\n            maxLength: 64\n          uid:\n            $ref: '#/components/schemas/UID'\n          phones:\n            type: array\n            items:\n              type: string\n              minLength: 3\n            maxItems: 10\n          fax:\n            type: array\n            items:\n              type: string\n              minLength: 3\n          height:\n            type:\n              - integer\n              - number\n            minimum: 1\n            maximum: 300\n          weight:\n            type:\n              - number\n              - integer\n            minimum: 1.0\n            maximum: 1000.0\n          age:\n            type: integer\n            minimum: 0.0\n            maximum: 200.0\n            exclusiveMinimum: true\n          rating:\n            type: number\n            minimum: 0\n            exclusiveMinimum: True\n            maximum: 5\n\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            minLength: 1\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  api_constrained.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional, Set, Union\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int = Field(..., ge=0, le=9223372036854775807)\n    name: str = Field(..., max_length=256)\n    tag: Optional[str] = Field(None, max_length=64)\n\n\nclass Pets(BaseModel):\n    __root__: Set[Pet] = Field(..., max_items=10, min_items=1, unique_items=True)\n\n\nclass UID(BaseModel):\n    __root__: int = Field(..., ge=0)\n\n\nclass Phone(BaseModel):\n    __root__: str = Field(..., min_length=3)\n\n\nclass FaxItem(BaseModel):\n    __root__: str = Field(..., min_length=3)\n\n\nclass User(BaseModel):\n    id: int = Field(..., ge=0)\n    name: str = Field(..., max_length=256)\n    tag: Optional[str] = Field(None, max_length=64)\n    uid: UID\n    phones: Optional[List[Phone]] = Field(None, max_items=10)\n    fax: Optional[List[FaxItem]] = None\n    height: Optional[Union[int, float]] = Field(None, ge=1.0, le=300.0)\n    weight: Optional[Union[float, int]] = Field(None, ge=1.0, le=1000.0)\n    age: Optional[int] = Field(None, gt=0, le=200)\n    rating: Optional[float] = Field(None, gt=0.0, le=5.0)\n\n\nclass Users(BaseModel):\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","Typing Customization"],"tags":[]}]}