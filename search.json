{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"datamodel-code-generator","text":"<p>üöÄ Generate Python data models from schema definitions in seconds.</p> <p> </p>","path":["datamodel-code-generator"],"tags":[]},{"location":"#what-it-does","level":2,"title":"‚ú® What it does","text":"<ul> <li>üìÑ Converts OpenAPI 3, JSON Schema, GraphQL, and raw data (JSON/YAML/CSV) into Python models</li> <li>üéØ Generates Pydantic v1/v2, dataclasses, TypedDict, or msgspec output</li> <li>üîó Handles complex schemas: <code>$ref</code>, <code>allOf</code>, <code>oneOf</code>, <code>anyOf</code>, enums, and nested types</li> <li>‚úÖ Produces type-safe, validated code ready for your IDE and type checker</li> </ul>","path":["datamodel-code-generator"],"tags":[]},{"location":"#installation","level":2,"title":"üì¶ Installation","text":"pipuvcondapipx (global)uvx (global) <pre><code>pip install datamodel-code-generator\n</code></pre> <pre><code>uv add datamodel-code-generator\n</code></pre> <pre><code>conda install -c conda-forge datamodel-code-generator\n</code></pre> <pre><code>pipx install datamodel-code-generator\n</code></pre> <pre><code>uvx datamodel-codegen --help\n</code></pre>","path":["datamodel-code-generator"],"tags":[]},{"location":"#quick-start","level":2,"title":"üèÉ Quick Start","text":"","path":["datamodel-code-generator"],"tags":[]},{"location":"#1-create-a-schema-file","level":3,"title":"1Ô∏è‚É£ Create a schema file","text":"pet.json<pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Pet\",\n  \"type\": \"object\",\n  \"required\": [\"name\", \"species\"],\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\",\n      \"description\": \"The pet's name\"\n    },\n    \"species\": {\n      \"type\": \"string\",\n      \"enum\": [\"dog\", \"cat\", \"bird\", \"fish\"]\n    },\n    \"age\": {\n      \"type\": \"integer\",\n      \"minimum\": 0,\n      \"description\": \"Age in years\"\n    },\n    \"vaccinated\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    }\n  }\n}\n</code></pre>","path":["datamodel-code-generator"],"tags":[]},{"location":"#2-run-the-generator","level":3,"title":"2Ô∏è‚É£ Run the generator","text":"<pre><code>datamodel-codegen --input pet.json --input-file-type jsonschema --output-model-type pydantic_v2.BaseModel --output model.py\n</code></pre>","path":["datamodel-code-generator"],"tags":[]},{"location":"#3-use-your-models","level":3,"title":"3Ô∏è‚É£ Use your models","text":"model.py<pre><code># generated by datamodel-codegen:\n#   filename:  tutorial_pet.json\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Species(Enum):\n    dog = 'dog'\n    cat = 'cat'\n    bird = 'bird'\n    fish = 'fish'\n\n\nclass Pet(BaseModel):\n    name: str = Field(..., description=\"The pet's name\")\n    species: Species\n    age: Optional[int] = Field(None, description='Age in years', ge=0)\n    vaccinated: Optional[bool] = False\n</code></pre> <p>üéâ That's it! Your schema is now a fully-typed Python model.</p>","path":["datamodel-code-generator"],"tags":[]},{"location":"#choose-your-input","level":2,"title":"üì• Choose Your Input","text":"Input Type File Types Example üìò OpenAPI 3 <code>.yaml</code>, <code>.json</code> API specifications üìã JSON Schema <code>.json</code> Data validation schemas üî∑ GraphQL <code>.graphql</code> GraphQL type definitions üìä JSON/YAML Data <code>.json</code>, <code>.yaml</code> Infer schema from data","path":["datamodel-code-generator"],"tags":[]},{"location":"#choose-your-output","level":2,"title":"üì§ Choose Your Output","text":"<pre><code># üÜï Pydantic v2 (recommended for new projects)\ndatamodel-codegen --output-model-type pydantic_v2.BaseModel ...\n\n# üîÑ Pydantic v1 (default, for compatibility)\ndatamodel-codegen --output-model-type pydantic.BaseModel ...\n\n# üèóÔ∏è Python dataclasses\ndatamodel-codegen --output-model-type dataclasses.dataclass ...\n\n# üìù TypedDict (for type hints without validation)\ndatamodel-codegen --output-model-type typing.TypedDict ...\n\n# ‚ö° msgspec (high-performance serialization)\ndatamodel-codegen --output-model-type msgspec.Struct ...\n</code></pre> <p>See Supported Data Types for the full list.</p>","path":["datamodel-code-generator"],"tags":[]},{"location":"#common-recipes","level":2,"title":"üç≥ Common Recipes","text":"","path":["datamodel-code-generator"],"tags":[]},{"location":"#http-extra-option","level":3,"title":"üåê Generate from URL","text":"<pre><code>pip install 'datamodel-code-generator[http]'\ndatamodel-codegen --url https://example.com/api/openapi.yaml --output model.py\n</code></pre>","path":["datamodel-code-generator"],"tags":[]},{"location":"#use-with-pyprojecttoml","level":3,"title":"‚öôÔ∏è Use with pyproject.toml","text":"pyproject.toml<pre><code>[tool.datamodel-codegen]\ninput = \"schema.yaml\"\noutput = \"src/models.py\"\noutput-model-type = \"pydantic_v2.BaseModel\"\nsnake-case-field = true\n</code></pre> <p>Then simply run:</p> <pre><code>datamodel-codegen\n</code></pre> <p>See pyproject.toml Configuration for more options.</p>","path":["datamodel-code-generator"],"tags":[]},{"location":"#snake-case-field-names","level":3,"title":"üêç Snake-case field names","text":"<pre><code>datamodel-codegen --snake-case-field --input schema.json --output model.py\n</code></pre>","path":["datamodel-code-generator"],"tags":[]},{"location":"#cicd-integration","level":3,"title":"üîÑ CI/CD Integration","text":"<p>Verify generated code stays in sync with schemas using <code>--check</code>:</p> <pre><code>datamodel-codegen --input schema.yaml --output models.py --disable-timestamp --check\n</code></pre> <p>See CI/CD Integration for GitHub Actions and more.</p>","path":["datamodel-code-generator"],"tags":[]},{"location":"#next-steps","level":2,"title":"üìö Next Steps","text":"<ul> <li>üñ•Ô∏è CLI Reference - All command-line options with examples</li> <li>‚öôÔ∏è pyproject.toml Configuration - Configure via pyproject.toml</li> <li>üöÄ One-liner Usage - uvx, pipx, clipboard integration</li> <li>üîÑ CI/CD Integration - GitHub Actions and CI validation</li> <li>üé® Custom Templates - Customize generated code with Jinja2</li> <li>üñåÔ∏è Code Formatting - Configure black, isort, and ruff</li> <li>‚ùì FAQ - Common questions and troubleshooting</li> </ul>","path":["datamodel-code-generator"],"tags":[]},{"location":"#sponsors","level":2,"title":"üíñ Sponsors","text":"<p>Astral</p>","path":["datamodel-code-generator"],"tags":[]},{"location":"#used-by","level":2,"title":"üè¢ Used by","text":"<p>These projects use datamodel-code-generator. See the linked examples for real-world usage.</p> <ul> <li>PostHog/posthog - Generate models via npm run</li> <li>airbytehq/airbyte - Generate Python, Java/Kotlin, and Typescript protocol models</li> <li>apache/iceberg - Generate Python code</li> <li>open-metadata/OpenMetadata - datamodel_generation.py</li> <li>awslabs/aws-lambda-powertools-python - Recommended for advanced-use-cases</li> <li>Netflix/consoleme - Generate models from Swagger</li> <li>DataDog/integrations-core - Config models</li> <li>argoproj-labs/hera - Makefile</li> <li>SeldonIO/MLServer - generate-types.sh</li> <li>geojupyter/jupytergis - Python type generation from JSONSchema</li> <li>Nike-Inc/brickflow - Code generate tools</li> <li>cloudcoil/cloudcoil - Model generation</li> <li>IBM/compliance-trestle - Building models from OSCAL schemas</li> <li>hashintel/hash - codegen.sh</li> </ul> <p>See all dependents ‚Üí</p>","path":["datamodel-code-generator"],"tags":[]},{"location":"aliases/","level":1,"title":"üè∑Ô∏è Field Aliases","text":"","path":["Usage","Output Customization","üè∑Ô∏è Field Aliases"],"tags":[]},{"location":"aliases/#field-aliases","level":1,"title":"üè∑Ô∏è Field Aliases","text":"<p>The <code>--aliases</code> option allows you to rename fields in the generated models. This is useful when you want to use different Python field names than those defined in the schema while preserving the original names as serialization aliases.</p>","path":["Usage","Output Customization","üè∑Ô∏è Field Aliases"],"tags":[]},{"location":"aliases/#basic-usage","level":2,"title":"üöÄ Basic Usage","text":"<pre><code>datamodel-codegen --input schema.json --output model.py --aliases aliases.json\n</code></pre>","path":["Usage","Output Customization","üè∑Ô∏è Field Aliases"],"tags":[]},{"location":"aliases/#alias-file-format","level":2,"title":"üìã Alias File Format","text":"<p>The alias file is a JSON file that maps original field names to their Python aliases.</p>","path":["Usage","Output Customization","üè∑Ô∏è Field Aliases"],"tags":[]},{"location":"aliases/#flat-format-traditional","level":3,"title":"üìù Flat Format (Traditional)","text":"<p>The simplest format applies aliases to all fields with the matching name, regardless of which class they belong to:</p> <pre><code>{\n  \"id\": \"id_\",\n  \"type\": \"type_\",\n  \"class\": \"class_\"\n}\n</code></pre> <p>This will rename all fields named <code>id</code> to <code>id_</code>, all fields named <code>type</code> to <code>type_</code>, etc.</p>","path":["Usage","Output Customization","üè∑Ô∏è Field Aliases"],"tags":[]},{"location":"aliases/#scoped-format-class-specific","level":3,"title":"üéØ Scoped Format (Class-Specific)","text":"<p>When you have the same field name in multiple classes but want different aliases for each, use the scoped format with <code>ClassName.field</code>:</p> <pre><code>{\n  \"User.name\": \"user_name\",\n  \"Address.name\": \"address_name\",\n  \"name\": \"default_name\"\n}\n</code></pre> <p>‚ö° Priority: Scoped aliases take priority over flat aliases. In the example above:</p> <ul> <li><code>User.name</code> will be renamed to <code>user_name</code></li> <li><code>Address.name</code> will be renamed to <code>address_name</code></li> <li>Any other class with a <code>name</code> field will use <code>default_name</code></li> </ul>","path":["Usage","Output Customization","üè∑Ô∏è Field Aliases"],"tags":[]},{"location":"aliases/#example","level":2,"title":"üìù Example","text":"","path":["Usage","Output Customization","üè∑Ô∏è Field Aliases"],"tags":[]},{"location":"aliases/#input-schema","level":3,"title":"üì• Input Schema","text":"<pre><code>{\n  \"type\": \"object\",\n  \"title\": \"Root\",\n  \"properties\": {\n    \"name\": {\"type\": \"string\"},\n    \"user\": {\n      \"type\": \"object\",\n      \"title\": \"User\",\n      \"properties\": {\n        \"name\": {\"type\": \"string\"},\n        \"id\": {\"type\": \"integer\"}\n      }\n    },\n    \"address\": {\n      \"type\": \"object\",\n      \"title\": \"Address\",\n      \"properties\": {\n        \"name\": {\"type\": \"string\"},\n        \"city\": {\"type\": \"string\"}\n      }\n    }\n  }\n}\n</code></pre>","path":["Usage","Output Customization","üè∑Ô∏è Field Aliases"],"tags":[]},{"location":"aliases/#alias-file","level":3,"title":"üè∑Ô∏è Alias File","text":"<pre><code>{\n  \"Root.name\": \"root_name\",\n  \"User.name\": \"user_name\",\n  \"Address.name\": \"address_name\"\n}\n</code></pre>","path":["Usage","Output Customization","üè∑Ô∏è Field Aliases"],"tags":[]},{"location":"aliases/#generated-output","level":3,"title":"‚ú® Generated Output","text":"<pre><code>from pydantic import BaseModel, Field\n\nclass User(BaseModel):\n    user_name: str | None = Field(None, alias='name')\n    id: int | None = None\n\nclass Address(BaseModel):\n    address_name: str | None = Field(None, alias='name')\n    city: str | None = None\n\nclass Root(BaseModel):\n    root_name: str | None = Field(None, alias='name')\n    user: User | None = None\n    address: Address | None = None\n</code></pre>","path":["Usage","Output Customization","üè∑Ô∏è Field Aliases"],"tags":[]},{"location":"aliases/#notes","level":2,"title":"üìå Notes","text":"<ul> <li>The <code>ClassName</code> in scoped format must match the generated Python class name (after title conversion)</li> <li>When using <code>--use-title-as-name</code>, the class name is derived from the <code>title</code> property in the schema</li> <li>Aliases are applied during code generation, so the original field names are preserved as Pydantic <code>alias</code> values for proper serialization/deserialization</li> </ul>","path":["Usage","Output Customization","üè∑Ô∏è Field Aliases"],"tags":[]},{"location":"aliases/#see-also","level":2,"title":"üìñ See Also","text":"<ul> <li>üñ•Ô∏è CLI Reference: <code>--aliases</code> - Detailed CLI option documentation with examples</li> </ul>","path":["Usage","Output Customization","üè∑Ô∏è Field Aliases"],"tags":[]},{"location":"ci-cd/","level":1,"title":"CI/CD Integration","text":"","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#cicd-integration","level":1,"title":"CI/CD Integration","text":"<p>This guide covers how to use datamodel-code-generator in CI/CD pipelines and development workflows to ensure generated code stays in sync with schemas.</p> <p>Note</p> <p>The package name is <code>datamodel-code-generator</code>, and the CLI command is <code>datamodel-codegen</code>.</p>","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#official-github-action","level":2,"title":"Official GitHub Action","text":"<p>The official GitHub Action provides a simple way to validate generated models in your CI pipeline.</p>","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#basic-usage","level":3,"title":"Basic Usage","text":"<pre><code>- uses: koxudaxi/datamodel-code-generator@0.44.0\n  with:\n    input: schema.yaml\n    output: src/models.py\n    input-file-type: openapi\n    output-model-type: pydantic_v2.BaseModel\n</code></pre> <p>By default, the action runs in check mode (<code>--check</code>), which validates that the existing output file matches what would be generated. If they differ, the action fails.</p>","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#inputs","level":3,"title":"Inputs","text":"Input Required Default Description <code>input</code> Yes - Input schema file or directory <code>output</code> Yes - Output file or directory <code>input-file-type</code> Yes - Input file type (<code>openapi</code>, <code>jsonschema</code>, <code>json</code>, <code>yaml</code>, <code>csv</code>, <code>graphql</code>) <code>output-model-type</code> Yes - Output model type (<code>pydantic_v2.BaseModel</code>, <code>pydantic.BaseModel</code>, <code>dataclasses.dataclass</code>, <code>typing.TypedDict</code>, <code>msgspec.Struct</code>) <code>check</code> No <code>true</code> Validate that existing output is up to date (no generation) <code>working-directory</code> No <code>.</code> Working directory (where <code>pyproject.toml</code> is located) <code>profile</code> No - Named profile from <code>pyproject.toml</code> <code>extra-args</code> No - Additional CLI arguments <code>version</code> No - Specific version to install (defaults to action's tag version) <code>extras</code> No - Optional extras to install (comma-separated: <code>graphql</code>, <code>http</code>, <code>validation</code>, <code>ruff</code>, <code>all</code>)","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#example-validate-on-pull-request","level":3,"title":"Example: Validate on Pull Request","text":".github/workflows/validate-models.yml<pre><code>name: Validate Generated Models\n\non:\n  pull_request:\n    paths:\n      - 'schemas/**'\n      - 'src/models/**'\n\njobs:\n  validate:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: koxudaxi/datamodel-code-generator@0.44.0\n        with:\n          input: schemas/api.yaml\n          output: src/models/api.py\n          input-file-type: openapi\n          output-model-type: pydantic_v2.BaseModel\n</code></pre>","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#example-monorepo-with-multiple-schemas","level":3,"title":"Example: Monorepo with Multiple Schemas","text":".github/workflows/validate-models.yml<pre><code>jobs:\n  validate:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        include:\n          - working-directory: packages/api\n            input: schemas/openapi.yaml\n            output: src/models.py\n            input-file-type: openapi\n          - working-directory: packages/admin\n            input: schemas/schema.json\n            output: src/models.py\n            input-file-type: jsonschema\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: koxudaxi/datamodel-code-generator@0.44.0\n        with:\n          input: ${{ matrix.input }}\n          output: ${{ matrix.output }}\n          input-file-type: ${{ matrix.input-file-type }}\n          output-model-type: pydantic_v2.BaseModel\n          working-directory: ${{ matrix.working-directory }}\n</code></pre>","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#example-using-profiles","level":3,"title":"Example: Using Profiles","text":"<pre><code>- uses: koxudaxi/datamodel-code-generator@0.44.0\n  with:\n    input: schemas/api.yaml\n    output: src/models.py\n    input-file-type: openapi\n    output-model-type: pydantic_v2.BaseModel\n    profile: api\n</code></pre>","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#example-generate-models-instead-of-validation","level":3,"title":"Example: Generate Models (Instead of Validation)","text":"<p>Set <code>check: 'false'</code> to actually generate the models:</p> <pre><code>- uses: koxudaxi/datamodel-code-generator@0.44.0\n  with:\n    input: schema.yaml\n    output: src/models.py\n    input-file-type: openapi\n    output-model-type: pydantic_v2.BaseModel\n    check: 'false'\n</code></pre>","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#example-graphql-schema","level":3,"title":"Example: GraphQL Schema","text":"<p>For GraphQL schemas, use the <code>extras</code> input to install the required dependency:</p> <pre><code>- uses: koxudaxi/datamodel-code-generator@0.44.0\n  with:\n    input: schema.graphql\n    output: src/models.py\n    input-file-type: graphql\n    output-model-type: pydantic_v2.BaseModel\n    extras: 'graphql'\n</code></pre>","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#example-multiple-extras","level":3,"title":"Example: Multiple Extras","text":"<p>You can install multiple extras with comma-separated values:</p> <pre><code>- uses: koxudaxi/datamodel-code-generator@0.44.0\n  with:\n    input: schema.yaml\n    output: src/models.py\n    input-file-type: openapi\n    output-model-type: pydantic_v2.BaseModel\n    extras: 'http,validation,ruff'\n</code></pre>","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#example-additional-cli-options","level":3,"title":"Example: Additional CLI Options","text":"<p>Use <code>extra-args</code> for CLI options not covered by the inputs:</p> <pre><code>- uses: koxudaxi/datamodel-code-generator@0.44.0\n  with:\n    input: schema.yaml\n    output: src/models.py\n    input-file-type: openapi\n    output-model-type: pydantic_v2.BaseModel\n    extra-args: '--snake-case-field --field-constraints'\n</code></pre> <p>Version Pinning</p> <p>Always pin the action to a specific version tag (e.g., <code>@0.44.0</code>) to ensure reproducible builds. The action installs the same version of <code>datamodel-code-generator</code> as the tag.</p>","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#the-check-flag","level":2,"title":"The <code>--check</code> Flag","text":"<p>The <code>--check</code> flag verifies that generated code matches existing files without modifying them. If the output would differ, it exits with a non-zero status code.</p> <pre><code>datamodel-codegen --check\n</code></pre>","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#success-exit-code-0","level":3,"title":"Success (Exit code 0)","text":"<p>When generated code matches the existing file, the command exits silently with code 0:</p> <pre><code>$ datamodel-codegen --check\n$ echo $?\n0\n</code></pre>","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#failure-exit-code-1","level":3,"title":"Failure (Exit code 1)","text":"<p>When the schema has changed and the generated code would differ, a unified diff is shown and the command exits with code 1:</p> <pre><code>$ datamodel-codegen --check\n--- models.py\n+++ models.py (expected)\n@@ -12,3 +12,4 @@\n     name: Optional[str] = None\n     age: Optional[int] = None\n     email: Optional[str] = None\n+    active: Optional[bool] = None\n$ echo $?\n1\n</code></pre> <p>Best Practice: Use pyproject.toml</p> <p>Instead of passing many CLI options, configure all settings in <code>pyproject.toml</code>. This keeps CI commands simple, ensures consistency between local development and CI, and makes configuration easier to maintain.</p> pyproject.toml<pre><code>[tool.datamodel-codegen]\ninput = \"schemas/api.yaml\"\noutput = \"src/models/api.py\"\noutput-model-type = \"pydantic_v2.BaseModel\"\ndisable-timestamp = true\n</code></pre> <p>Then simply run:</p> <pre><code>datamodel-codegen --check\n</code></pre> <p>For projects with multiple schemas, use named profiles to organize configurations by purpose.</p> <p>Related: <code>--check</code>, <code>--disable-timestamp</code>, pyproject.toml Configuration</p>","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#github-actions","level":2,"title":"GitHub Actions","text":"","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#basic-example","level":3,"title":"Basic Example","text":".github/workflows/ci.yml<pre><code>name: CI\n\non:\n  push:\n    branches: [main]\n  pull_request:\n\njobs:\n  check-generated-code:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v6\n        with:\n          python-version: \"3.14\"\n\n      - name: Install dependencies\n        run: pip install datamodel-code-generator\n\n      - name: Verify generated models are up-to-date\n        run: datamodel-codegen --check\n</code></pre>","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#using-profiles-for-multiple-schemas","level":3,"title":"Using Profiles for Multiple Schemas","text":"<p>For projects with multiple schemas, use named profiles to organize configurations by purpose:</p> pyproject.toml<pre><code>[tool.datamodel-codegen]\noutput-model-type = \"pydantic_v2.BaseModel\"\ndisable-timestamp = true\n\n[tool.datamodel-codegen.profiles.api]\ninput = \"schemas/openapi/api.yaml\"\noutput = \"src/models/api.py\"\n\n[tool.datamodel-codegen.profiles.events]\ninput = \"schemas/jsonschema/events.json\"\noutput = \"src/models/events.py\"\ninput-file-type = \"jsonschema\"\n</code></pre> .github/workflows/ci.yml<pre><code>- name: Verify API models are up-to-date\n  run: datamodel-codegen --profile api --check\n\n- name: Verify event models are up-to-date\n  run: datamodel-codegen --profile events --check\n</code></pre>","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#using-uv","level":3,"title":"Using uv","text":"<p>If your project uses uv, you can run the CLI via <code>uv run</code>. This example installs the tool ephemerally (no need to add it to your project dependencies):</p> .github/workflows/ci.yml<pre><code>- name: Install uv\n  uses: astral-sh/setup-uv@v4\n\n- name: Verify generated models are up-to-date\n  run: uv run --with datamodel-code-generator datamodel-codegen --profile api --check\n</code></pre>","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#pre-commit-hook","level":2,"title":"Pre-commit Hook","text":"<p>You can use datamodel-code-generator as a pre-commit hook to automatically check or regenerate models before commits.</p> <p>Tip</p> <p>Pin <code>rev</code> to a released tag (e.g., <code>vX.Y.Z</code>) to keep generated output stable and reproducible across developer machines and CI.</p>","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#with-pyprojecttoml-recommended","level":3,"title":"With pyproject.toml (Recommended)","text":"<p>Configure settings in <code>pyproject.toml</code> and use a simple pre-commit hook:</p> .pre-commit-config.yaml<pre><code>repos:\n  - repo: https://github.com/koxudaxi/datamodel-code-generator\n    rev: vX.Y.Z\n    hooks:\n      - id: datamodel-code-generator\n        args: [--check]\n        files: ^schemas/\n</code></pre>","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#with-profiles","level":3,"title":"With Profiles","text":"<p>For projects with multiple schemas using named profiles:</p> .pre-commit-config.yaml<pre><code>repos:\n  - repo: https://github.com/koxudaxi/datamodel-code-generator\n    rev: vX.Y.Z\n    hooks:\n      - id: datamodel-code-generator\n        name: Check API models\n        args: [--profile, api, --check]\n        files: ^schemas/openapi/\n      - id: datamodel-code-generator\n        name: Check event models\n        args: [--profile, events, --check]\n        files: ^schemas/jsonschema/\n</code></pre>","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#auto-regenerate-mode","level":3,"title":"Auto-regenerate Mode","text":"<p>This configuration automatically regenerates models when schema files change:</p> .pre-commit-config.yaml<pre><code>repos:\n  - repo: https://github.com/koxudaxi/datamodel-code-generator\n    rev: vX.Y.Z\n    hooks:\n      - id: datamodel-code-generator\n        files: ^schemas/\n</code></pre> <p>Installing the hook</p> <p>Ensure <code>pre-commit</code> is installed, then install the hooks:</p> <pre><code>pip install pre-commit\npre-commit install\n</code></pre>","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#gitlab-ci","level":2,"title":"GitLab CI","text":".gitlab-ci.yml<pre><code>check-generated-code:\n  image: python:3.14\n  script:\n    - pip install datamodel-code-generator\n    - datamodel-codegen --check\n  rules:\n    - changes:\n        - schemas/**/*\n        - src/models/**/*\n</code></pre>","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#makefile-integration","level":2,"title":"Makefile Integration","text":"<p>Add targets to your Makefile for easy generation and checking:</p> Makefile<pre><code>.PHONY: generate-models check-models\n\ngenerate-models:\n    datamodel-codegen\n\ncheck-models:\n    datamodel-codegen --check\n</code></pre> <p>Then use in CI:</p> .github/workflows/ci.yml<pre><code>- name: Check generated models\n  run: make check-models\n</code></pre> <p>For projects with multiple profiles:</p> Makefile<pre><code>.PHONY: generate-all check-all\n\ngenerate-all:\n    datamodel-codegen --profile api\n    datamodel-codegen --profile events\n\ncheck-all:\n    datamodel-codegen --profile api --check\n    datamodel-codegen --profile events --check\n</code></pre>","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#troubleshooting","level":2,"title":"Troubleshooting","text":"","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#check-fails-due-to-formatting-differences","level":3,"title":"Check fails due to formatting differences","text":"<p>Ensure you're using the same formatters in CI as locally. Configure formatters in <code>pyproject.toml</code>:</p> pyproject.toml<pre><code>[tool.datamodel-codegen]\nformatters = [\"ruff\"]\n</code></pre> <p>See Formatting for details.</p> <p>Related: <code>--formatters</code></p>","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#check-fails-due-to-timestamp","level":3,"title":"Check fails due to timestamp","text":"<p>Always use <code>disable-timestamp = true</code> in <code>pyproject.toml</code>:</p> pyproject.toml<pre><code>[tool.datamodel-codegen]\ndisable-timestamp = true\n</code></pre> <p>Related: <code>--disable-timestamp</code></p>","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"ci-cd/#different-python-versions-produce-different-output","level":3,"title":"Different Python versions produce different output","text":"<p>Some type annotations differ between Python versions. Pin the target version in <code>pyproject.toml</code> and ensure CI uses the same Python version as development:</p> pyproject.toml<pre><code>[tool.datamodel-codegen]\ntarget-python-version = \"3.14\"\n</code></pre> <p>Related: <code>--target-python-version</code></p>","path":["Usage","Integration","CI/CD Integration"],"tags":[]},{"location":"custom-formatters/","level":1,"title":"üé® Custom Code Formatters","text":"","path":["Usage","Templates and Formatting","üé® Custom Code Formatters"],"tags":[]},{"location":"custom-formatters/#custom-code-formatters","level":1,"title":"üé® Custom Code Formatters","text":"<p>Create your own custom code formatters for specialized formatting needs.</p>","path":["Usage","Templates and Formatting","üé® Custom Code Formatters"],"tags":[]},{"location":"custom-formatters/#usage","level":2,"title":"üöÄ Usage","text":"<p>Pass the module path containing your formatter class:</p> <pre><code>datamodel-codegen --input {your_input_file} --output {your_output_file} --custom-formatters \"{path_to_your_module}.your_module\"\n</code></pre>","path":["Usage","Templates and Formatting","üé® Custom Code Formatters"],"tags":[]},{"location":"custom-formatters/#example","level":2,"title":"üìù Example","text":"","path":["Usage","Templates and Formatting","üé® Custom Code Formatters"],"tags":[]},{"location":"custom-formatters/#1-create-your-formatter","level":3,"title":"1Ô∏è‚É£ Create your formatter","text":"","path":["Usage","Templates and Formatting","üé® Custom Code Formatters"],"tags":[]},{"location":"custom-formatters/#your_modulepy","level":3,"title":"your_module.py","text":"<pre><code>from datamodel_code_generator.format import CustomCodeFormatter\n\nclass CodeFormatter(CustomCodeFormatter):\n    def apply(self, code: str) -&gt; str:\n        # Apply your custom formatting here\n        # For example, add a custom header comment:\n        header = \"# This code was formatted by custom formatter\\n\"\n        return header + code\n</code></pre>","path":["Usage","Templates and Formatting","üé® Custom Code Formatters"],"tags":[]},{"location":"custom-formatters/#2-use-your-formatter","level":3,"title":"2Ô∏è‚É£ Use your formatter","text":"<pre><code>datamodel-codegen --input schema.json --output model.py --custom-formatters \"mypackage.your_module\"\n</code></pre>","path":["Usage","Templates and Formatting","üé® Custom Code Formatters"],"tags":[]},{"location":"custom-formatters/#passing-arguments","level":2,"title":"üîß Passing Arguments","text":"<p>You can pass keyword arguments to your custom formatter using <code>--custom-formatters-kwargs</code>:</p> <pre><code>datamodel-codegen --input schema.json --output model.py \\\n    --custom-formatters \"mypackage.your_module\" \\\n    --custom-formatters-kwargs '{\"line_length\": 100}'\n</code></pre>","path":["Usage","Templates and Formatting","üé® Custom Code Formatters"],"tags":[]},{"location":"custom-formatters/#see-also","level":2,"title":"üìñ See Also","text":"<ul> <li>üñ•Ô∏è CLI Reference: <code>--custom-formatters</code> - Detailed CLI option documentation</li> <li>üîß CLI Reference: <code>--custom-formatters-kwargs</code> - Pass arguments to custom formatters</li> <li>üñåÔ∏è Formatting - Built-in code formatting with black and isort</li> </ul>","path":["Usage","Templates and Formatting","üé® Custom Code Formatters"],"tags":[]},{"location":"custom_template/","level":1,"title":"üé® Custom Templates","text":"","path":["Usage","Templates and Formatting","üé® Custom Templates"],"tags":[]},{"location":"custom_template/#custom-templates","level":1,"title":"üé® Custom Templates","text":"<p>One of the powerful features of datamodel-code-generator is the ability to use custom templates with the <code>--custom-template-dir</code> option. This allows you to provide a directory containing Jinja2 templates for customizing the generated code.</p>","path":["Usage","Templates and Formatting","üé® Custom Templates"],"tags":[]},{"location":"custom_template/#usage","level":2,"title":"üöÄ Usage","text":"<p>Pass the directory path containing your custom templates:</p> <pre><code>datamodel-codegen --input {your_input_file} --output {your_output_file} --custom-template-dir {your_custom_template_directory}\n</code></pre>","path":["Usage","Templates and Formatting","üé® Custom Templates"],"tags":[]},{"location":"custom_template/#example","level":2,"title":"üìù Example","text":"<p>Let's say you want to generate a custom Python data model from a JSON Schema file called <code>person.json</code>. You want the generated data model to include a custom comment at the top of the file.</p>","path":["Usage","Templates and Formatting","üé® Custom Templates"],"tags":[]},{"location":"custom_template/#1-create-the-template-directory","level":3,"title":"1Ô∏è‚É£ Create the template directory","text":"<p>Create a directory structure matching the output model type:</p> <pre><code>custom_templates/\n‚îî‚îÄ‚îÄ pydantic/\n    ‚îî‚îÄ‚îÄ BaseModel.jinja2\n</code></pre>","path":["Usage","Templates and Formatting","üé® Custom Templates"],"tags":[]},{"location":"custom_template/#2-create-the-template","level":3,"title":"2Ô∏è‚É£ Create the template","text":"<p>custom_templates/pydantic/BaseModel.jinja2 <pre><code># This is a custom comment generated with custom_template!!\n\nclass {{ class_name }}({{ base_class }}):\n{%- for field in fields %}\n    {{ field.name }}: {{ field.type_hint }}\n{%- endfor -%}\n</code></pre></p> <p>This custom template includes the custom comment at the top and replicates the default rendering behavior of the <code>BaseModel.jinja2</code> template.</p>","path":["Usage","Templates and Formatting","üé® Custom Templates"],"tags":[]},{"location":"custom_template/#3-run-the-generator","level":3,"title":"3Ô∏è‚É£ Run the generator","text":"<pre><code>datamodel-codegen --input person.json --output person.py --custom-template-dir custom_templates\n</code></pre>","path":["Usage","Templates and Formatting","üé® Custom Templates"],"tags":[]},{"location":"custom_template/#generated-output","level":3,"title":"‚ú® Generated Output","text":"<p>person.py <pre><code># generated by datamodel-codegen:\n#   filename:  person.json\n#   timestamp: 2023-04-09T05:36:24+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n# This is a custom comment generated with custom_template!!\n\n\nclass Model(BaseModel):\n    name: Optional[str]\n    age: Optional[int]\n</code></pre></p>","path":["Usage","Templates and Formatting","üé® Custom Templates"],"tags":[]},{"location":"custom_template/#template-reference","level":2,"title":"üìö Template Reference","text":"<p>You can create more complex custom templates by copying the default templates. Use them as a reference for understanding the structure and available variables, and customize the code generation process according to your specific requirements.</p>","path":["Usage","Templates and Formatting","üé® Custom Templates"],"tags":[]},{"location":"custom_template/#see-also","level":2,"title":"üìñ See Also","text":"<ul> <li>üñ•Ô∏è CLI Reference: <code>--custom-template-dir</code> - Detailed CLI option documentation</li> <li>üìä CLI Reference: <code>--extra-template-data</code> - Pass custom variables to templates</li> </ul>","path":["Usage","Templates and Formatting","üé® Custom Templates"],"tags":[]},{"location":"development-contributing/","level":1,"title":"üõ†Ô∏è Development","text":"<p>Install the package in editable mode:</p> <pre><code>$ git clone git@github.com:koxudaxi/datamodel-code-generator.git\n$ pip install -e datamodel-code-generator\n</code></pre>","path":["üõ†Ô∏è Development"],"tags":[]},{"location":"development-contributing/#contribute","level":1,"title":"ü§ù Contribute","text":"<p>We are waiting for your contributions to <code>datamodel-code-generator</code>.</p>","path":["üõ†Ô∏è Development"],"tags":[]},{"location":"development-contributing/#how-to-contribute","level":2,"title":"üìù How to contribute","text":"<pre><code>## 1. Clone your fork repository\n$ git clone git@github.com:&lt;your username&gt;/datamodel-code-generator.git\n$ cd datamodel-code-generator\n\n## 2. Install [uv](https://docs.astral.sh/uv/getting-started/installation/)\n$ curl -LsSf https://astral.sh/uv/install.sh | sh\n\n## 3. Install tox with uv\n$ uv tool install --python-preference only-managed --python 3.13 tox --with tox-uv\n\n## 4. Create developer environment\n$ tox run -e dev\n\n.tox/dev is a Python environment you can use for development purposes\n\n## 5. Create new branch and rewrite code.\n$ git checkout -b new-branch\n\n## 6. Run unittest under Python 3.13 (you should pass all test and coverage should be 100%)\n$ tox run -e 3.13\n\n## 7. Format and lint code (will print errors that cannot be automatically fixed)\n$ tox run -e fix\n\n## 8. Check README help text is up to date\n$ tox run -e readme\n\n## 9. Check CLI documentation is up to date\n$ tox run -e cli-docs\n\n## 10. Commit and Push...\n</code></pre>","path":["üõ†Ô∏è Development"],"tags":[]},{"location":"development-contributing/#adding-a-new-cli-option","level":2,"title":"‚ûï Adding a New CLI Option","text":"<p>When adding a new CLI option to <code>datamodel-code-generator</code>, follow these steps:</p>","path":["üõ†Ô∏è Development"],"tags":[]},{"location":"development-contributing/#step-1-implement-the-option-required","level":3,"title":"Step 1: Implement the option (Required)","text":"<p>Add the option to <code>src/datamodel_code_generator/arguments.py</code>:</p> <pre><code>arg_parser.add_argument(\n    \"--my-new-option\",\n    help=\"Description of what this option does\",\n    action=\"store_true\",  # or other action type\n)\n</code></pre>","path":["üõ†Ô∏è Development"],"tags":[]},{"location":"development-contributing/#step-2-add-a-test-with-documentation-marker-required","level":3,"title":"Step 2: Add a test with documentation marker (Required)","text":"<p>Create a test that demonstrates the option and add the <code>@pytest.mark.cli_doc()</code> marker:</p> <pre><code>@pytest.mark.cli_doc(\n    options=[\"--my-new-option\"],\n    input_schema=\"jsonschema/example.json\",  # Path relative to tests/data/\n    cli_args=[\"--my-new-option\"],\n    golden_output=\"jsonschema/example_with_my_option.py\",  # Expected output\n)\ndef test_my_new_option(output_file: Path) -&gt; None:\n    \"\"\"Short description of what the option does.\n\n    This docstring becomes the documentation for the option.\n    Explain when and why users would use this option.\n    \"\"\"\n    run_main_and_assert(\n        input_path=JSON_SCHEMA_DATA_PATH / \"example.json\",\n        output_path=output_file,\n        extra_args=[\"--my-new-option\"],\n        ...\n    )\n</code></pre>","path":["üõ†Ô∏è Development"],"tags":[]},{"location":"development-contributing/#step-3-categorize-the-option-optional","level":3,"title":"Step 3: Categorize the option (Optional)","text":"<p>By default, new options appear in \"General Options\". To place in a specific category, add to <code>src/datamodel_code_generator/cli_options.py</code>:</p> <pre><code>CLI_OPTION_META: dict[str, CLIOptionMeta] = {\n    ...\n    \"--my-new-option\": CLIOptionMeta(\n        name=\"--my-new-option\",\n        category=OptionCategory.MODEL,  # or FIELD, TYPING, TEMPLATE, etc.\n    ),\n}\n</code></pre>","path":["üõ†Ô∏è Development"],"tags":[]},{"location":"development-contributing/#step-4-generate-and-verify-documentation","level":3,"title":"Step 4: Generate and verify documentation","text":"<pre><code># Regenerate CLI docs\n$ pytest --collect-cli-docs -p no:xdist -q\n$ python scripts/build_cli_docs.py\n\n# Verify docs are correct\n$ tox run -e cli-docs\n</code></pre>","path":["üõ†Ô∏è Development"],"tags":[]},{"location":"development-contributing/#troubleshooting","level":3,"title":"üîß Troubleshooting","text":"<p>If <code>tox run -e cli-docs</code> fails:</p> <ul> <li>\"No test found documenting option --xxx\": Add <code>@pytest.mark.cli_doc(options=[\"--xxx\"], ...)</code> to a test</li> <li>\"File not found: ...\": Check that <code>input_schema</code> and <code>golden_output</code> paths are correct</li> <li>\"CLI docs are OUT OF DATE\": Run <code>python scripts/build_cli_docs.py</code> to regenerate</li> </ul>","path":["üõ†Ô∏è Development"],"tags":[]},{"location":"development-contributing/#cli-documentation-marker-reference","level":2,"title":"üìñ CLI Documentation Marker Reference","text":"<p>The <code>cli_doc</code> marker supports:</p> Parameter Required Description <code>options</code> Yes List of CLI options this test documents <code>input_schema</code> Yes Input schema path (relative to <code>tests/data/</code>) <code>cli_args</code> Yes CLI arguments used in the test <code>golden_output</code> Yes* Expected output file path <code>model_outputs</code> No Dict of model type ‚Üí output file (for multi-model tabs) <code>version_outputs</code> No Dict of Python version ‚Üí output file <code>comparison_output</code> No Baseline output without option (for before/after) <code>primary</code> No Set <code>True</code> if this is the main example for the option <p>*Either <code>golden_output</code> or <code>model_outputs</code> is required.</p> <p>See existing tests in <code>tests/main/</code> for examples.</p>","path":["üõ†Ô∏è Development"],"tags":[]},{"location":"faq/","level":1,"title":"‚ùì Frequently Asked Questions","text":"","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#schema-handling","level":2,"title":"üìã Schema Handling","text":"","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#oneofanyof-generates-unexpected-union-types","level":3,"title":"üîÄ oneOf/anyOf generates unexpected Union types","text":"<p>When using <code>oneOf</code> or <code>anyOf</code>, the generated models may not match your expectations. Use <code>--union-mode</code> to control how unions are generated:</p> <pre><code># Smart union (Pydantic v2 only) - validates against types in order\ndatamodel-codegen --union-mode smart --output-model-type pydantic_v2.BaseModel ...\n\n# Left-to-right validation\ndatamodel-codegen --union-mode left_to_right ...\n</code></pre> <p>See CLI Reference: <code>--union-mode</code> for details.</p>","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#allof-doesnt-merge-properties-as-expected","level":3,"title":"üîó allOf doesn't merge properties as expected","text":"<p>Control how <code>allOf</code> schemas merge fields:</p> <pre><code># Merge only constraints (minItems, maxItems, pattern, etc.) - default\ndatamodel-codegen --allof-merge-mode constraints ...\n\n# Merge constraints + annotations (default, examples)\ndatamodel-codegen --allof-merge-mode all ...\n\n# Don't merge any fields\ndatamodel-codegen --allof-merge-mode none ...\n</code></pre> <p>See CLI Reference: <code>--allof-merge-mode</code> for details.</p> <p>üìé Related: #399</p>","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#how-to-generate-from-multiple-schema-files","level":3,"title":"üìÅ How to generate from multiple schema files?","text":"<p>Use a directory as input, or use <code>$ref</code> to reference other files:</p> <pre><code># Generate from directory containing multiple schemas\ndatamodel-codegen --input schemas/ --output models/\n</code></pre> <p>For schemas with cross-file <code>$ref</code>, ensure you have the HTTP extra for remote refs:</p> <pre><code>pip install 'datamodel-code-generator[http]'\n</code></pre> <p>üìé Related: #215</p>","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#type-checking","level":2,"title":"üîç Type Checking","text":"","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#mypy-complains-about-field-constraints","level":3,"title":"‚ö†Ô∏è mypy complains about Field constraints","text":"<p>If mypy reports errors about <code>conint</code>, <code>constr</code>, or other constrained types, use <code>--field-constraints</code> or <code>--use-annotated</code>:</p> <pre><code># Use Field(..., ge=0) instead of conint(ge=0)\ndatamodel-codegen --field-constraints ...\n\n# Use Annotated[int, Field(ge=0)]\ndatamodel-codegen --use-annotated ...\n</code></pre> <p>See Field Constraints for more information.</p>","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#type-checker-doesnt-understand-generated-types","level":3,"title":"ü§î Type checker doesn't understand generated types","text":"<p>Ensure you're using the correct target Python version:</p> <pre><code>datamodel-codegen --target-python-version 3.11 ...\n</code></pre> <p>This affects type syntax generation (e.g., <code>list[str]</code> vs <code>List[str]</code>, <code>X | Y</code> vs <code>Union[X, Y]</code>).</p>","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#field-naming","level":2,"title":"üè∑Ô∏è Field Naming","text":"","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#property-names-conflict-with-python-reserved-words","level":3,"title":"üö´ Property names conflict with Python reserved words","text":"<p>Properties like <code>class</code>, <code>from</code>, <code>import</code> are automatically renamed with a <code>field_</code> prefix. Control this behavior:</p> <pre><code># Custom prefix (default: \"field\")\ndatamodel-codegen --special-field-name-prefix my_prefix ...\n\n# Remove special prefix entirely\ndatamodel-codegen --remove-special-field-name-prefix ...\n</code></pre>","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#field-names-have-special-characters","level":3,"title":"üî£ Field names have special characters","text":"<p>JSON/YAML property names with spaces, dashes, or special characters are converted to valid Python identifiers. An alias is automatically generated to preserve the original name:</p> <pre><code>class Model(BaseModel):\n    my_field: str = Field(..., alias='my-field')\n</code></pre> <p>To disable aliases:</p> <pre><code>datamodel-codegen --no-alias ...\n</code></pre> <p>See Field Aliases for custom alias mappings.</p>","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#want-snake_case-field-names-from-camelcase","level":3,"title":"üêç Want snake_case field names from camelCase","text":"<pre><code>datamodel-codegen --snake-case-field ...\n</code></pre> <p>This generates snake_case field names with camelCase aliases:</p> <pre><code>class User(BaseModel):\n    first_name: str = Field(..., alias='firstName')\n</code></pre>","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#output-stability","level":2,"title":"üîÑ Output Stability","text":"","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#generated-output-changes-on-every-run","level":3,"title":"‚è∞ Generated output changes on every run","text":"<p>The timestamp in the header changes on each run. Disable it for reproducible output:</p> <pre><code>datamodel-codegen --disable-timestamp ...\n</code></pre>","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#output-differs-between-environments","level":3,"title":"üåç Output differs between environments","text":"<p>Ensure consistent formatting across environments:</p> <pre><code># Explicitly set formatters\ndatamodel-codegen --formatters black isort ...\n\n# Or disable formatting entirely for raw output\ndatamodel-codegen --formatters ...\n</code></pre> <p>Also ensure the same Python version and formatter configurations (<code>pyproject.toml</code>) are used.</p>","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#ci-fails-because-generated-code-is-different","level":3,"title":"ü§ñ CI fails because generated code is different","text":"<p>Use <code>--check</code> mode in CI to verify generated files are up-to-date:</p> <pre><code>datamodel-codegen --check --input schema.yaml --output models.py\n</code></pre> <p>This exits with code 1 if the output would differ, without modifying files.</p>","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#performance","level":2,"title":"‚ö° Performance","text":"","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#generation-is-slow-for-large-schemas","level":3,"title":"üê¢ Generation is slow for large schemas","text":"<p>For very large schemas with many models:</p> <ol> <li>Use <code>--reuse-model</code> to deduplicate identical models</li> <li>Consider splitting schemas into multiple files</li> <li>Use <code>--disable-warnings</code> to reduce output</li> </ol> <pre><code>datamodel-codegen --reuse-model --disable-warnings ...\n</code></pre> <p>See Model Reuse and Deduplication for details.</p>","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#output-model-types","level":2,"title":"üîß Output Model Types","text":"","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#which-output-model-type-should-i-use","level":3,"title":"ü§∑ Which output model type should I use?","text":"<ul> <li>Pydantic v2 (<code>pydantic_v2.BaseModel</code>): ‚ú® Recommended for new projects. Better performance and modern API.</li> <li>Pydantic v1 (<code>pydantic.BaseModel</code>): üîÑ Default for backward compatibility with existing codebases.</li> <li>dataclasses: Simple data containers without validation.</li> <li>TypedDict: Type hints for dict structures.</li> <li>msgspec: High-performance serialization.</li> </ul> <p>See Output Model Types for a detailed comparison.</p> <pre><code># For new projects\ndatamodel-codegen --output-model-type pydantic_v2.BaseModel ...\n</code></pre> <p>See Pydantic v1 vs v2 for migration details.</p> <p>üìé Related: #803</p>","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#generated-code-doesnt-work-with-my-pydantic-version","level":3,"title":"üí• Generated code doesn't work with my Pydantic version","text":"<p>Ensure the output model type matches your installed Pydantic version:</p> <pre><code># Check your Pydantic version\npython -c \"import pydantic; print(pydantic.VERSION)\"\n\n# Generate for Pydantic v2\ndatamodel-codegen --output-model-type pydantic_v2.BaseModel ...\n\n# Generate for Pydantic v1\ndatamodel-codegen --output-model-type pydantic.BaseModel ...\n</code></pre>","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#remote-schemas","level":2,"title":"üåê Remote Schemas","text":"","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#cannot-fetch-schema-from-url","level":3,"title":"üì° Cannot fetch schema from URL","text":"<p>Install the HTTP extra:</p> <pre><code>pip install 'datamodel-code-generator[http]'\n</code></pre> <p>For authenticated endpoints:</p> <pre><code>datamodel-codegen --url https://api.example.com/schema.yaml \\\n    --http-headers \"Authorization: Bearer TOKEN\" \\\n    --output model.py\n</code></pre>","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#ssl-certificate-errors","level":3,"title":"üîí SSL certificate errors","text":"<p>For development/testing with self-signed certificates:</p> <pre><code>datamodel-codegen --url https://... --http-ignore-tls --output model.py\n</code></pre> <p>‚ö†Ô∏è Security Notice</p> <p>Only use <code>--http-ignore-tls</code> in trusted environments.</p>","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#openapi-specific","level":2,"title":"üìò OpenAPI Specific","text":"","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#how-to-handle-readonlywriteonly-properties","level":3,"title":"üìù How to handle readOnly/writeOnly properties?","text":"<p>Use <code>--read-only-write-only-model-type</code> to generate separate Request/Response models:</p> <pre><code># Generate Request/Response models only\ndatamodel-codegen --read-only-write-only-model-type request-response ...\n\n# Generate Base + Request + Response models\ndatamodel-codegen --read-only-write-only-model-type all ...\n</code></pre> <p>üìé Related: #727</p>","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#why-are-nullable-fields-not-optional","level":3,"title":"‚ùì Why are nullable fields not Optional?","text":"<p>Use <code>--strict-nullable</code> to treat nullable fields as truly optional:</p> <pre><code>datamodel-codegen --strict-nullable ...\n</code></pre> <p>üìé Related: #327</p>","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#advanced","level":2,"title":"üîß Advanced","text":"","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#how-to-use-typealias-instead-of-rootmodel","level":3,"title":"üì¶ How to use TypeAlias instead of RootModel?","text":"<p>Use <code>--use-type-alias</code> (experimental) to generate type aliases instead of root models:</p> <pre><code>datamodel-codegen --use-type-alias --output-model-type pydantic_v2.BaseModel ...\n</code></pre> <p>See Root Models and Type Aliases for details.</p> <p>üìé Related: #2505</p>","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"faq/#see-also","level":2,"title":"üìñ See Also","text":"<ul> <li>üñ•Ô∏è CLI Reference - Complete option documentation</li> <li>‚öôÔ∏è pyproject.toml Configuration - Configure options via file</li> <li>üêõ GitHub Issues - Report bugs or request features</li> <li>üí¨ Discussions - Ask questions and share ideas</li> </ul>","path":["‚ùì Frequently Asked Questions"],"tags":[]},{"location":"field-constraints/","level":1,"title":"üîí Field Constraints","text":"","path":["Usage","Output Customization","üîí Field Constraints"],"tags":[]},{"location":"field-constraints/#field-constraints","level":1,"title":"üîí Field Constraints","text":"<p>The <code>--field-constraints</code> option converts all <code>con*</code> annotations (like <code>conint</code>, <code>constr</code>) to <code>Field</code> constraint options.</p>","path":["Usage","Output Customization","üîí Field Constraints"],"tags":[]},{"location":"field-constraints/#why-use-this","level":2,"title":"ü§î Why use this?","text":"<p>Mypy may show errors for <code>con*</code> annotations on fields. The <code>--field-constraints</code> option resolves this problem by using standard <code>Field()</code> constraints instead.</p>","path":["Usage","Output Customization","üîí Field Constraints"],"tags":[]},{"location":"field-constraints/#example","level":2,"title":"üìù Example","text":"<p>Convert simple JSON Schema <code>model.json</code> to pydantic model <code>model.py</code>:</p> <p>model.json <pre><code>{\n  \"type\":  \"object\",\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\",\n      \"maxLength\": 64\n    }\n  },\n  \"required\": [\"name\"]\n}\n</code></pre></p>","path":["Usage","Output Customization","üîí Field Constraints"],"tags":[]},{"location":"field-constraints/#without-field-constraints-option","level":3,"title":"‚ùå Without <code>--field-constraints</code> option","text":"<pre><code>datamodel-codegen --input model.json --input-file-type jsonschema &gt; model.py\n</code></pre> <p>Generated model.py <pre><code># generated by datamodel-codegen:\n#   filename:  model.json\n#   timestamp: 2020-07-20T15:37:56+00:00\n\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel, constr\n\n\nclass  Model(BaseModel):\n  name: constr(max_length=64)\n</code></pre></p> <p>üî¥ Run mypy... <pre><code>$ mypy model.py\nmodel.py:3: error: Invalid type comment or annotation\nmodel.py:3: note: Suggestion: use constr[...] instead of constr(...)\nFound 1 error in 1 file (checked 1 source file)\n</code></pre></p> <p>mypy shows errors! üò±</p>","path":["Usage","Output Customization","üîí Field Constraints"],"tags":[]},{"location":"field-constraints/#with-field-constraints-option","level":3,"title":"‚úÖ With <code>--field-constraints</code> option","text":"<pre><code>datamodel-codegen --input model.json --input-file-type jsonschema --field-constraints &gt; model.py\n</code></pre> <p>Generated model.py <pre><code># generated by datamodel-codegen:\n#   filename:  model.json\n#   timestamp: 2020-07-20T15:47:21+00:00\n\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    name: str = Field(..., max_length=64)\n</code></pre></p> <p>üü¢ Run mypy... <pre><code>$ mypy model.py\nSuccess: no issues found in 1 source file\n</code></pre></p> <p>No errors! üéâ</p>","path":["Usage","Output Customization","üîí Field Constraints"],"tags":[]},{"location":"field-constraints/#see-also","level":2,"title":"üìñ See Also","text":"<ul> <li>üñ•Ô∏è CLI Reference: <code>--field-constraints</code> - Detailed CLI option documentation with examples</li> </ul>","path":["Usage","Output Customization","üîí Field Constraints"],"tags":[]},{"location":"field-constraints/#related-issues","level":2,"title":"üîó Related Issues","text":"<ul> <li>pydantic/pydantic#156</li> </ul>","path":["Usage","Output Customization","üîí Field Constraints"],"tags":[]},{"location":"formatting/","level":1,"title":"üñåÔ∏è Code Formatting","text":"","path":["Usage","Templates and Formatting","üñåÔ∏è Code Formatting"],"tags":[]},{"location":"formatting/#code-formatting","level":1,"title":"üñåÔ∏è Code Formatting","text":"<p>Generated code is automatically formatted using code formatters. By default, <code>black</code> and <code>isort</code> are used to produce consistent, well-formatted output.</p>","path":["Usage","Templates and Formatting","üñåÔ∏è Code Formatting"],"tags":[]},{"location":"formatting/#default-behavior","level":2,"title":"üéØ Default Behavior","text":"<pre><code>datamodel-codegen --input schema.yaml --output model.py\n</code></pre> <p>This runs the following formatters in order:</p> <ol> <li>isort - Sorts and organizes imports</li> <li>black - Formats code style</li> </ol>","path":["Usage","Templates and Formatting","üñåÔ∏è Code Formatting"],"tags":[]},{"location":"formatting/#available-formatters","level":2,"title":"üõ†Ô∏è Available Formatters","text":"Formatter Description <code>black</code> Code formatting (PEP 8 style) <code>isort</code> Import sorting <code>ruff-check</code> Linting with auto-fix <code>ruff-format</code> Fast code formatting (black alternative)","path":["Usage","Templates and Formatting","üñåÔ∏è Code Formatting"],"tags":[]},{"location":"formatting/#using-ruff-instead-of-black","level":3,"title":"‚ö° Using ruff instead of black","text":"<p>Ruff is a fast Python linter and formatter. To use it:</p> <pre><code># Use ruff for both linting and formatting\ndatamodel-codegen --formatters ruff-check ruff-format --input schema.yaml --output model.py\n\n# Use ruff-format as a black replacement\ndatamodel-codegen --formatters isort ruff-format --input schema.yaml --output model.py\n</code></pre>","path":["Usage","Templates and Formatting","üñåÔ∏è Code Formatting"],"tags":[]},{"location":"formatting/#disable-formatting","level":3,"title":"üö´ Disable formatting","text":"<p><code>datamodel-codegen</code> requires at least one formatter when using the CLI <code>--formatters</code> option.</p> <p>To disable built-in formatting entirely, configure it via <code>pyproject.toml</code>:</p> pyproject.toml<pre><code>[tool.datamodel-codegen]\nformatters = []\n</code></pre>","path":["Usage","Templates and Formatting","üñåÔ∏è Code Formatting"],"tags":[]},{"location":"formatting/#configuration-via-pyprojecttoml","level":2,"title":"‚öôÔ∏è Configuration via pyproject.toml","text":"<p>Formatters read their configuration from <code>pyproject.toml</code>. The tool searches for <code>pyproject.toml</code> in:</p> <ol> <li>The output file's directory</li> <li>Parent directories (up to the git repository root)</li> </ol>","path":["Usage","Templates and Formatting","üñåÔ∏è Code Formatting"],"tags":[]},{"location":"formatting/#example-configuration","level":3,"title":"üìù Example Configuration","text":"pyproject.toml<pre><code>[tool.black]\nline-length = 100\nskip-string-normalization = true\n\n[tool.isort]\nprofile = \"black\"\nline_length = 100\n\n[tool.ruff]\nline-length = 100\n\n[tool.ruff.format]\nquote-style = \"single\"\n</code></pre>","path":["Usage","Templates and Formatting","üñåÔ∏è Code Formatting"],"tags":[]},{"location":"formatting/#string-quotes","level":2,"title":"üí¨ String Quotes","text":"<p>By default, string quote style is determined by your formatter configuration. To force double quotes regardless of configuration:</p> <pre><code>datamodel-codegen --use-double-quotes --input schema.yaml --output model.py\n</code></pre> <p>This overrides <code>skip_string_normalization</code> in black config.</p>","path":["Usage","Templates and Formatting","üñåÔ∏è Code Formatting"],"tags":[]},{"location":"formatting/#custom-formatters","level":2,"title":"üé® Custom Formatters","text":"<p>You can create custom formatters for specialized formatting needs. See Custom Formatters for details.</p>","path":["Usage","Templates and Formatting","üñåÔ∏è Code Formatting"],"tags":[]},{"location":"formatting/#see-also","level":2,"title":"üìñ See Also","text":"<ul> <li>üñ•Ô∏è CLI Reference: <code>--formatters</code> - Specify code formatters</li> <li>üí¨ CLI Reference: <code>--use-double-quotes</code> - Force double quotes</li> <li>üé® Custom Formatters - Create your own formatters</li> <li>‚öôÔ∏è pyproject.toml Configuration - Configure datamodel-codegen options</li> </ul>","path":["Usage","Templates and Formatting","üñåÔ∏è Code Formatting"],"tags":[]},{"location":"graphql/","level":1,"title":"üî∑ Generate from GraphQL","text":"<p>Generate Pydantic models from GraphQL schema definitions.</p>","path":["Usage","Input Formats","üî∑ Generate from GraphQL"],"tags":[]},{"location":"graphql/#quick-start","level":2,"title":"üöÄ Quick Start","text":"<pre><code>datamodel-codegen --input schema.graphql --input-file-type graphql --output model.py\n</code></pre> <p>üì¶ Installation</p> <p>GraphQL support requires the <code>graphql</code> extra: <pre><code>pip install 'datamodel-code-generator[graphql]'\n</code></pre></p>","path":["Usage","Input Formats","üî∑ Generate from GraphQL"],"tags":[]},{"location":"graphql/#simple-example","level":2,"title":"üìù Simple Example","text":"<p>Let's consider a simple GraphQL schema (more details in GraphQL Schemas and Types).</p> <p>schema.graphql <pre><code>type Book {\n  id: ID!\n  title: String\n  author: Author\n}\n\ntype Author {\n  id: ID!\n  name: String\n  books: [Book]\n}\n\ninput BooksInput {\n    ids: [ID!]!\n}\n\ninput AuthorBooksInput {\n    id: ID!\n}\n\ntype Query {\n  getBooks(input: BooksInput): [Book]\n  getAuthorBooks(input: AuthorBooksInput): [Book]\n}\n</code></pre></p> <p>‚ú® Generated model.py <pre><code># generated by datamodel-codegen:\n#   filename:  schema.graphql\n#   timestamp: 2023-11-20T17:04:42+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional, TypeAlias\n\nfrom pydantic import BaseModel, Field\nfrom typing_extensions import Literal\n\n# The `Boolean` scalar type represents `true` or `false`.\nBoolean: TypeAlias = bool\n\n\n# The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `\"4\"`) or integer (such as `4`) input value will be accepted as an ID.\nID: TypeAlias = str\n\n\n# The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\nString: TypeAlias = str\n\n\nclass Author(BaseModel):\n    books: Optional[List[Optional[Book]]] = Field(default_factory=list)\n    id: ID\n    name: Optional[String] = None\n    typename__: Optional[Literal['Author']] = Field('Author', alias='__typename')\n\n\nclass Book(BaseModel):\n    author: Optional[Author] = None\n    id: ID\n    title: Optional[String] = None\n    typename__: Optional[Literal['Book']] = Field('Book', alias='__typename')\n\n\nclass AuthorBooksInput(BaseModel):\n    id: ID\n    typename__: Optional[Literal['AuthorBooksInput']] = Field(\n        'AuthorBooksInput', alias='__typename'\n    )\n\n\nclass BooksInput(BaseModel):\n    ids: List[ID]\n    typename__: Optional[Literal['BooksInput']] = Field(\n        'BooksInput', alias='__typename'\n    )\n</code></pre></p>","path":["Usage","Input Formats","üî∑ Generate from GraphQL"],"tags":[]},{"location":"graphql/#response-deserialization","level":2,"title":"üì§ Response Deserialization","text":"<p>For the following response of <code>getAuthorBooks</code> GraphQL query:</p> <p>response.json <pre><code>{\n  \"getAuthorBooks\": [\n    {\n      \"author\": {\n        \"id\": \"51341cdscwef14r13\",\n        \"name\": \"J. K. Rowling\"\n      },\n      \"id\": \"1321dfvrt211wdw\",\n      \"title\": \"Harry Potter and the Prisoner of Azkaban\"\n    },\n    {\n      \"author\": {\n        \"id\": \"51341cdscwef14r13\",\n        \"name\": \"J. K. Rowling\"\n      },\n      \"id\": \"dvsmu12e19xmqacqw9\",\n      \"title\": \"Fantastic Beasts: The Crimes of Grindelwald\"\n    }\n  ]\n}\n</code></pre></p> <p>main.py <pre><code>from model import Book\n\nresponse = {...}\n\nbooks = [\n    Book.parse_obj(book_raw) for book_raw in response[\"getAuthorBooks\"]\n]\nprint(books)\n# [Book(author=Author(books=[], id='51341cdscwef14r13', name='J. K. Rowling', typename__='Author'), id='1321dfvrt211wdw', title='Harry Potter and the Prisoner of Azkaban', typename__='Book'), Book(author=Author(books=[], id='51341cdscwef14r13', name='J. K. Rowling', typename__='Author'), id='dvsmu12e19xmqacqw9', title='Fantastic Beasts: The Crimes of Grindelwald', typename__='Book')]\n</code></pre></p>","path":["Usage","Input Formats","üî∑ Generate from GraphQL"],"tags":[]},{"location":"graphql/#custom-scalar-types","level":2,"title":"üé® Custom Scalar Types","text":"<pre><code>datamodel-codegen --input schema.graphql --input-file-type graphql --output model.py --extra-template-data data.json\n</code></pre> <p>schema.graphql <pre><code>scalar Long\n\ntype A {\n  id: ID!\n  duration: Long!\n}\n</code></pre></p> <p>data.json <pre><code>{\n  \"Long\": {\n    \"py_type\": \"int\"\n  }\n}\n</code></pre></p> <p>‚ú® Generated model.py <pre><code># generated by datamodel-codegen:\n#   filename:  custom-scalar-types.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional, TypeAlias\n\nfrom pydantic import BaseModel, Field\nfrom typing_extensions import Literal\n\n# The `Boolean` scalar type represents `true` or `false`.\nBoolean: TypeAlias = bool\n\n\n# The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `\"4\"`) or integer (such as `4`) input value will be accepted as an ID.\nID: TypeAlias = str\n\n\nLong: TypeAlias = int\n\n\n# The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\nString: TypeAlias = str\n\n\nclass A(BaseModel):\n    duration: Long\n    id: ID\n    typename__: Optional[Literal['A']] = Field('A', alias='__typename')\n</code></pre></p>","path":["Usage","Input Formats","üî∑ Generate from GraphQL"],"tags":[]},{"location":"graphql/#see-also","level":2,"title":"üìñ See Also","text":"<ul> <li>üñ•Ô∏è CLI Reference - Complete CLI options reference</li> <li>üîß CLI Reference: Typing Customization - Type annotation options</li> <li>üé® CLI Reference: <code>--extra-template-data</code> - Custom scalar type mappings</li> </ul>","path":["Usage","Input Formats","üî∑ Generate from GraphQL"],"tags":[]},{"location":"jsondata/","level":1,"title":"üìä Generate from JSON Data","text":"<p>Generate Pydantic models directly from JSON data. Under the hood, the generator uses GenSON to infer a JSON Schema from your input, then processes it the same way as JSON Schema input.</p>","path":["Usage","Input Formats","üìä Generate from JSON Data"],"tags":[]},{"location":"jsondata/#quick-start","level":2,"title":"üöÄ Quick Start","text":"<pre><code>datamodel-codegen --input pets.json --input-file-type json --output model.py\n</code></pre>","path":["Usage","Input Formats","üìä Generate from JSON Data"],"tags":[]},{"location":"jsondata/#example","level":2,"title":"üìù Example","text":"<p>pets.json <pre><code>{\n  \"pets\": [\n    {\n      \"name\": \"dog\",\n      \"age\": 2\n    },\n    {\n      \"name\": \"cat\",\n      \"age\": 1\n    },\n    {\n      \"name\": \"snake\",\n      \"age\": 3,\n      \"nickname\": \"python\"\n    }\n  ],\n  \"status\": 200\n}\n</code></pre></p> <p>‚ú® Generated model.py <pre><code># generated by datamodel-codegen:\n#   filename:  pets.json\n#   timestamp: 2020-04-27T16:08:21+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    name: str\n    age: int\n    nickname: Optional[str] = None\n\n\nclass Model(BaseModel):\n    pets: List[Pet]\n    status: int\n</code></pre></p>","path":["Usage","Input Formats","üìä Generate from JSON Data"],"tags":[]},{"location":"jsondata/#see-also","level":2,"title":"üìñ See Also","text":"<ul> <li>üìã Generate from JSON Schema - JSON Schema input documentation</li> <li>üñ•Ô∏è CLI Reference - Complete CLI options reference</li> <li>üìä Supported Data Types - Data type support details</li> </ul>","path":["Usage","Input Formats","üìä Generate from JSON Data"],"tags":[]},{"location":"jsonschema/","level":1,"title":"üìã Generate from JSON Schema","text":"<p>Generate Pydantic models from JSON Schema definitions. See Supported Data Types for supported JSON Schema features.</p>","path":["Usage","Input Formats","üìã Generate from JSON Schema"],"tags":[]},{"location":"jsonschema/#quick-start","level":2,"title":"üöÄ Quick Start","text":"<pre><code>datamodel-codegen --input person.json --input-file-type jsonschema --output model.py\n</code></pre>","path":["Usage","Input Formats","üìã Generate from JSON Schema"],"tags":[]},{"location":"jsonschema/#example","level":2,"title":"üìù Example","text":"<p>person.json <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Person\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"firstName\": {\n      \"type\": \"string\",\n      \"description\": \"The person's first name.\"\n    },\n    \"lastName\": {\n      \"type\": \"string\",\n      \"description\": \"The person's last name.\"\n    },\n    \"age\": {\n      \"description\": \"Age in years which must be equal to or greater than zero.\",\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"friends\": {\n      \"type\": \"array\"\n    },\n    \"comment\": {\n      \"type\": \"null\"\n    }\n  }\n}\n</code></pre></p> <p>‚ú® Generated model.py <pre><code># generated by datamodel-codegen:\n#   filename:  person.json\n#   timestamp: 2020-04-27T16:12:27+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Any, List, Optional\n\nfrom pydantic import BaseModel, Field, conint\n\n\nclass Person(BaseModel):\n    firstName: Optional[str] = Field(None, description=\"The person's first name.\")\n    lastName: Optional[str] = Field(None, description=\"The person's last name.\")\n    age: Optional[conint(ge=0)] = Field(\n        None, description='Age in years which must be equal to or greater than zero.'\n    )\n    friends: Optional[List] = None\n    comment: Optional[Any] = None\n</code></pre></p>","path":["Usage","Input Formats","üìã Generate from JSON Schema"],"tags":[]},{"location":"jsonschema/#see-also","level":2,"title":"üìñ See Also","text":"<ul> <li>üñ•Ô∏è CLI Reference - Complete CLI options reference</li> <li>üîß CLI Reference: Typing Customization - Type annotation options</li> <li>üè∑Ô∏è CLI Reference: Field Customization - Field naming and constraint options</li> <li>üìä Supported Data Types - JSON Schema data type support</li> </ul>","path":["Usage","Input Formats","üìã Generate from JSON Schema"],"tags":[]},{"location":"model-reuse/","level":1,"title":"Model Reuse and Deduplication","text":"","path":["Usage","Output Customization","Model Reuse and Deduplication"],"tags":[]},{"location":"model-reuse/#model-reuse-and-deduplication","level":1,"title":"Model Reuse and Deduplication","text":"<p>When generating models from schemas, you may encounter duplicate model definitions. datamodel-code-generator provides options to deduplicate models and share them across multiple files, improving output structure, reducing diff sizes, and enhancing performance.</p>","path":["Usage","Output Customization","Model Reuse and Deduplication"],"tags":[]},{"location":"model-reuse/#quick-overview","level":2,"title":"Quick Overview","text":"Option Description <code>--reuse-model</code> Deduplicate identical model/enum definitions <code>--reuse-scope</code> Control scope of deduplication (<code>root</code> or <code>tree</code>) <code>--shared-module-name</code> Name for shared module in multi-file output <code>--collapse-root-models</code> Inline root models instead of creating wrappers","path":["Usage","Output Customization","Model Reuse and Deduplication"],"tags":[]},{"location":"model-reuse/#-reuse-model","level":2,"title":"<code>--reuse-model</code>","text":"<p>The <code>--reuse-model</code> flag detects identical enum or model definitions and generates a single shared definition instead of duplicates.</p>","path":["Usage","Output Customization","Model Reuse and Deduplication"],"tags":[]},{"location":"model-reuse/#without-reuse-model","level":3,"title":"Without <code>--reuse-model</code>","text":"<pre><code>datamodel-codegen --input schema.json --output model.py\n</code></pre> <pre><code># Duplicate enums for animal and pet fields\nclass Animal(Enum):\n    dog = 'dog'\n    cat = 'cat'\n\nclass Pet(Enum):  # Duplicate!\n    dog = 'dog'\n    cat = 'cat'\n\nclass User(BaseModel):\n    animal: Optional[Animal] = None\n    pet: Optional[Pet] = None\n</code></pre>","path":["Usage","Output Customization","Model Reuse and Deduplication"],"tags":[]},{"location":"model-reuse/#with-reuse-model","level":3,"title":"With <code>--reuse-model</code>","text":"<pre><code>datamodel-codegen --input schema.json --output model.py --reuse-model\n</code></pre> <pre><code># Single shared enum\nclass Animal(Enum):\n    dog = 'dog'\n    cat = 'cat'\n\nclass User(BaseModel):\n    animal: Optional[Animal] = None\n    pet: Optional[Animal] = None  # Reuses Animal\n</code></pre>","path":["Usage","Output Customization","Model Reuse and Deduplication"],"tags":[]},{"location":"model-reuse/#benefits","level":3,"title":"Benefits","text":"<ul> <li>Smaller output - Less generated code</li> <li>Cleaner diffs - Changes to shared types only appear once</li> <li>Better performance - Faster generation for large schemas</li> <li>Type consistency - Same types are truly the same</li> </ul>","path":["Usage","Output Customization","Model Reuse and Deduplication"],"tags":[]},{"location":"model-reuse/#-reuse-scope","level":2,"title":"<code>--reuse-scope</code>","text":"<p>Controls the scope for model reuse detection when processing multiple input files.</p> Value Description <code>root</code> Detect duplicates only within each input file (default) <code>tree</code> Detect duplicates across all input files","path":["Usage","Output Customization","Model Reuse and Deduplication"],"tags":[]},{"location":"model-reuse/#single-file-input","level":3,"title":"Single-file input","text":"<p>For single-file input, <code>--reuse-scope</code> has no effect. Use <code>--reuse-model</code> alone.</p>","path":["Usage","Output Customization","Model Reuse and Deduplication"],"tags":[]},{"location":"model-reuse/#multi-file-input-with-tree-scope","level":3,"title":"Multi-file input with <code>tree</code> scope","text":"<p>When generating from multiple schema files to a directory:</p> <pre><code>datamodel-codegen --input schemas/ --output models/ --reuse-model --reuse-scope tree\n</code></pre> <p>Input files: <pre><code>schemas/\n‚îú‚îÄ‚îÄ user.json      # defines SharedModel\n‚îî‚îÄ‚îÄ order.json     # also defines identical SharedModel\n</code></pre></p> <p>Output with <code>--reuse-scope tree</code>: <pre><code>models/\n‚îú‚îÄ‚îÄ __init__.py\n‚îú‚îÄ‚îÄ user.py        # imports from shared\n‚îú‚îÄ‚îÄ order.py       # imports from shared\n‚îî‚îÄ‚îÄ shared.py      # SharedModel defined once\n</code></pre></p> <pre><code># models/user.py\nfrom .shared import SharedModel\n\nclass User(BaseModel):\n    data: Optional[SharedModel] = None\n\n# models/shared.py\nclass SharedModel(BaseModel):\n    id: Optional[int] = None\n    name: Optional[str] = None\n</code></pre>","path":["Usage","Output Customization","Model Reuse and Deduplication"],"tags":[]},{"location":"model-reuse/#-shared-module-name","level":2,"title":"<code>--shared-module-name</code>","text":"<p>Customize the name of the shared module when using <code>--reuse-scope tree</code>.</p> <pre><code>datamodel-codegen --input schemas/ --output models/ \\\n  --reuse-model --reuse-scope tree --shared-module-name common\n</code></pre> <p>Output: <pre><code>models/\n‚îú‚îÄ‚îÄ __init__.py\n‚îú‚îÄ‚îÄ user.py\n‚îú‚îÄ‚îÄ order.py\n‚îî‚îÄ‚îÄ common.py      # Instead of shared.py\n</code></pre></p>","path":["Usage","Output Customization","Model Reuse and Deduplication"],"tags":[]},{"location":"model-reuse/#-collapse-root-models","level":2,"title":"<code>--collapse-root-models</code>","text":"<p>Inline root model definitions instead of creating separate wrapper classes.</p>","path":["Usage","Output Customization","Model Reuse and Deduplication"],"tags":[]},{"location":"model-reuse/#without-collapse-root-models","level":3,"title":"Without <code>--collapse-root-models</code>","text":"<pre><code>class UserId(BaseModel):\n    __root__: str\n\nclass User(BaseModel):\n    id: UserId\n</code></pre>","path":["Usage","Output Customization","Model Reuse and Deduplication"],"tags":[]},{"location":"model-reuse/#with-collapse-root-models","level":3,"title":"With <code>--collapse-root-models</code>","text":"<pre><code>class User(BaseModel):\n    id: str  # Inlined\n</code></pre>","path":["Usage","Output Customization","Model Reuse and Deduplication"],"tags":[]},{"location":"model-reuse/#when-to-use","level":3,"title":"When to use","text":"<ul> <li>Simpler output when wrapper classes aren't needed</li> <li>Reducing the number of generated classes</li> <li>When root models are just type aliases</li> </ul>","path":["Usage","Output Customization","Model Reuse and Deduplication"],"tags":[]},{"location":"model-reuse/#combining-options","level":2,"title":"Combining Options","text":"","path":["Usage","Output Customization","Model Reuse and Deduplication"],"tags":[]},{"location":"model-reuse/#recommended-for-large-multi-file-projects","level":3,"title":"Recommended for large multi-file projects","text":"<pre><code>datamodel-codegen \\\n  --input schemas/ \\\n  --output models/ \\\n  --reuse-model \\\n  --reuse-scope tree \\\n  --shared-module-name common \\\n  --collapse-root-models\n</code></pre> <p>This produces: - Deduplicated models across all files - Shared types in a <code>common.py</code> module - Inlined simple root models - Minimal, clean output</p>","path":["Usage","Output Customization","Model Reuse and Deduplication"],"tags":[]},{"location":"model-reuse/#recommended-for-single-file-projects","level":3,"title":"Recommended for single-file projects","text":"<pre><code>datamodel-codegen \\\n  --input schema.json \\\n  --output model.py \\\n  --reuse-model \\\n  --collapse-root-models\n</code></pre>","path":["Usage","Output Customization","Model Reuse and Deduplication"],"tags":[]},{"location":"model-reuse/#performance-impact","level":2,"title":"Performance Impact","text":"<p>For large schemas with many models:</p> Scenario Without reuse With reuse 100 schemas, 50% duplicates 100 models ~50 models Generation time Baseline Faster (less to generate) Output size Large Smaller Git diff on type change Multiple files Single location <p>Performance tip</p> <p>For very large schemas, combine <code>--reuse-model</code> with <code>--disable-warnings</code> to speed up generation:</p> <pre><code>datamodel-codegen --reuse-model --disable-warnings --input large-schema.json\n</code></pre>","path":["Usage","Output Customization","Model Reuse and Deduplication"],"tags":[]},{"location":"model-reuse/#output-structure-comparison","level":2,"title":"Output Structure Comparison","text":"","path":["Usage","Output Customization","Model Reuse and Deduplication"],"tags":[]},{"location":"model-reuse/#without-deduplication","level":3,"title":"Without deduplication","text":"<pre><code>models/\n‚îú‚îÄ‚îÄ user.py         # UserStatus enum\n‚îú‚îÄ‚îÄ order.py        # OrderStatus enum (duplicate of UserStatus!)\n‚îî‚îÄ‚îÄ product.py      # ProductStatus enum (duplicate!)\n</code></pre>","path":["Usage","Output Customization","Model Reuse and Deduplication"],"tags":[]},{"location":"model-reuse/#with-reuse-model-reuse-scope-tree","level":3,"title":"With <code>--reuse-model --reuse-scope tree</code>","text":"<pre><code>models/\n‚îú‚îÄ‚îÄ __init__.py\n‚îú‚îÄ‚îÄ user.py         # imports Status from shared\n‚îú‚îÄ‚îÄ order.py        # imports Status from shared\n‚îú‚îÄ‚îÄ product.py      # imports Status from shared\n‚îî‚îÄ‚îÄ shared.py       # Status enum defined once\n</code></pre>","path":["Usage","Output Customization","Model Reuse and Deduplication"],"tags":[]},{"location":"model-reuse/#see-also","level":2,"title":"See Also","text":"<ul> <li>CLI Reference: <code>--reuse-model</code></li> <li>CLI Reference: <code>--reuse-scope</code></li> <li>CLI Reference: <code>--collapse-root-models</code></li> <li>Root Models and Type Aliases</li> <li>FAQ: Performance</li> </ul>","path":["Usage","Output Customization","Model Reuse and Deduplication"],"tags":[]},{"location":"module-exports/","level":1,"title":"Module Structure and Exports","text":"","path":["Usage","Output Customization","Module Structure and Exports"],"tags":[]},{"location":"module-exports/#module-structure-and-exports","level":1,"title":"Module Structure and Exports","text":"<p>When generating models to a directory structure, datamodel-code-generator can automatically create <code>__init__.py</code> files with <code>__all__</code> exports. This page explains how to control this behavior.</p>","path":["Usage","Output Customization","Module Structure and Exports"],"tags":[]},{"location":"module-exports/#quick-overview","level":2,"title":"Quick Overview","text":"Option Description <code>--all-exports-scope</code> Control which modules get <code>__all__</code> exports <code>--all-exports-collision-strategy</code> Handle name collisions in recursive exports <code>--treat-dot-as-module</code> Convert dots in names to nested modules","path":["Usage","Output Customization","Module Structure and Exports"],"tags":[]},{"location":"module-exports/#-all-exports-scope","level":2,"title":"<code>--all-exports-scope</code>","text":"<p>Controls the scope of <code>__all__</code> generation in <code>__init__.py</code> files.</p> Value Description <code>none</code> No <code>__all__</code> generation (default) <code>local</code> Export only the module's own definitions <code>recursive</code> Export all definitions from child modules","path":["Usage","Output Customization","Module Structure and Exports"],"tags":[]},{"location":"module-exports/#example-none-default","level":3,"title":"Example: <code>none</code> (default)","text":"<pre><code>datamodel-codegen --input schemas/ --output models/\n</code></pre> <pre><code># models/__init__.py\n# (empty or minimal imports)\n</code></pre>","path":["Usage","Output Customization","Module Structure and Exports"],"tags":[]},{"location":"module-exports/#example-local","level":3,"title":"Example: <code>local</code>","text":"<pre><code>datamodel-codegen --input schemas/ --output models/ --all-exports-scope local\n</code></pre> <pre><code># models/__init__.py\nfrom .user import User\nfrom .order import Order\n\n__all__ = [\"User\", \"Order\"]\n</code></pre>","path":["Usage","Output Customization","Module Structure and Exports"],"tags":[]},{"location":"module-exports/#example-recursive","level":3,"title":"Example: <code>recursive</code>","text":"<pre><code>datamodel-codegen --input schemas/ --output models/ --all-exports-scope recursive\n</code></pre> <pre><code># models/__init__.py\nfrom .user import User\nfrom .order import Order\nfrom .common.status import Status\nfrom .common.types import ID, Timestamp\n\n__all__ = [\"User\", \"Order\", \"Status\", \"ID\", \"Timestamp\"]\n</code></pre>","path":["Usage","Output Customization","Module Structure and Exports"],"tags":[]},{"location":"module-exports/#-all-exports-collision-strategy","level":2,"title":"<code>--all-exports-collision-strategy</code>","text":"<p>When using <code>--all-exports-scope recursive</code>, name collisions can occur if multiple modules define the same class name. This option controls how to handle them.</p> Value Description <code>minimal-prefix</code> Add minimum module path prefix to disambiguate <code>full-prefix</code> Use complete module path for all exports","path":["Usage","Output Customization","Module Structure and Exports"],"tags":[]},{"location":"module-exports/#the-problem","level":3,"title":"The Problem","text":"<pre><code>models/\n‚îú‚îÄ‚îÄ user/\n‚îÇ   ‚îî‚îÄ‚îÄ types.py      # defines `ID`\n‚îî‚îÄ‚îÄ order/\n    ‚îî‚îÄ‚îÄ types.py      # also defines `ID`\n</code></pre> <p>Both modules define <code>ID</code>, causing a collision when exporting recursively.</p>","path":["Usage","Output Customization","Module Structure and Exports"],"tags":[]},{"location":"module-exports/#solution-minimal-prefix","level":3,"title":"Solution: <code>minimal-prefix</code>","text":"<pre><code>datamodel-codegen --input schemas/ --output models/ \\\n  --all-exports-scope recursive \\\n  --all-exports-collision-strategy minimal-prefix\n</code></pre> <pre><code># models/__init__.py\nfrom .user.types import ID as user_ID\nfrom .order.types import ID as order_ID\n\n__all__ = [\"user_ID\", \"order_ID\"]\n</code></pre> <p>Only colliding names get prefixed.</p>","path":["Usage","Output Customization","Module Structure and Exports"],"tags":[]},{"location":"module-exports/#solution-full-prefix","level":3,"title":"Solution: <code>full-prefix</code>","text":"<pre><code>datamodel-codegen --input schemas/ --output models/ \\\n  --all-exports-scope recursive \\\n  --all-exports-collision-strategy full-prefix\n</code></pre> <pre><code># models/__init__.py\nfrom .user.types import ID as user_types_ID\nfrom .order.types import ID as order_types_ID\n\n__all__ = [\"user_types_ID\", \"order_types_ID\"]\n</code></pre> <p>All names use the full module path prefix.</p>","path":["Usage","Output Customization","Module Structure and Exports"],"tags":[]},{"location":"module-exports/#-treat-dot-as-module","level":2,"title":"<code>--treat-dot-as-module</code>","text":"<p>Converts dots in schema names to nested module directories.</p>","path":["Usage","Output Customization","Module Structure and Exports"],"tags":[]},{"location":"module-exports/#without-treat-dot-as-module","level":3,"title":"Without <code>--treat-dot-as-module</code>","text":"<p>Schema with <code>title: \"api.v1.User\"</code> generates:</p> <pre><code># models.py\nclass ApiV1User(BaseModel):\n    ...\n</code></pre>","path":["Usage","Output Customization","Module Structure and Exports"],"tags":[]},{"location":"module-exports/#with-treat-dot-as-module","level":3,"title":"With <code>--treat-dot-as-module</code>","text":"<pre><code>datamodel-codegen --input schema.json --output models/ --treat-dot-as-module\n</code></pre> <p>Schema with <code>title: \"api.v1.User\"</code> generates:</p> <pre><code>models/\n‚îú‚îÄ‚îÄ __init__.py\n‚îî‚îÄ‚îÄ api/\n    ‚îú‚îÄ‚îÄ __init__.py\n    ‚îî‚îÄ‚îÄ v1/\n        ‚îú‚îÄ‚îÄ __init__.py\n        ‚îî‚îÄ‚îÄ user.py      # contains class User\n</code></pre> <p>This is useful for: - Organizing large schemas by namespace - Mirroring API versioning structure - Keeping related models together</p>","path":["Usage","Output Customization","Module Structure and Exports"],"tags":[]},{"location":"module-exports/#common-patterns","level":2,"title":"Common Patterns","text":"","path":["Usage","Output Customization","Module Structure and Exports"],"tags":[]},{"location":"module-exports/#pattern-1-flat-output-with-local-exports","level":3,"title":"Pattern 1: Flat output with local exports","text":"<p>Best for small to medium projects with a single output file or simple structure.</p> <pre><code>datamodel-codegen --input schema.yaml --output models/ --all-exports-scope local\n</code></pre>","path":["Usage","Output Customization","Module Structure and Exports"],"tags":[]},{"location":"module-exports/#pattern-2-hierarchical-with-recursive-exports","level":3,"title":"Pattern 2: Hierarchical with recursive exports","text":"<p>Best for large projects with many schemas organized by domain.</p> <pre><code>datamodel-codegen --input schemas/ --output models/ \\\n  --all-exports-scope recursive \\\n  --all-exports-collision-strategy minimal-prefix \\\n  --treat-dot-as-module\n</code></pre>","path":["Usage","Output Customization","Module Structure and Exports"],"tags":[]},{"location":"module-exports/#pattern-3-openapi-with-module-structure","level":3,"title":"Pattern 3: OpenAPI with module structure","text":"<p>Best for OpenAPI schemas with versioned endpoints.</p> <pre><code>datamodel-codegen --input openapi.yaml --output models/ \\\n  --treat-dot-as-module \\\n  --all-exports-scope recursive\n</code></pre>","path":["Usage","Output Customization","Module Structure and Exports"],"tags":[]},{"location":"module-exports/#troubleshooting","level":2,"title":"Troubleshooting","text":"","path":["Usage","Output Customization","Module Structure and Exports"],"tags":[]},{"location":"module-exports/#import-errors-after-generation","level":3,"title":"Import errors after generation","text":"<p>If you see <code>ImportError: cannot import name 'X'</code>:</p> <ol> <li>Check if <code>__all__</code> is generated correctly</li> <li>Verify the module structure matches your imports</li> <li>Try <code>--all-exports-scope local</code> first, then <code>recursive</code></li> </ol>","path":["Usage","Output Customization","Module Structure and Exports"],"tags":[]},{"location":"module-exports/#name-collisions","level":3,"title":"Name collisions","text":"<p>If you see duplicate class names:</p> <ol> <li>Use <code>--all-exports-collision-strategy minimal-prefix</code></li> <li>Or use <code>--all-exports-collision-strategy full-prefix</code> for maximum clarity</li> <li>Consider restructuring your schemas to avoid collisions</li> </ol>","path":["Usage","Output Customization","Module Structure and Exports"],"tags":[]},{"location":"module-exports/#circular-imports","level":3,"title":"Circular imports","text":"<p>If you encounter circular import errors:</p> <ol> <li>Check the generated <code>__init__.py</code> files</li> <li>Consider using <code>--all-exports-scope local</code> instead of <code>recursive</code></li> <li>Use lazy imports in your application code</li> </ol>","path":["Usage","Output Customization","Module Structure and Exports"],"tags":[]},{"location":"module-exports/#see-also","level":2,"title":"See Also","text":"<ul> <li>CLI Reference: <code>--all-exports-scope</code></li> <li>CLI Reference: <code>--all-exports-collision-strategy</code></li> <li>CLI Reference: <code>--treat-dot-as-module</code></li> <li>Model Reuse and Deduplication</li> </ul>","path":["Usage","Output Customization","Module Structure and Exports"],"tags":[]},{"location":"oneliner/","level":1,"title":"One-liner Usage","text":"<p>This guide covers how to use datamodel-code-generator with pipes and clipboard tools for quick, one-time code generation without permanent installation.</p> <p>Note</p> <p>The package name is <code>datamodel-code-generator</code>, and the CLI command is <code>datamodel-codegen</code>.</p>","path":["Usage","Integration","One-liner Usage"],"tags":[]},{"location":"oneliner/#one-liner-execution-with-uvxpipx","level":2,"title":"One-liner Execution with uvx/pipx","text":"<p>You don't need to install datamodel-code-generator permanently. Use <code>uvx</code> or <code>pipx run</code> to execute it directly.</p>","path":["Usage","Integration","One-liner Usage"],"tags":[]},{"location":"oneliner/#using-uvx-recommended","level":3,"title":"Using uvx (Recommended)","text":"<p>uvx runs Python tools without installation:</p> <pre><code># Basic usage\nuvx datamodel-codegen --input schema.json --output model.py\n\n# With extras (e.g., HTTP support)\nuvx --from 'datamodel-code-generator[http]' datamodel-codegen --url https://example.com/api.yaml --output model.py\n\n# With GraphQL support\nuvx --from 'datamodel-code-generator[graphql]' datamodel-codegen --input schema.graphql --output model.py\n</code></pre>","path":["Usage","Integration","One-liner Usage"],"tags":[]},{"location":"oneliner/#using-pipx-run","level":3,"title":"Using pipx run","text":"<p>pipx also supports one-shot execution:</p> <pre><code>pipx run datamodel-code-generator --input schema.json --output model.py\n</code></pre>","path":["Usage","Integration","One-liner Usage"],"tags":[]},{"location":"oneliner/#reading-from-stdin","level":2,"title":"Reading from stdin","text":"<p>datamodel-code-generator can read schema input from stdin, enabling powerful pipeline workflows:</p> <pre><code># Pipe JSON directly\necho '{\"type\": \"object\", \"properties\": {\"name\": {\"type\": \"string\"}}}' | \\\n  uvx datamodel-codegen --input-file-type jsonschema\n\n# Pipe from another command\ncurl -s https://example.com/schema.json | \\\n  uvx datamodel-codegen --input-file-type jsonschema --output model.py\n</code></pre>","path":["Usage","Integration","One-liner Usage"],"tags":[]},{"location":"oneliner/#clipboard-integration","level":2,"title":"Clipboard Integration","text":"<p>Combine stdin support with clipboard tools to quickly generate models from copied schema definitions.</p>","path":["Usage","Integration","One-liner Usage"],"tags":[]},{"location":"oneliner/#macos-pbpastepbcopy","level":3,"title":"macOS (pbpaste/pbcopy)","text":"<pre><code># Generate from clipboard and print to stdout\npbpaste | uvx datamodel-codegen --input-file-type jsonschema\n\n# Generate from clipboard and save to file\npbpaste | uvx datamodel-codegen --input-file-type jsonschema --output model.py\n\n# Generate from clipboard and copy result back to clipboard\npbpaste | uvx datamodel-codegen --input-file-type jsonschema | pbcopy\n</code></pre>","path":["Usage","Integration","One-liner Usage"],"tags":[]},{"location":"oneliner/#linux-xclipxsel","level":3,"title":"Linux (xclip/xsel)","text":"xclipxsel <pre><code># Generate from clipboard and print to stdout\nxclip -selection clipboard -o | uvx datamodel-codegen --input-file-type jsonschema\n\n# Generate and copy result to clipboard\nxclip -selection clipboard -o | uvx datamodel-codegen --input-file-type jsonschema | xclip -selection clipboard\n</code></pre> <pre><code># Generate from clipboard and print to stdout\nxsel --clipboard --output | uvx datamodel-codegen --input-file-type jsonschema\n\n# Generate and copy result to clipboard\nxsel --clipboard --output | uvx datamodel-codegen --input-file-type jsonschema | xsel --clipboard --input\n</code></pre> <p>Installing clipboard tools on Linux</p> <pre><code># Debian/Ubuntu\nsudo apt install xclip\n# or\nsudo apt install xsel\n\n# Fedora\nsudo dnf install xclip\n# or\nsudo dnf install xsel\n</code></pre>","path":["Usage","Integration","One-liner Usage"],"tags":[]},{"location":"oneliner/#windows-clippowershell","level":3,"title":"Windows (clip/PowerShell)","text":"PowerShellCommand Prompt <pre><code># Generate from clipboard and print to stdout\nGet-Clipboard | uvx datamodel-codegen --input-file-type jsonschema\n\n# Generate and copy result to clipboard\nGet-Clipboard | uvx datamodel-codegen --input-file-type jsonschema | Set-Clipboard\n</code></pre> <pre><code>REM Windows Command Prompt doesn't have a built-in paste command\nREM Use PowerShell from cmd:\npowershell -command \"Get-Clipboard\" | uvx datamodel-codegen --input-file-type jsonschema\n</code></pre> <p>Windows clip command</p> <p>The <code>clip</code> command on Windows only supports copying to the clipboard, not reading from it. Use PowerShell's <code>Get-Clipboard</code> and <code>Set-Clipboard</code> for full clipboard integration.</p>","path":["Usage","Integration","One-liner Usage"],"tags":[]},{"location":"oneliner/#practical-examples","level":2,"title":"Practical Examples","text":"","path":["Usage","Integration","One-liner Usage"],"tags":[]},{"location":"oneliner/#quick-model-generation-workflow","level":3,"title":"Quick model generation workflow","text":"<ol> <li>Copy a JSON Schema from documentation or an API response</li> <li>Run the generator from clipboard:</li> </ol> <pre><code># macOS\npbpaste | uvx datamodel-codegen --input-file-type jsonschema --output-model-type pydantic_v2.BaseModel\n\n# Linux\nxclip -selection clipboard -o | uvx datamodel-codegen --input-file-type jsonschema --output-model-type pydantic_v2.BaseModel\n\n# Windows PowerShell\nGet-Clipboard | uvx datamodel-codegen --input-file-type jsonschema --output-model-type pydantic_v2.BaseModel\n</code></pre>","path":["Usage","Integration","One-liner Usage"],"tags":[]},{"location":"oneliner/#generating-from-api-documentation","level":3,"title":"Generating from API documentation","text":"<pre><code># Fetch OpenAPI spec and generate models\ncurl -s https://petstore3.swagger.io/api/v3/openapi.json | \\\n  uvx datamodel-codegen --input-file-type openapi --output-model-type pydantic_v2.BaseModel --output petstore.py\n</code></pre>","path":["Usage","Integration","One-liner Usage"],"tags":[]},{"location":"oneliner/#generating-from-github-raw-urls","level":3,"title":"Generating from GitHub raw URLs","text":"<p>You can directly fetch schemas from GitHub repositories using raw URLs:</p> <pre><code># Fetch JSON Schema from GitHub and generate models\ncurl -s https://raw.githubusercontent.com/OAI/OpenAPI-Specification/main/schemas/v3.0/schema.json | \\\n  uvx datamodel-codegen --input-file-type jsonschema --output-model-type pydantic_v2.BaseModel\n\n# Fetch OpenAPI spec from a GitHub repository\ncurl -s https://raw.githubusercontent.com/github/rest-api-description/main/descriptions/api.github.com/api.github.com.json | \\\n  uvx datamodel-codegen --input-file-type openapi --output-model-type pydantic_v2.BaseModel --output github_api.py\n</code></pre> <p>Using the --url option</p> <p>If you have the <code>http</code> extra installed, you can use <code>--url</code> directly without curl:</p> <pre><code>uvx --from 'datamodel-code-generator[http]' datamodel-codegen \\\n  --url https://raw.githubusercontent.com/OAI/OpenAPI-Specification/main/schemas/v3.0/schema.json \\\n  --input-file-type jsonschema \\\n  --output-model-type pydantic_v2.BaseModel\n</code></pre>","path":["Usage","Integration","One-liner Usage"],"tags":[]},{"location":"oneliner/#using-with-jq-for-json-manipulation","level":3,"title":"Using with jq for JSON manipulation","text":"<pre><code># Extract a specific schema definition and generate a model\ncat openapi.yaml | yq '.components.schemas.User' | \\\n  uvx datamodel-codegen --input-file-type jsonschema\n</code></pre>","path":["Usage","Integration","One-liner Usage"],"tags":[]},{"location":"oneliner/#comparison-installation-methods","level":2,"title":"Comparison: Installation Methods","text":"Method Command Use Case uvx <code>uvx datamodel-codegen</code> One-liner usage, no installation pipx run <code>pipx run datamodel-code-generator</code> One-liner usage, alternative to uvx pipx install <code>pipx install datamodel-code-generator</code> Global installation, frequent usage uv add <code>uv add datamodel-code-generator</code> Project dependency pip install <code>pip install datamodel-code-generator</code> Traditional installation <p>When to use each method</p> <ul> <li>uvx/pipx run: Quick one-liner generation, testing different versions</li> <li>pipx install: Frequent CLI usage across multiple projects</li> <li>uv add/pip install: Project dependency, CI/CD pipelines, programmatic usage</li> </ul>","path":["Usage","Integration","One-liner Usage"],"tags":[]},{"location":"openapi-options/","level":1,"title":"OpenAPI-Specific Options","text":"","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#openapi-specific-options","level":1,"title":"OpenAPI-Specific Options","text":"<p>When working with OpenAPI specifications, datamodel-code-generator provides several options to control how schemas, operations, and special properties are handled. This page explains when and how to use each option.</p>","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#quick-overview","level":2,"title":"Quick Overview","text":"Option Description <code>--openapi-scopes</code> Select which parts of the spec to generate models from <code>--include-path-parameters</code> Include path parameters in generated models <code>--use-operation-id-as-name</code> Name models using operation IDs <code>--read-only-write-only-model-type</code> Generate separate models for read/write contexts <code>--validation</code> Enable OpenAPI validation constraints (deprecated)","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#-openapi-scopes","level":2,"title":"<code>--openapi-scopes</code>","text":"<p>Controls which sections of the OpenAPI specification to generate models from.</p> Scope Description <code>schemas</code> Generate from <code>#/components/schemas</code> (default) <code>parameters</code> Generate from <code>#/components/parameters</code> <code>paths</code> Generate from path operation parameters","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#default-behavior-schemas-only","level":3,"title":"Default behavior (schemas only)","text":"<pre><code>datamodel-codegen --input openapi.yaml --output models.py\n</code></pre> <p>Generates models only from <code>#/components/schemas</code>.</p>","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#include-parameters","level":3,"title":"Include parameters","text":"<pre><code>datamodel-codegen --input openapi.yaml --output models.py \\\n  --openapi-scopes schemas parameters\n</code></pre> <p>Also generates models from <code>#/components/parameters</code>.</p>","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#include-path-level-definitions","level":3,"title":"Include path-level definitions","text":"<pre><code>datamodel-codegen --input openapi.yaml --output models.py \\\n  --openapi-scopes schemas parameters paths\n</code></pre> <p>Generates models from all sources, including inline path operation parameters.</p>","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#when-to-use-each-scope","level":3,"title":"When to use each scope","text":"Use Case Recommended Scopes Basic model generation <code>schemas</code> (default) Reusable parameter types <code>schemas parameters</code> Complete API coverage <code>schemas parameters paths</code>","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#-include-path-parameters","level":2,"title":"<code>--include-path-parameters</code>","text":"<p>Includes path parameters as fields in generated models.</p>","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#openapi-example","level":3,"title":"OpenAPI Example","text":"<pre><code>paths:\n  /users/{user_id}/orders/{order_id}:\n    get:\n      operationId: getOrder\n      parameters:\n        - name: user_id\n          in: path\n          schema:\n            type: string\n        - name: order_id\n          in: path\n          schema:\n            type: integer\n</code></pre>","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#without-include-path-parameters","level":3,"title":"Without <code>--include-path-parameters</code>","text":"<pre><code>class GetOrderResponse(BaseModel):\n    # Only response body fields\n    items: list[Item]\n    total: float\n</code></pre>","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#with-include-path-parameters","level":3,"title":"With <code>--include-path-parameters</code>","text":"<pre><code>datamodel-codegen --input openapi.yaml --output models.py --include-path-parameters\n</code></pre> <pre><code>class GetOrderResponse(BaseModel):\n    user_id: str\n    order_id: int\n    items: list[Item]\n    total: float\n</code></pre>","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#when-to-use","level":3,"title":"When to use","text":"<ul> <li>Building request validation models that include URL parameters</li> <li>Creating unified request/response types for API clients</li> <li>Generating models for frameworks that expect all parameters in one object</li> </ul>","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#-use-operation-id-as-name","level":2,"title":"<code>--use-operation-id-as-name</code>","text":"<p>Uses the <code>operationId</code> from OpenAPI operations to name generated models instead of deriving names from paths.</p>","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#openapi-example_1","level":3,"title":"OpenAPI Example","text":"<pre><code>paths:\n  /users/{id}:\n    get:\n      operationId: getUserById\n      responses:\n        '200':\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  id: { type: integer }\n                  name: { type: string }\n</code></pre>","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#without-use-operation-id-as-name","level":3,"title":"Without <code>--use-operation-id-as-name</code>","text":"<pre><code>class UsersIdGetResponse(BaseModel):  # Derived from path\n    id: int\n    name: str\n</code></pre>","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#with-use-operation-id-as-name","level":3,"title":"With <code>--use-operation-id-as-name</code>","text":"<pre><code>datamodel-codegen --input openapi.yaml --output models.py --use-operation-id-as-name\n</code></pre> <pre><code>class GetUserByIdResponse(BaseModel):  # Uses operationId\n    id: int\n    name: str\n</code></pre>","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#when-to-use_1","level":3,"title":"When to use","text":"<ul> <li>When <code>operationId</code> values are well-designed and descriptive</li> <li>For consistency with generated API clients (e.g., OpenAPI Generator)</li> <li>When path-derived names are too verbose or unclear</li> </ul>","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#-read-only-write-only-model-type","level":2,"title":"<code>--read-only-write-only-model-type</code>","text":"<p>Generates separate model variants for properties marked as <code>readOnly</code> or <code>writeOnly</code> in OpenAPI.</p>","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#openapi-example_2","level":3,"title":"OpenAPI Example","text":"<pre><code>components:\n  schemas:\n    User:\n      type: object\n      properties:\n        id:\n          type: integer\n          readOnly: true        # Only in responses\n        password:\n          type: string\n          writeOnly: true       # Only in requests\n        name:\n          type: string          # In both\n</code></pre>","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#without-read-only-write-only-model-type","level":3,"title":"Without <code>--read-only-write-only-model-type</code>","text":"<pre><code>class User(BaseModel):\n    id: Optional[int] = None      # Both included\n    password: Optional[str] = None\n    name: Optional[str] = None\n</code></pre>","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#with-read-only-write-only-model-type","level":3,"title":"With <code>--read-only-write-only-model-type</code>","text":"<pre><code>datamodel-codegen --input openapi.yaml --output models.py \\\n  --read-only-write-only-model-type all\n</code></pre> <pre><code>class User(BaseModel):\n    \"\"\"Base model with all fields.\"\"\"\n    id: Optional[int] = None\n    password: Optional[str] = None\n    name: Optional[str] = None\n\nclass UserRead(BaseModel):\n    \"\"\"For responses - excludes writeOnly fields.\"\"\"\n    id: Optional[int] = None\n    name: Optional[str] = None\n\nclass UserWrite(BaseModel):\n    \"\"\"For requests - excludes readOnly fields.\"\"\"\n    password: Optional[str] = None\n    name: Optional[str] = None\n</code></pre>","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#values","level":3,"title":"Values","text":"Value Description <code>all</code> Generate both Read and Write variants <code>read</code> Generate only Read variants <code>write</code> Generate only Write variants","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#when-to-use_2","level":3,"title":"When to use","text":"<ul> <li>APIs with distinct request/response schemas</li> <li>Strict type checking for API clients</li> <li>When <code>readOnly</code>/<code>writeOnly</code> properties are heavily used</li> </ul>","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#-validation-deprecated","level":2,"title":"<code>--validation</code> (Deprecated)","text":"<p>Deprecated</p> <p>Use <code>--field-constraints</code> instead. The <code>--validation</code> option is maintained for backward compatibility.</p> <p>Enables validation constraints from OpenAPI schemas.</p> <pre><code># Deprecated\ndatamodel-codegen --input openapi.yaml --output models.py --validation\n\n# Recommended\ndatamodel-codegen --input openapi.yaml --output models.py --field-constraints\n</code></pre> <p>See Field Constraints for details.</p>","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#common-patterns","level":2,"title":"Common Patterns","text":"","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#pattern-1-basic-api-models","level":3,"title":"Pattern 1: Basic API models","text":"<p>For simple APIs where you only need schema models:</p> <pre><code>datamodel-codegen --input openapi.yaml --output models.py\n</code></pre>","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#pattern-2-full-api-client-models","level":3,"title":"Pattern 2: Full API client models","text":"<p>For generating complete models for an API client:</p> <pre><code>datamodel-codegen --input openapi.yaml --output models/ \\\n  --openapi-scopes schemas parameters paths \\\n  --use-operation-id-as-name \\\n  --include-path-parameters\n</code></pre>","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#pattern-3-strict-requestresponse-separation","level":3,"title":"Pattern 3: Strict request/response separation","text":"<p>For APIs with distinct input/output shapes:</p> <pre><code>datamodel-codegen --input openapi.yaml --output models/ \\\n  --read-only-write-only-model-type all \\\n  --field-constraints\n</code></pre>","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#pattern-4-versioned-api-structure","level":3,"title":"Pattern 4: Versioned API structure","text":"<p>For large APIs with versioned endpoints:</p> <pre><code>datamodel-codegen --input openapi.yaml --output models/ \\\n  --treat-dot-as-module \\\n  --use-operation-id-as-name \\\n  --all-exports-scope recursive\n</code></pre>","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#openapi-version-support","level":2,"title":"OpenAPI Version Support","text":"OpenAPI Version Support 3.0.x Full support 3.1.x Full support 2.0 (Swagger) Partial support","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi-options/#see-also","level":2,"title":"See Also","text":"<ul> <li>CLI Reference: OpenAPI-only Options</li> <li>Field Constraints</li> <li>Module Structure and Exports</li> <li>OpenAPI Input Format</li> </ul>","path":["Usage","Output Customization","OpenAPI-Specific Options"],"tags":[]},{"location":"openapi/","level":1,"title":"üìò Generate from OpenAPI","text":"<p>Generate Pydantic models from OpenAPI 3 schema definitions.</p>","path":["Usage","Input Formats","üìò Generate from OpenAPI"],"tags":[]},{"location":"openapi/#quick-start","level":2,"title":"üöÄ Quick Start","text":"<pre><code>datamodel-codegen --input api.yaml --input-file-type openapi --output model.py\n</code></pre>","path":["Usage","Input Formats","üìò Generate from OpenAPI"],"tags":[]},{"location":"openapi/#example","level":2,"title":"üìù Example","text":"api.yaml <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Error:\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n</code></pre> <p>‚ú® Generated model.py:</p> <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n</code></pre>","path":["Usage","Input Formats","üìò Generate from OpenAPI"],"tags":[]},{"location":"openapi/#readonly-writeonly-properties","level":2,"title":"üìñ readOnly / writeOnly Properties","text":"<p>OpenAPI 3.x supports <code>readOnly</code> and <code>writeOnly</code> property annotations:</p> <ul> <li>üì§ readOnly: Property is only returned in responses (e.g., <code>id</code>, <code>created_at</code>)</li> <li>üì• writeOnly: Property is only sent in requests (e.g., <code>password</code>)</li> </ul>","path":["Usage","Input Formats","üìò Generate from OpenAPI"],"tags":[]},{"location":"openapi/#option-read-only-write-only-model-type","level":3,"title":"‚öôÔ∏è Option: <code>--read-only-write-only-model-type</code>","text":"<p>This option generates separate Request/Response models based on these annotations.</p> Value Description (not set) Default. No special handling (backward compatible) <code>request-response</code> Generate only Request/Response models (no base model) <code>all</code> Generate base model + Request + Response models","path":["Usage","Input Formats","üìò Generate from OpenAPI"],"tags":[]},{"location":"openapi/#example-schema","level":3,"title":"üìã Example Schema","text":"<pre><code>openapi: \"3.0.0\"\ninfo:\n  title: User API\n  version: \"1.0\"\npaths: {}\ncomponents:\n  schemas:\n    User:\n      type: object\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          readOnly: true      # Server-generated, not in requests\n        name:\n          type: string\n        password:\n          type: string\n          writeOnly: true     # Client-only, not in responses\n        created_at:\n          type: string\n          format: date-time\n          readOnly: true\n</code></pre>","path":["Usage","Input Formats","üìò Generate from OpenAPI"],"tags":[]},{"location":"openapi/#generated-output","level":3,"title":"‚ú® Generated Output","text":"<pre><code>datamodel-codegen --input user.yaml --input-file-type openapi \\\n    --output-model-type pydantic_v2.BaseModel \\\n    --read-only-write-only-model-type all\n</code></pre> <pre><code>from pydantic import BaseModel\nfrom typing import Optional\nfrom datetime import datetime\n\n# üì• Request model: excludes readOnly fields (id, created_at)\nclass UserRequest(BaseModel):\n    name: str\n    password: Optional[str] = None\n\n# üì§ Response model: excludes writeOnly fields (password)\nclass UserResponse(BaseModel):\n    id: int\n    name: str\n    created_at: Optional[datetime] = None\n\n# üì¶ Base model: contains all fields\nclass User(BaseModel):\n    id: int\n    name: str\n    password: Optional[str] = None\n    created_at: Optional[datetime] = None\n</code></pre>","path":["Usage","Input Formats","üìò Generate from OpenAPI"],"tags":[]},{"location":"openapi/#usage-patterns","level":3,"title":"üéØ Usage Patterns","text":"Use Case Recommended Option Generated Models API client validation <code>request-response</code> <code>UserRequest</code>, <code>UserResponse</code> Database ORM mapping (not set) <code>User</code> Both client &amp; ORM <code>all</code> <code>User</code>, <code>UserRequest</code>, <code>UserResponse</code>","path":["Usage","Input Formats","üìò Generate from OpenAPI"],"tags":[]},{"location":"openapi/#behavior-with-allof-inheritance","level":3,"title":"üîó Behavior with allOf Inheritance","text":"<p>When using <code>allOf</code> with <code>$ref</code>, fields from all referenced schemas are flattened into Request/Response models:</p> <pre><code>components:\n  schemas:\n    Timestamps:\n      type: object\n      properties:\n        created_at:\n          type: string\n          format: date-time\n          readOnly: true\n\n    User:\n      allOf:\n        - $ref: \"#/components/schemas/Timestamps\"\n        - type: object\n          properties:\n            name:\n              type: string\n</code></pre> <p>Generated <code>UserRequest</code> will exclude <code>created_at</code> (readOnly from Timestamps).</p>","path":["Usage","Input Formats","üìò Generate from OpenAPI"],"tags":[]},{"location":"openapi/#collision-handling","level":3,"title":"‚ö†Ô∏è Collision Handling","text":"<p>If a schema named <code>UserRequest</code> or <code>UserResponse</code> already exists, the generated model will be named <code>UserRequestModel</code> or <code>UserResponseModel</code> to avoid conflicts.</p>","path":["Usage","Input Formats","üìò Generate from OpenAPI"],"tags":[]},{"location":"openapi/#supported-output-formats","level":3,"title":"üì§ Supported Output Formats","text":"<p>This option works with all output formats:</p> <ul> <li><code>pydantic.BaseModel</code> / <code>pydantic_v2.BaseModel</code></li> <li><code>dataclasses.dataclass</code></li> <li><code>typing.TypedDict</code></li> <li><code>msgspec.Struct</code></li> </ul>","path":["Usage","Input Formats","üìò Generate from OpenAPI"],"tags":[]},{"location":"openapi/#supported-ref-types","level":3,"title":"üîó Supported $ref Types","text":"<p>readOnly/writeOnly resolution works with local and file reference types:</p> Reference Type Example Support Local <code>#/components/schemas/User</code> ‚úÖ Supported File <code>./common.yaml#/User</code> ‚úÖ Supported","path":["Usage","Input Formats","üìò Generate from OpenAPI"],"tags":[]},{"location":"openapi/#see-also","level":2,"title":"üìñ See Also","text":"<ul> <li>üñ•Ô∏è CLI Reference: OpenAPI-only Options - All OpenAPI-specific CLI options</li> <li>‚öôÔ∏è CLI Reference: Base Options - Input/output configuration options</li> </ul>","path":["Usage","Input Formats","üìò Generate from OpenAPI"],"tags":[]},{"location":"pyproject_toml/","level":1,"title":"‚öôÔ∏è pyproject.toml Configuration","text":"","path":["Usage","Integration","‚öôÔ∏è pyproject.toml Configuration"],"tags":[]},{"location":"pyproject_toml/#pyprojecttoml-configuration","level":1,"title":"‚öôÔ∏è pyproject.toml Configuration","text":"<p>datamodel-code-generator can be configured using <code>pyproject.toml</code>. The tool automatically searches for <code>pyproject.toml</code> in the current directory and parent directories (stopping at the git repository root).</p>","path":["Usage","Integration","‚öôÔ∏è pyproject.toml Configuration"],"tags":[]},{"location":"pyproject_toml/#basic-usage","level":2,"title":"üöÄ Basic Usage","text":"<pre><code>[tool.datamodel-codegen]\ninput = \"schema.yaml\"\noutput = \"models.py\"\ntarget-python-version = \"3.11\"\nsnake-case-field = true\nfield-constraints = true\n</code></pre> <p>All CLI options can be used in <code>pyproject.toml</code> by converting them to kebab-case (e.g., <code>--snake-case-field</code> becomes <code>snake-case-field</code>).</p>","path":["Usage","Integration","‚öôÔ∏è pyproject.toml Configuration"],"tags":[]},{"location":"pyproject_toml/#named-profiles","level":2,"title":"üìã Named Profiles","text":"<p>You can define multiple named profiles for different use cases within a single project:</p> <pre><code>[tool.datamodel-codegen]\ntarget-python-version = \"3.9\"\nsnake-case-field = true\n\n[tool.datamodel-codegen.profiles.api]\ninput = \"schemas/api.yaml\"\noutput = \"src/models/api.py\"\ntarget-python-version = \"3.11\"\n\n[tool.datamodel-codegen.profiles.database]\ninput = \"schemas/db.json\"\noutput = \"src/models/db.py\"\ninput-file-type = \"jsonschema\"\n</code></pre> <p>Base settings in <code>[tool.datamodel-codegen]</code> are used when no profile is specified, and also serve as defaults for profiles.</p> <p>Use a profile with the <code>--profile</code> option:</p> <pre><code>datamodel-codegen --profile api\ndatamodel-codegen --profile database\n</code></pre>","path":["Usage","Integration","‚öôÔ∏è pyproject.toml Configuration"],"tags":[]},{"location":"pyproject_toml/#configuration-priority","level":2,"title":"üéØ Configuration Priority","text":"<p>Settings are applied in the following priority order (highest to lowest):</p> <ol> <li>üñ•Ô∏è CLI arguments - Always take precedence</li> <li>üìã Profile settings - From <code>[tool.datamodel-codegen.profiles.&lt;name&gt;]</code></li> <li>‚öôÔ∏è Base settings - From <code>[tool.datamodel-codegen]</code></li> <li>üîß Default values - Built-in defaults</li> </ol>","path":["Usage","Integration","‚öôÔ∏è pyproject.toml Configuration"],"tags":[]},{"location":"pyproject_toml/#merge-rules","level":2,"title":"üîÄ Merge Rules","text":"<p>When using profiles, settings are merged using shallow merge:</p> <ul> <li>Profile values completely replace base values (no deep merging)</li> <li>Settings not specified in the profile are inherited from the base configuration</li> <li>Lists and dictionaries are replaced entirely, not merged</li> </ul>","path":["Usage","Integration","‚öôÔ∏è pyproject.toml Configuration"],"tags":[]},{"location":"pyproject_toml/#example","level":3,"title":"üìù Example","text":"<pre><code>[tool.datamodel-codegen]\nstrict-types = [\"str\", \"int\"]\nhttp-headers = [\"Authorization: Bearer token\"]\n\n[tool.datamodel-codegen.profiles.api]\nstrict-types = [\"bytes\"]\n</code></pre> <p>When using <code>--profile api</code>:</p> <ul> <li><code>strict-types</code> becomes <code>[\"bytes\"]</code> (completely replaces base, not merged)</li> <li><code>http-headers</code> is inherited from base as <code>[\"Authorization: Bearer token\"]</code></li> </ul>","path":["Usage","Integration","‚öôÔ∏è pyproject.toml Configuration"],"tags":[]},{"location":"pyproject_toml/#ignoring-pyprojecttoml","level":2,"title":"üö´ Ignoring pyproject.toml","text":"<p>To ignore all <code>pyproject.toml</code> configuration and use only CLI arguments:</p> <pre><code>datamodel-codegen --ignore-pyproject --input schema.yaml --output models.py\n</code></pre>","path":["Usage","Integration","‚öôÔ∏è pyproject.toml Configuration"],"tags":[]},{"location":"pyproject_toml/#generating-configuration","level":2,"title":"üîß Generating Configuration","text":"<p>Generate a <code>pyproject.toml</code> configuration section from CLI arguments:</p> <pre><code>datamodel-codegen --input schema.yaml --output models.py --snake-case-field --generate-pyproject-config\n</code></pre> <p>‚ú® Output:</p> <pre><code>[tool.datamodel-codegen]\ninput = \"schema.yaml\"\noutput = \"models.py\"\nsnake-case-field = true\n</code></pre> <p>Generate CLI command from existing <code>pyproject.toml</code>:</p> <pre><code>datamodel-codegen --generate-cli-command\n</code></pre> <p>With a specific profile:</p> <pre><code>datamodel-codegen --profile api --generate-cli-command\n</code></pre>","path":["Usage","Integration","‚öôÔ∏è pyproject.toml Configuration"],"tags":[]},{"location":"pyproject_toml/#see-also","level":2,"title":"üìñ See Also","text":"<ul> <li>üñ•Ô∏è CLI Reference: <code>--ignore-pyproject</code> - Ignore pyproject.toml configuration</li> <li>üîß CLI Reference: <code>--generate-pyproject-config</code> - Generate pyproject.toml from CLI arguments</li> <li>üñ•Ô∏è CLI Reference: <code>--generate-cli-command</code> - Generate CLI command from pyproject.toml</li> </ul>","path":["Usage","Integration","‚öôÔ∏è pyproject.toml Configuration"],"tags":[]},{"location":"python-version-compatibility/","level":1,"title":"Python Version Compatibility","text":"","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#python-version-compatibility","level":1,"title":"Python Version Compatibility","text":"<p>datamodel-code-generator can generate code compatible with different Python versions. This page explains how to control type annotation syntax and imports for your target environment.</p>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#quick-overview","level":2,"title":"Quick Overview","text":"Option Description <code>--target-python-version</code> Set the minimum Python version for generated code <code>--use-union-operator</code> Use <code>X \\| Y</code> instead of <code>Union[X, Y]</code> <code>--use-standard-collections</code> Use <code>list</code>, <code>dict</code> instead of <code>List</code>, <code>Dict</code> <code>--use-annotated</code> Use <code>Annotated</code> for field metadata <code>--use-generic-container-types</code> Use generic types like <code>List[T]</code> <code>--disable-future-imports</code> Don't add <code>from __future__ import annotations</code>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#-target-python-version","level":2,"title":"<code>--target-python-version</code>","text":"<p>Sets the minimum Python version for the generated code. This automatically adjusts type annotation syntax.</p> Version Union Syntax Collection Syntax Notes 3.8 <code>Union[X, Y]</code> <code>List[T]</code>, <code>Dict[K, V]</code> Requires <code>typing</code> imports 3.9 <code>Union[X, Y]</code> <code>list[T]</code>, <code>dict[K, V]</code> Built-in generics available 3.10+ <code>X \\| Y</code> <code>list[T]</code>, <code>dict[K, V]</code> Union operator available","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#example-python-38","level":3,"title":"Example: Python 3.8","text":"<pre><code>datamodel-codegen --input schema.json --output models.py \\\n  --target-python-version 3.8\n</code></pre> <pre><code>from typing import List, Optional, Union\n\nclass User(BaseModel):\n    id: int\n    tags: List[str]\n    metadata: Optional[Union[str, int]] = None\n</code></pre>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#example-python-310","level":3,"title":"Example: Python 3.10+","text":"<pre><code>datamodel-codegen --input schema.json --output models.py \\\n  --target-python-version 3.10\n</code></pre> <pre><code>class User(BaseModel):\n    id: int\n    tags: list[str]\n    metadata: str | int | None = None\n</code></pre>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#-use-union-operator","level":2,"title":"<code>--use-union-operator</code>","text":"<p>Uses the <code>|</code> operator for union types instead of <code>Union[X, Y]</code>.</p>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#without-use-union-operator","level":3,"title":"Without <code>--use-union-operator</code>","text":"<pre><code>from typing import Union, Optional\n\nclass Item(BaseModel):\n    value: Union[str, int]\n    label: Optional[str] = None  # Same as Union[str, None]\n</code></pre>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#with-use-union-operator","level":3,"title":"With <code>--use-union-operator</code>","text":"<pre><code>datamodel-codegen --input schema.json --output models.py --use-union-operator\n</code></pre> <pre><code>class Item(BaseModel):\n    value: str | int\n    label: str | None = None\n</code></pre>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#compatibility-note","level":3,"title":"Compatibility Note","text":"<p>The union operator <code>|</code> requires: - Python 3.10+ at runtime, OR - <code>from __future__ import annotations</code> (Python 3.7+) for postponed evaluation</p>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#-use-standard-collections","level":2,"title":"<code>--use-standard-collections</code>","text":"<p>Uses built-in collection types instead of <code>typing</code> module generics.</p>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#without-use-standard-collections","level":3,"title":"Without <code>--use-standard-collections</code>","text":"<pre><code>from typing import List, Dict, Set, Tuple\n\nclass Data(BaseModel):\n    items: List[str]\n    mapping: Dict[str, int]\n    unique: Set[str]\n    pair: Tuple[str, int]\n</code></pre>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#with-use-standard-collections","level":3,"title":"With <code>--use-standard-collections</code>","text":"<pre><code>datamodel-codegen --input schema.json --output models.py --use-standard-collections\n</code></pre> <pre><code>class Data(BaseModel):\n    items: list[str]\n    mapping: dict[str, int]\n    unique: set[str]\n    pair: tuple[str, int]\n</code></pre>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#compatibility-note_1","level":3,"title":"Compatibility Note","text":"<p>Built-in generic syntax requires: - Python 3.9+ at runtime, OR - <code>from __future__ import annotations</code> (Python 3.7+)</p>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#-use-annotated","level":2,"title":"<code>--use-annotated</code>","text":"<p>Uses <code>typing.Annotated</code> to attach metadata to types, which is the modern approach for Pydantic v2.</p>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#without-use-annotated","level":3,"title":"Without <code>--use-annotated</code>","text":"<pre><code>from pydantic import Field\n\nclass User(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    age: int = Field(..., ge=0, le=150)\n</code></pre>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#with-use-annotated","level":3,"title":"With <code>--use-annotated</code>","text":"<pre><code>datamodel-codegen --input schema.json --output models.py --use-annotated\n</code></pre> <pre><code>from typing import Annotated\nfrom pydantic import Field\n\nclass User(BaseModel):\n    name: Annotated[str, Field(min_length=1, max_length=100)]\n    age: Annotated[int, Field(ge=0, le=150)]\n</code></pre>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#benefits","level":3,"title":"Benefits","text":"<ul> <li>Cleaner separation of type and constraints</li> <li>Better IDE support</li> <li>More compatible with other tools that understand <code>Annotated</code></li> <li>Required types are more explicit</li> </ul>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#-use-generic-container-types","level":2,"title":"<code>--use-generic-container-types</code>","text":"<p>Uses generic container types from <code>typing</code> module explicitly.</p> <pre><code>datamodel-codegen --input schema.json --output models.py --use-generic-container-types\n</code></pre> <pre><code>from typing import List, Dict, Set\n\nclass Data(BaseModel):\n    items: List[str]\n    mapping: Dict[str, int]\n</code></pre> <p>This is useful when: - Targeting Python 3.8 or earlier - Working with tools that require explicit <code>typing</code> imports - Maintaining compatibility with legacy codebases</p>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#-disable-future-imports","level":2,"title":"<code>--disable-future-imports</code>","text":"<p>Prevents adding <code>from __future__ import annotations</code> to generated files.</p>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#default-behavior-with-future-imports","level":3,"title":"Default behavior (with future imports)","text":"<pre><code>from __future__ import annotations\n\nclass User(BaseModel):\n    friends: list[User]  # Forward reference works due to PEP 563\n</code></pre>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#with-disable-future-imports","level":3,"title":"With <code>--disable-future-imports</code>","text":"<pre><code>datamodel-codegen --input schema.json --output models.py --disable-future-imports\n</code></pre> <pre><code>from typing import List, TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from typing import ForwardRef\n\nclass User(BaseModel):\n    friends: List[\"User\"]  # String forward reference\n</code></pre>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#when-to-disable","level":3,"title":"When to disable","text":"<ul> <li>Compatibility with runtime annotation inspection</li> <li>Libraries that don't support <code>__future__.annotations</code></li> <li>Pydantic v1 in some configurations</li> <li>When using <code>get_type_hints()</code> at runtime</li> </ul>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#common-patterns","level":2,"title":"Common Patterns","text":"","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#pattern-1-modern-python-310","level":3,"title":"Pattern 1: Modern Python (3.10+)","text":"<p>For projects targeting Python 3.10 or later:</p> <pre><code>datamodel-codegen --input schema.json --output models.py \\\n  --target-python-version 3.10 \\\n  --use-union-operator \\\n  --use-standard-collections \\\n  --use-annotated\n</code></pre> <p>Output: <pre><code>from typing import Annotated\nfrom pydantic import BaseModel, Field\n\nclass User(BaseModel):\n    id: int\n    name: Annotated[str, Field(min_length=1)]\n    tags: list[str]\n    metadata: dict[str, str] | None = None\n</code></pre></p>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#pattern-2-legacy-python-38","level":3,"title":"Pattern 2: Legacy Python (3.8)","text":"<p>For projects requiring Python 3.8 compatibility:</p> <pre><code>datamodel-codegen --input schema.json --output models.py \\\n  --target-python-version 3.8 \\\n  --use-generic-container-types \\\n  --disable-future-imports\n</code></pre> <p>Output: <pre><code>from typing import Dict, List, Optional, Union\n\nclass User(BaseModel):\n    id: int\n    name: str\n    tags: List[str]\n    metadata: Optional[Dict[str, str]] = None\n</code></pre></p>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#pattern-3-maximum-compatibility","level":3,"title":"Pattern 3: Maximum compatibility","text":"<p>For libraries that need to work across multiple Python versions:</p> <pre><code>datamodel-codegen --input schema.json --output models.py \\\n  --target-python-version 3.8\n</code></pre> <p>The generator will use <code>from __future__ import annotations</code> to enable modern syntax while maintaining runtime compatibility.</p>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#pattern-4-cicd-consistency","level":3,"title":"Pattern 4: CI/CD consistency","text":"<p>Pin the Python version in <code>pyproject.toml</code> to ensure consistent output:</p> <pre><code>[tool.datamodel-codegen]\ntarget-python-version = \"3.10\"\nuse-union-operator = true\nuse-standard-collections = true\nuse-annotated = true\n</code></pre>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#version-feature-matrix","level":2,"title":"Version Feature Matrix","text":"Feature 3.8 3.9 3.10 3.11+ <code>list[T]</code> syntax via <code>__future__</code> native native native <code>X \\| Y</code> union via <code>__future__</code> via <code>__future__</code> native native <code>Annotated</code> <code>typing_extensions</code> native native native <code>TypeAlias</code> <code>typing_extensions</code> native native native <code>Self</code> <code>typing_extensions</code> <code>typing_extensions</code> <code>typing_extensions</code> native","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#troubleshooting","level":2,"title":"Troubleshooting","text":"","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#typeerror-type-object-is-not-subscriptable","level":3,"title":"TypeError: 'type' object is not subscriptable","text":"<p>This occurs when using <code>list[T]</code> syntax on Python &lt; 3.9 without <code>__future__</code> imports.</p> <p>Solution: Either use <code>--target-python-version 3.8</code> or ensure <code>from __future__ import annotations</code> is present.</p>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#pydantic-validation-fails-with-forward-references","level":3,"title":"Pydantic validation fails with forward references","text":"<p>This can happen when <code>__future__.annotations</code> interacts poorly with Pydantic's type resolution.</p> <p>Solution: Try <code>--disable-future-imports</code> or update to Pydantic v2.</p>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#ide-shows-type-errors","level":3,"title":"IDE shows type errors","text":"<p>Some IDEs don't fully understand <code>from __future__ import annotations</code>.</p> <p>Solution: Configure your IDE's Python version or use explicit type syntax matching your runtime version.</p>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"python-version-compatibility/#see-also","level":2,"title":"See Also","text":"<ul> <li>CLI Reference: <code>--target-python-version</code></li> <li>CLI Reference: <code>--use-union-operator</code></li> <li>CLI Reference: <code>--use-standard-collections</code></li> <li>CLI Reference: <code>--use-annotated</code></li> <li>Output Model Types</li> <li>Type Mappings and Custom Types</li> <li>CI/CD Integration</li> </ul>","path":["Usage","Output Customization","Python Version Compatibility"],"tags":[]},{"location":"root-model-and-type-alias/","level":1,"title":"üì¶ Root Models and Type Aliases","text":"<p>When a schema defines a simple type (not an object with properties), <code>datamodel-code-generator</code> creates a root model. If you don't want to introduce a new level of attribute access (<code>.root</code>) or want to use generated types as plain Python types in non-Pydantic code, you can use the <code>--use-type-alias</code> flag to generate type aliases instead of root models.</p>","path":["Usage","Output Customization","üì¶ Root Models and Type Aliases"],"tags":[]},{"location":"root-model-and-type-alias/#notes-and-limitations","level":2,"title":"‚ö†Ô∏è Notes and Limitations","text":"<p>This functionality is experimental! Here are a few known issues:</p> <ul> <li>üìå RootModel and type aliases do not fully support field-specific metadata (default, alias, etc). See Named Type Aliases for details.</li> <li>üö´ Type aliases do not support some RootModel features (e.g. <code>model_config</code>)</li> <li>üìÑ A RootModel or type alias is also generated for the main schema, allowing you to define a single type alias from a schema file (e.g. <code>model.json</code> containing <code>{\"title\": \"MyString\", \"type\": \"string\"}</code>)</li> <li>‚ùå Type aliases cannot be combined with <code>Annotated</code> for Pydantic v1</li> </ul>","path":["Usage","Output Customization","üì¶ Root Models and Type Aliases"],"tags":[]},{"location":"root-model-and-type-alias/#type-alias-behavior-by-output-type-and-python-version","level":2,"title":"üìä Type Alias Behavior by Output Type and Python Version","text":"<p>The type of type alias generated depends on the output model type and target Python version:</p> Output Type Python 3.12+ Python 3.10-3.11 Python 3.9 Pydantic v2 <code>type</code> statement <code>TypeAliasType</code> (typing_extensions) <code>TypeAliasType</code> (typing_extensions) Pydantic v1 <code>TypeAlias</code> <code>TypeAlias</code> <code>TypeAlias</code> (typing_extensions) TypedDict <code>type</code> statement <code>TypeAlias</code> <code>TypeAlias</code> (typing_extensions) dataclasses <code>type</code> statement <code>TypeAlias</code> <code>TypeAlias</code> (typing_extensions) msgspec <code>type</code> statement <code>TypeAlias</code> <code>TypeAlias</code> (typing_extensions)","path":["Usage","Output Customization","üì¶ Root Models and Type Aliases"],"tags":[]},{"location":"root-model-and-type-alias/#why-the-difference","level":3,"title":"ü§î Why the difference?","text":"<ul> <li>Pydantic v2 requires <code>TypeAliasType</code> because it cannot properly handle <code>TypeAlias</code> annotations</li> <li>Other output types (TypedDict, dataclasses, msgspec) use <code>TypeAlias</code> for better compatibility with libraries that may not expect <code>TypeAliasType</code> objects</li> <li>Python 3.12+ uses the native <code>type</code> statement for all output types</li> </ul>","path":["Usage","Output Customization","üì¶ Root Models and Type Aliases"],"tags":[]},{"location":"root-model-and-type-alias/#example","level":2,"title":"üìù Example","text":"","path":["Usage","Output Customization","üì¶ Root Models and Type Aliases"],"tags":[]},{"location":"root-model-and-type-alias/#modeljson","level":3,"title":"model.json","text":"<pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"definitions\": {\n    \"UserId\": {\n      \"type\": \"string\"\n    },\n    \"Status\": {\n      \"anyOf\": [\n        {\"type\": \"string\"},\n        {\"type\": \"integer\"}\n      ]\n    },\n    \"User\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"id\": {\"$ref\": \"#/definitions/UserId\"},\n        \"status\": {\"$ref\": \"#/definitions/Status\"}\n      }\n    }\n  }\n}\n</code></pre>","path":["Usage","Output Customization","üì¶ Root Models and Type Aliases"],"tags":[]},{"location":"root-model-and-type-alias/#pydantic-v1","level":3,"title":"üîπ Pydantic v1","text":"","path":["Usage","Output Customization","üì¶ Root Models and Type Aliases"],"tags":[]},{"location":"root-model-and-type-alias/#generating-rootmodel","level":4,"title":"Generating RootModel","text":"<pre><code>datamodel-codegen --input model.json --input-file-type jsonschema --output model.py\n</code></pre>","path":["Usage","Output Customization","üì¶ Root Models and Type Aliases"],"tags":[]},{"location":"root-model-and-type-alias/#generated-modelpy-pydantic-v1","level":3,"title":"‚ú® Generated model.py (Pydantic v1)","text":"<pre><code># generated by datamodel-codegen:\n#   filename:  model.json\n\nfrom __future__ import annotations\n\nfrom typing import Any, Optional, Union\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    __root__: Any\n\n\nclass UserId(BaseModel):\n    __root__: str\n\n\nclass Status(BaseModel):\n    __root__: Union[str, int]\n\n\nclass User(BaseModel):\n    id: Optional[UserId] = None\n    status: Optional[Status] = None\n</code></pre>","path":["Usage","Output Customization","üì¶ Root Models and Type Aliases"],"tags":[]},{"location":"root-model-and-type-alias/#generating-typealias-annotation","level":4,"title":"Generating TypeAlias annotation","text":"<pre><code>datamodel-codegen --input model.json --input-file-type jsonschema --use-type-alias --output model.py\n</code></pre>","path":["Usage","Output Customization","üì¶ Root Models and Type Aliases"],"tags":[]},{"location":"root-model-and-type-alias/#generated-modelpy-python-310","level":3,"title":"‚ú® Generated model.py (Python 3.10+)","text":"<pre><code># generated by datamodel-codegen:\n#   filename:  model.json\n\nfrom __future__ import annotations\n\nfrom typing import Any, Optional, TypeAlias, Union\n\nfrom pydantic import BaseModel\n\nModel: TypeAlias = Any\n\n\nUserId: TypeAlias = str\n\n\nStatus: TypeAlias = Union[str, int]\n\n\nclass User(BaseModel):\n    id: Optional[UserId] = None\n    status: Optional[Status] = None\n</code></pre>","path":["Usage","Output Customization","üì¶ Root Models and Type Aliases"],"tags":[]},{"location":"root-model-and-type-alias/#pydantic-v2","level":3,"title":"üî∏ Pydantic v2","text":"","path":["Usage","Output Customization","üì¶ Root Models and Type Aliases"],"tags":[]},{"location":"root-model-and-type-alias/#generating-rootmodel_1","level":4,"title":"Generating RootModel","text":"<pre><code>datamodel-codegen --input model.json --input-file-type jsonschema --output-model-type pydantic_v2.BaseModel --output model.py\n</code></pre>","path":["Usage","Output Customization","üì¶ Root Models and Type Aliases"],"tags":[]},{"location":"root-model-and-type-alias/#generated-modelpy-pydantic-v2","level":3,"title":"‚ú® Generated model.py (Pydantic v2)","text":"<pre><code># generated by datamodel-codegen:\n#   filename:  model.json\n\nfrom __future__ import annotations\n\nfrom typing import Any, Optional, Union\n\nfrom pydantic import BaseModel, RootModel\n\n\nclass Model(RootModel[Any]):\n    root: Any\n\n\nclass UserId(RootModel[str]):\n    root: str\n\n\nclass Status(RootModel[Union[str, int]]):\n    root: Union[str, int]\n\n\nclass User(BaseModel):\n    id: Optional[UserId] = None\n    status: Optional[Status] = None\n</code></pre>","path":["Usage","Output Customization","üì¶ Root Models and Type Aliases"],"tags":[]},{"location":"root-model-and-type-alias/#generating-type-statement-python-312","level":4,"title":"Generating type statement (Python 3.12+)","text":"<pre><code>datamodel-codegen --input model.json --input-file-type jsonschema --output-model-type pydantic_v2.BaseModel --use-type-alias --target-python-version 3.12 --output model.py\n</code></pre>","path":["Usage","Output Customization","üì¶ Root Models and Type Aliases"],"tags":[]},{"location":"root-model-and-type-alias/#generated-modelpy-python-312-type-statement","level":3,"title":"‚ú® Generated model.py (Python 3.12+ type statement)","text":"<pre><code># generated by datamodel-codegen:\n#   filename:  model.json\n\nfrom __future__ import annotations\n\nfrom typing import Any, Optional, Union\n\nfrom pydantic import BaseModel\n\ntype Model = Any\n\n\ntype UserId = str\n\n\ntype Status = Union[str, int]\n\n\nclass User(BaseModel):\n    id: Optional[UserId] = None\n    status: Optional[Status] = None\n</code></pre>","path":["Usage","Output Customization","üì¶ Root Models and Type Aliases"],"tags":[]},{"location":"root-model-and-type-alias/#see-also","level":2,"title":"üìñ See Also","text":"<ul> <li>üñ•Ô∏è CLI Reference: <code>--use-type-alias</code> - Detailed CLI option documentation</li> <li>üéØ CLI Reference: <code>--target-python-version</code> - Control Python version-specific syntax</li> </ul>","path":["Usage","Output Customization","üì¶ Root Models and Type Aliases"],"tags":[]},{"location":"supported-data-types/","level":1,"title":"üìö Supported Input Formats","text":"<p>This code generator supports the following input formats:</p> <ul> <li>OpenAPI 3 (YAML/JSON, OpenAPI Data Type);</li> <li>JSON Schema (JSON Schema Core /JSON Schema Validation);</li> <li>JSON/YAML Data (it will be converted to JSON Schema);</li> <li>Python dictionary (it will be converted to JSON Schema);</li> <li>GraphQL schema (GraphQL Schemas and Types);</li> </ul>","path":["üìö Supported Input Formats"],"tags":[]},{"location":"supported-data-types/#openapi-3-and-json-schema","level":2,"title":"üìò OpenAPI 3 and JSON Schema","text":"<p>Below are the data types and features recognized by datamodel-code-generator for OpenAPI 3 and JSON Schema.</p>","path":["üìö Supported Input Formats"],"tags":[]},{"location":"supported-data-types/#implemented-data-types-and-features","level":2,"title":"‚úÖ Implemented data types and features","text":"","path":["üìö Supported Input Formats"],"tags":[]},{"location":"supported-data-types/#data-types","level":3,"title":"üìä Data Types","text":"<ul> <li>string (supported keywords: pattern/minLength/maxLength)</li> <li>number (supported keywords: maximum/exclusiveMaximum/minimum/exclusiveMinimum/multipleOf)</li> <li>integer (supported keywords: maximum/exclusiveMaximum/minimum/exclusiveMinimum/multipleOf)</li> <li>boolean</li> <li>array</li> <li>object</li> </ul>","path":["üìö Supported Input Formats"],"tags":[]},{"location":"supported-data-types/#string-formats","level":3,"title":"üìù String Formats","text":"<ul> <li>date</li> <li>datetime</li> <li>time</li> <li>password</li> <li>email</li> <li>idn-email</li> <li>path</li> <li>uuid (uuid1/uuid2/uuid3/uuid4/uuid5)</li> <li>ipv4</li> <li>ipv6</li> <li>hostname</li> <li>decimal</li> <li>uri</li> </ul>","path":["üìö Supported Input Formats"],"tags":[]},{"location":"supported-data-types/#other-schema","level":3,"title":"üîó Other schema","text":"<ul> <li>enum (as enum.Enum or typing.Literal)</li> <li>allOf (as Multiple inheritance)</li> <li>anyOf (as typing.Union)</li> <li>oneOf (as typing.Union)</li> <li>$ref (http extra is required when resolving $ref for remote files.)</li> <li>$id (for JSONSchema)</li> </ul>","path":["üìö Supported Input Formats"],"tags":[]},{"location":"type-mappings/","level":1,"title":"Type Mappings and Custom Types","text":"","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#type-mappings-and-custom-types","level":1,"title":"Type Mappings and Custom Types","text":"<p>datamodel-code-generator allows you to customize how schema types are mapped to Python types. This is essential for projects with specific type requirements, datetime handling preferences, or third-party library integrations.</p>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#quick-overview","level":2,"title":"Quick Overview","text":"Option Description <code>--type-mappings</code> Map schema types to custom Python types <code>--strict-types</code> Use Pydantic strict types for validation <code>--output-datetime-class</code> Choose datetime output type <code>--use-pendulum</code> Use Pendulum library for datetime types <code>--use-decimal-for-multiple-of</code> Use Decimal for multipleOf constraints","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#-type-mappings","level":2,"title":"<code>--type-mappings</code>","text":"<p>Maps schema types to custom Python types. This is the most flexible way to customize type output.</p>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#format","level":3,"title":"Format","text":"<pre><code>--type-mappings &lt;schema_type&gt;=&lt;python_type&gt; [&lt;schema_type&gt;=&lt;python_type&gt; ...]\n</code></pre>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#basic-examples","level":3,"title":"Basic Examples","text":"<pre><code># Map string format to custom type\ndatamodel-codegen --input schema.json --output models.py \\\n  --type-mappings \"string+uri=pydantic.HttpUrl\"\n\n# Map integer to custom ID type\ndatamodel-codegen --input schema.json --output models.py \\\n  --type-mappings \"integer=myproject.types.ID\"\n\n# Multiple mappings\ndatamodel-codegen --input schema.json --output models.py \\\n  --type-mappings \"string+date-time=datetime.datetime\" \"string+uri=str\"\n</code></pre>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#mapping-syntax","level":3,"title":"Mapping Syntax","text":"Syntax Description Example <code>type</code> Map base type <code>integer=int</code> <code>type+format</code> Map type with format <code>string+uuid=uuid.UUID</code> <code>type+format+pattern</code> Map with pattern <code>string++^[A-Z]{2}$=CountryCode</code>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#common-mappings","level":3,"title":"Common Mappings","text":"<pre><code># Use AwareDatetime for timezone-aware datetimes\n--type-mappings \"string+date-time=pydantic.AwareDatetime\"\n\n# Use custom Email type\n--type-mappings \"string+email=myapp.types.Email\"\n\n# Use pathlib.Path for file paths\n--type-mappings \"string+uri-reference=pathlib.Path\"\n\n# Use Decimal for money\n--type-mappings \"number=decimal.Decimal\"\n</code></pre>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#pyprojecttoml-configuration","level":3,"title":"pyproject.toml Configuration","text":"<pre><code>[tool.datamodel-codegen]\ntype-mappings = [\n    \"string+date-time=datetime.datetime\",\n    \"string+uuid=uuid.UUID\",\n    \"number=decimal.Decimal\",\n]\n</code></pre>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#-strict-types","level":2,"title":"<code>--strict-types</code>","text":"<p>Generates Pydantic strict types that don't perform type coercion during validation.</p>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#available-strict-types","level":3,"title":"Available Strict Types","text":"Value Strict Type Rejects <code>str</code> <code>StrictStr</code> Integers, floats <code>int</code> <code>StrictInt</code> Strings, floats <code>float</code> <code>StrictFloat</code> Strings, integers <code>bool</code> <code>StrictBool</code> Strings, integers <code>bytes</code> <code>StrictBytes</code> Strings","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#without-strict-types","level":3,"title":"Without <code>--strict-types</code>","text":"<pre><code>class User(BaseModel):\n    id: int        # Accepts \"123\" and converts to 123\n    name: str      # Accepts 123 and converts to \"123\"\n    active: bool   # Accepts 1 and converts to True\n</code></pre>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#with-strict-types","level":3,"title":"With <code>--strict-types</code>","text":"<pre><code>datamodel-codegen --input schema.json --output models.py \\\n  --strict-types str int bool\n</code></pre> <pre><code>from pydantic import StrictBool, StrictInt, StrictStr\n\nclass User(BaseModel):\n    id: StrictInt      # Rejects \"123\", requires integer\n    name: StrictStr    # Rejects 123, requires string\n    active: StrictBool # Rejects 1, requires boolean\n</code></pre>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#when-to-use","level":3,"title":"When to use","text":"<ul> <li>API validation where type coercion is undesirable</li> <li>Data pipelines requiring exact types</li> <li>Security-sensitive applications</li> <li>Testing environments requiring strict type checking</li> </ul>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#-output-datetime-class","level":2,"title":"<code>--output-datetime-class</code>","text":"<p>Controls the Python type used for <code>date-time</code> formatted strings.</p> Value Output Type Description <code>datetime</code> <code>datetime.datetime</code> Standard library datetime (default) <code>AwareDatetime</code> <code>pydantic.AwareDatetime</code> Requires timezone info <code>NaiveDatetime</code> <code>pydantic.NaiveDatetime</code> Rejects timezone info","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#default-behavior","level":3,"title":"Default behavior","text":"<pre><code>from datetime import datetime\n\nclass Event(BaseModel):\n    created_at: datetime  # Accepts both aware and naive\n</code></pre>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#awaredatetime-recommended-for-apis","level":3,"title":"AwareDatetime (recommended for APIs)","text":"<pre><code>datamodel-codegen --input schema.json --output models.py \\\n  --output-datetime-class AwareDatetime\n</code></pre> <pre><code>from pydantic import AwareDatetime\n\nclass Event(BaseModel):\n    created_at: AwareDatetime  # Requires timezone, e.g., 2024-01-01T00:00:00Z\n</code></pre>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#naivedatetime","level":3,"title":"NaiveDatetime","text":"<pre><code>datamodel-codegen --input schema.json --output models.py \\\n  --output-datetime-class NaiveDatetime\n</code></pre> <pre><code>from pydantic import NaiveDatetime\n\nclass Event(BaseModel):\n    created_at: NaiveDatetime  # Rejects timezone, e.g., 2024-01-01T00:00:00\n</code></pre>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#when-to-use-each","level":3,"title":"When to use each","text":"Use Case Recommended Class REST APIs <code>AwareDatetime</code> Database models <code>datetime</code> or <code>NaiveDatetime</code> Logs with UTC timestamps <code>AwareDatetime</code> Local time applications <code>NaiveDatetime</code>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#-use-pendulum","level":2,"title":"<code>--use-pendulum</code>","text":"<p>Uses Pendulum library types instead of standard library datetime.</p> <pre><code>pip install pendulum\ndatamodel-codegen --input schema.json --output models.py --use-pendulum\n</code></pre>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#output","level":3,"title":"Output","text":"<pre><code>import pendulum\n\nclass Event(BaseModel):\n    created_at: pendulum.DateTime\n    date: pendulum.Date\n    time: pendulum.Time\n</code></pre>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#benefits-of-pendulum","level":3,"title":"Benefits of Pendulum","text":"<ul> <li>Timezone handling is simpler and more intuitive</li> <li>Human-friendly datetime manipulation</li> <li>Better serialization defaults</li> <li>Immutable by default</li> </ul>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#when-to-use_1","level":3,"title":"When to use","text":"<ul> <li>Projects already using Pendulum</li> <li>Applications requiring complex datetime manipulation</li> <li>When timezone handling is a priority</li> </ul>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#-use-decimal-for-multiple-of","level":2,"title":"<code>--use-decimal-for-multiple-of</code>","text":"<p>Uses <code>Decimal</code> type for numbers with <code>multipleOf</code> constraints to avoid floating-point precision issues.</p>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#the-problem","level":3,"title":"The Problem","text":"<pre><code>properties:\n  price:\n    type: number\n    multipleOf: 0.01  # Currency precision\n</code></pre> <p>Without this option, floating-point arithmetic can cause validation issues:</p> <pre><code># 0.1 + 0.2 = 0.30000000000000004 in floating-point\nprice = 0.30000000000000004  # May fail multipleOf validation\n</code></pre>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#solution","level":3,"title":"Solution","text":"<pre><code>datamodel-codegen --input schema.json --output models.py \\\n  --use-decimal-for-multiple-of\n</code></pre> <pre><code>from decimal import Decimal\n\nclass Product(BaseModel):\n    price: Decimal  # Exact decimal arithmetic\n</code></pre>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#when-to-use_2","level":3,"title":"When to use","text":"<ul> <li>Financial applications</li> <li>Scientific calculations requiring precision</li> <li>Any schema with <code>multipleOf</code> constraints</li> </ul>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#common-patterns","level":2,"title":"Common Patterns","text":"","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#pattern-1-financial-application","level":3,"title":"Pattern 1: Financial application","text":"<pre><code>datamodel-codegen --input schema.json --output models.py \\\n  --use-decimal-for-multiple-of \\\n  --type-mappings \"number=decimal.Decimal\" \\\n  --strict-types str int\n</code></pre>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#pattern-2-strict-api-validation","level":3,"title":"Pattern 2: Strict API validation","text":"<pre><code>datamodel-codegen --input schema.json --output models.py \\\n  --strict-types str int float bool \\\n  --output-datetime-class AwareDatetime \\\n  --field-constraints\n</code></pre>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#pattern-3-custom-type-library","level":3,"title":"Pattern 3: Custom type library","text":"<pre><code>datamodel-codegen --input schema.json --output models.py \\\n  --type-mappings \\\n    \"string+email=myapp.types.Email\" \\\n    \"string+uri=myapp.types.URL\" \\\n    \"integer=myapp.types.ID\"\n</code></pre>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#pattern-4-pendulum-datetime-handling","level":3,"title":"Pattern 4: Pendulum datetime handling","text":"<pre><code>datamodel-codegen --input schema.json --output models.py \\\n  --use-pendulum \\\n  --strict-types str int\n</code></pre>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#type-mapping-reference","level":2,"title":"Type Mapping Reference","text":"","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#common-format-mappings","level":3,"title":"Common Format Mappings","text":"Schema Format Default Type Common Custom Mapping <code>date-time</code> <code>datetime</code> <code>pydantic.AwareDatetime</code>, <code>pendulum.DateTime</code> <code>date</code> <code>date</code> <code>pendulum.Date</code> <code>time</code> <code>time</code> <code>pendulum.Time</code> <code>uuid</code> <code>UUID</code> <code>str</code> <code>email</code> <code>EmailStr</code> <code>str</code>, custom Email class <code>uri</code> <code>AnyUrl</code> <code>str</code>, <code>pydantic.HttpUrl</code> <code>binary</code> <code>bytes</code> <code>str</code> (base64-encoded)","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"type-mappings/#see-also","level":2,"title":"See Also","text":"<ul> <li>CLI Reference: <code>--type-mappings</code></li> <li>CLI Reference: <code>--strict-types</code></li> <li>CLI Reference: <code>--output-datetime-class</code></li> <li>CLI Reference: <code>--use-pendulum</code></li> <li>Field Constraints</li> <li>Python Version Compatibility</li> </ul>","path":["Usage","Output Customization","Type Mappings and Custom Types"],"tags":[]},{"location":"using_as_module/","level":1,"title":"üêç Using datamodel-code-generator as a Module","text":"<p>datamodel-code-generator is a CLI tool, but it can also be used as a Python module.</p>","path":["Usage","Integration","üêç Using datamodel-code-generator as a Module"],"tags":[]},{"location":"using_as_module/#how-to-use","level":2,"title":"üöÄ How to Use","text":"<p>You can generate models with <code>datamodel_code_generator.generate</code> using parameters that match the CLI arguments. The generated files can be written to and read from the <code>Path</code> object supplied to output.</p> <p>In the below example, we use a file in a <code>TemporaryDirectory</code> to store our output.</p>","path":["Usage","Integration","üêç Using datamodel-code-generator as a Module"],"tags":[]},{"location":"using_as_module/#installation","level":3,"title":"üì¶ Installation","text":"<pre><code>pip install 'datamodel-code-generator[http]'\n</code></pre>","path":["Usage","Integration","üêç Using datamodel-code-generator as a Module"],"tags":[]},{"location":"using_as_module/#example","level":3,"title":"üìù Example","text":"<pre><code>from pathlib import Path\nfrom tempfile import TemporaryDirectory\nfrom datamodel_code_generator import InputFileType, generate\nfrom datamodel_code_generator import DataModelType\n\njson_schema: str = \"\"\"{\n    \"type\": \"object\",\n    \"properties\": {\n        \"number\": {\"type\": \"number\"},\n        \"street_name\": {\"type\": \"string\"},\n        \"street_type\": {\"type\": \"string\",\n                        \"enum\": [\"Street\", \"Avenue\", \"Boulevard\"]\n                        }\n    }\n}\"\"\"\n\nwith TemporaryDirectory() as temporary_directory_name:\n    temporary_directory = Path(temporary_directory_name)\n    output = Path(temporary_directory / 'model.py')\n    generate(\n        json_schema,\n        input_file_type=InputFileType.JsonSchema,\n        input_filename=\"example.json\",\n        output=output,\n        # set up the output model types\n        output_model_type=DataModelType.PydanticV2BaseModel,\n    )\n    model: str = output.read_text()\nprint(model)\n</code></pre> <p>‚ú® Output: <pre><code># generated by datamodel-codegen:\n#   filename:  example.json\n#   timestamp: 2020-12-21T08:01:06+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass StreetType(Enum):\n    Street = 'Street'\n    Avenue = 'Avenue'\n    Boulevard = 'Boulevard'\n\n\nclass Model(BaseModel):\n    number: Optional[float] = None\n    street_name: Optional[str] = None\n    street_type: Optional[StreetType] = None\n</code></pre></p>","path":["Usage","Integration","üêç Using datamodel-code-generator as a Module"],"tags":[]},{"location":"using_as_module/#using-the-parser-directly","level":2,"title":"üîß Using the Parser Directly","text":"<p>You can also call the parser directly for more control:</p> <pre><code>from datamodel_code_generator import DataModelType, PythonVersion\nfrom datamodel_code_generator.model import get_data_model_types\nfrom datamodel_code_generator.parser.jsonschema import JsonSchemaParser\n\njson_schema: str = \"\"\"{\n    \"type\": \"object\",\n    \"properties\": {\n        \"number\": {\"type\": \"number\"},\n        \"street_name\": {\"type\": \"string\"},\n        \"street_type\": {\"type\": \"string\",\n                        \"enum\": [\"Street\", \"Avenue\", \"Boulevard\"]\n                        }\n    }\n}\"\"\"\n\n\ndata_model_types = get_data_model_types(\n    DataModelType.PydanticV2BaseModel,\n    target_python_version=PythonVersion.PY_311\n)\nparser = JsonSchemaParser(\n   json_schema,\n   data_model_type=data_model_types.data_model,\n   data_model_root_type=data_model_types.root_model,\n   data_model_field_type=data_model_types.field_model,\n   data_type_manager_type=data_model_types.data_type_manager,\n   dump_resolve_reference_action=data_model_types.dump_resolve_reference_action,\n)\nresult = parser.parse()\nprint(result)\n</code></pre> <p>‚ú® Output: <pre><code>from __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass StreetType(Enum):\n    Street = 'Street'\n    Avenue = 'Avenue'\n    Boulevard = 'Boulevard'\n\n\nclass Model(BaseModel):\n    number: Optional[float] = None\n    street_name: Optional[str] = None\n    street_type: Optional[StreetType] = None\n</code></pre></p>","path":["Usage","Integration","üêç Using datamodel-code-generator as a Module"],"tags":[]},{"location":"using_as_module/#why-doesnt-generate-return-a-string","level":2,"title":"‚ùì Why doesn't <code>generate</code> return a string?","text":"<p>The above example schema only generates a single Python module, but a single schema may generate multiple modules. There is no way to represent these modules as a single string, so the <code>generate</code> method returns <code>None</code>.</p> <p>üìå Note: The output parameter can take any <code>Path</code> object, which includes both file and directory paths. If a file name is provided and multiple modules are generated, <code>generate</code> will raise a <code>datamodel_code_gen.Error</code> exception.</p> <p>If multiple modules are generated, you will need to walk through the supplied output directory to find all of them.</p>","path":["Usage","Integration","üêç Using datamodel-code-generator as a Module"],"tags":[]},{"location":"using_as_module/#see-also","level":2,"title":"üìñ See Also","text":"<ul> <li>üñ•Ô∏è CLI Reference - Complete CLI options (same parameters as module)</li> <li>üìã Generate from JSON Schema - JSON Schema examples</li> </ul>","path":["Usage","Integration","üêç Using datamodel-code-generator as a Module"],"tags":[]},{"location":"what_is_the_difference_between_v1_and_v2/","level":1,"title":"Output Model Types","text":"","path":["Usage","Output Customization","Output Model Types"],"tags":[]},{"location":"what_is_the_difference_between_v1_and_v2/#output-model-types","level":1,"title":"Output Model Types","text":"<p>datamodel-code-generator supports multiple output model types. This page compares them to help you choose the right one for your project.</p>","path":["Usage","Output Customization","Output Model Types"],"tags":[]},{"location":"what_is_the_difference_between_v1_and_v2/#quick-comparison","level":2,"title":"Quick Comparison","text":"Model Type Validation Serialization Performance Use Case Pydantic v2 Runtime Built-in Fast New projects, APIs, data validation Pydantic v1 Runtime Built-in Moderate Legacy compatibility dataclasses None Manual Fastest Simple data containers, no validation needed TypedDict Static only Dict-compatible N/A Type hints for dicts, JSON APIs msgspec Runtime Built-in Fastest High-performance serialization","path":["Usage","Output Customization","Output Model Types"],"tags":[]},{"location":"what_is_the_difference_between_v1_and_v2/#pydantic-v2-recommended","level":2,"title":"Pydantic v2 (Recommended)","text":"<p>Use <code>--output-model-type pydantic_v2.BaseModel</code></p> <p>Pydantic v2 is recommended for new projects. It offers better performance and a modern API.</p> <pre><code>datamodel-codegen --input schema.json --output-model-type pydantic_v2.BaseModel --output model.py\n</code></pre> <pre><code>from pydantic import BaseModel, Field, RootModel\n\nclass Pet(BaseModel):\n    id: int = Field(..., ge=0)\n    name: str = Field(..., max_length=256)\n    tag: str | None = None\n\nclass Pets(RootModel[list[Pet]]):\n    root: list[Pet]\n</code></pre>","path":["Usage","Output Customization","Output Model Types"],"tags":[]},{"location":"what_is_the_difference_between_v1_and_v2/#when-to-use","level":3,"title":"When to use","text":"<ul> <li>New projects without Pydantic v1 dependencies</li> <li>APIs requiring data validation</li> <li>Projects needing JSON Schema generation from models</li> </ul>","path":["Usage","Output Customization","Output Model Types"],"tags":[]},{"location":"what_is_the_difference_between_v1_and_v2/#pydantic-v1","level":2,"title":"Pydantic v1","text":"<p>Use <code>--output-model-type pydantic.BaseModel</code> (default)</p> <p>Pydantic v1 is the default for backward compatibility with existing codebases.</p> <pre><code>datamodel-codegen --input schema.json --output-model-type pydantic.BaseModel --output model.py\n</code></pre> <pre><code>from pydantic import BaseModel, Field\n\nclass Pet(BaseModel):\n    id: int = Field(..., ge=0)\n    name: str = Field(..., max_length=256)\n    tag: Optional[str] = None\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n</code></pre>","path":["Usage","Output Customization","Output Model Types"],"tags":[]},{"location":"what_is_the_difference_between_v1_and_v2/#migration-from-v1-to-v2","level":3,"title":"Migration from v1 to v2","text":"<p>Key differences when migrating:</p> v1 v2 Notes <code>__root__</code> <code>RootModel</code> Custom root types now use <code>RootModel</code> class <code>const</code> Removed Use <code>Literal</code> types instead <code>min_items</code> <code>min_length</code> <code>max_items</code> <code>max_length</code> <code>unique_items</code> Removed List replaced by <code>set</code> type <code>allow_mutation</code> <code>frozen</code> Inverse value <code>regex</code> <code>pattern</code> <code>pydantic.Config</code> <code>pydantic.ConfigDict</code> <p>See Pydantic v2 Migration Guide for details.</p>","path":["Usage","Output Customization","Output Model Types"],"tags":[]},{"location":"what_is_the_difference_between_v1_and_v2/#dataclasses","level":2,"title":"dataclasses","text":"<p>Use <code>--output-model-type dataclasses.dataclass</code></p> <p>Python's built-in dataclasses for simple data containers without runtime validation.</p> <pre><code>datamodel-codegen --input schema.json --output-model-type dataclasses.dataclass --output model.py\n</code></pre> <pre><code>from dataclasses import dataclass\nfrom typing import Optional\n\n@dataclass\nclass Pet:\n    id: int\n    name: str\n    tag: Optional[str] = None\n</code></pre>","path":["Usage","Output Customization","Output Model Types"],"tags":[]},{"location":"what_is_the_difference_between_v1_and_v2/#options-for-dataclasses","level":3,"title":"Options for dataclasses","text":"Option Description <code>--frozen-dataclasses</code> Generate immutable dataclasses (<code>frozen=True</code>) <code>--keyword-only</code> Require keyword arguments (<code>kw_only=True</code>, Python 3.10+) <code>--dataclass-arguments</code> Custom decorator arguments as JSON <pre><code># Frozen, keyword-only dataclasses\ndatamodel-codegen --input schema.json --output-model-type dataclasses.dataclass \\\n  --frozen-dataclasses --keyword-only --target-python-version 3.10\n</code></pre>","path":["Usage","Output Customization","Output Model Types"],"tags":[]},{"location":"what_is_the_difference_between_v1_and_v2/#when-to-use_1","level":3,"title":"When to use","text":"<ul> <li>Simple data structures without validation needs</li> <li>Performance-critical code where validation overhead matters</li> <li>Interoperability with code expecting dataclasses</li> </ul>","path":["Usage","Output Customization","Output Model Types"],"tags":[]},{"location":"what_is_the_difference_between_v1_and_v2/#typeddict","level":2,"title":"TypedDict","text":"<p>Use <code>--output-model-type typing.TypedDict</code></p> <p>TypedDict provides static type checking for dictionary structures.</p> <pre><code>datamodel-codegen --input schema.json --output-model-type typing.TypedDict --output model.py\n</code></pre> <pre><code>from typing import TypedDict, NotRequired\n\nclass Pet(TypedDict):\n    id: int\n    name: str\n    tag: NotRequired[str]\n</code></pre>","path":["Usage","Output Customization","Output Model Types"],"tags":[]},{"location":"what_is_the_difference_between_v1_and_v2/#when-to-use_2","level":3,"title":"When to use","text":"<ul> <li>Working with JSON APIs where data remains as dicts</li> <li>Static type checking without runtime overhead</li> <li>Gradual typing of existing dict-based code</li> </ul>","path":["Usage","Output Customization","Output Model Types"],"tags":[]},{"location":"what_is_the_difference_between_v1_and_v2/#msgspec","level":2,"title":"msgspec","text":"<p>Use <code>--output-model-type msgspec.Struct</code></p> <p>msgspec offers high-performance serialization with validation.</p> <pre><code>pip install 'datamodel-code-generator[msgspec]'\ndatamodel-codegen --input schema.json --output-model-type msgspec.Struct --output model.py\n</code></pre> <pre><code>from msgspec import Struct, field\nfrom typing import Union, UnsetType\nfrom msgspec import UNSET\n\nclass Pet(Struct):\n    id: int\n    name: str\n    tag: Union[str, UnsetType] = UNSET\n</code></pre>","path":["Usage","Output Customization","Output Model Types"],"tags":[]},{"location":"what_is_the_difference_between_v1_and_v2/#when-to-use_3","level":3,"title":"When to use","text":"<ul> <li>High-performance JSON/MessagePack serialization</li> <li>Memory-efficient data structures</li> <li>APIs with strict performance requirements</li> </ul>","path":["Usage","Output Customization","Output Model Types"],"tags":[]},{"location":"what_is_the_difference_between_v1_and_v2/#choosing-the-right-type","level":2,"title":"Choosing the Right Type","text":"<pre><code>graph TD\n    A[Need runtime validation?] --&gt;|Yes| B[Need best performance?]\n    A --&gt;|No| C[Need type hints for dicts?]\n    B --&gt;|Yes| D[msgspec.Struct]\n    B --&gt;|No| E[Pydantic v1 dependency?]\n    E --&gt;|Yes| F[pydantic.BaseModel]\n    E --&gt;|No| G[pydantic_v2.BaseModel]\n    C --&gt;|Yes| H[typing.TypedDict]\n    C --&gt;|No| I[dataclasses.dataclass]\n</code></pre>","path":["Usage","Output Customization","Output Model Types"],"tags":[]},{"location":"what_is_the_difference_between_v1_and_v2/#decision-guide","level":3,"title":"Decision Guide","text":"<ol> <li>API with validation ‚Üí Pydantic v2</li> <li>Legacy Pydantic v1 project ‚Üí Pydantic v1</li> <li>High-performance serialization ‚Üí msgspec</li> <li>Simple data containers ‚Üí dataclasses</li> <li>Dict-based JSON handling ‚Üí TypedDict</li> </ol>","path":["Usage","Output Customization","Output Model Types"],"tags":[]},{"location":"what_is_the_difference_between_v1_and_v2/#see-also","level":2,"title":"See Also","text":"<ul> <li>CLI Reference: <code>--output-model-type</code></li> <li>CLI Reference: Model Customization</li> <li>Pydantic Documentation</li> <li>msgspec Documentation</li> </ul>","path":["Usage","Output Customization","Output Model Types"],"tags":[]},{"location":"cli-reference/","level":1,"title":"üñ•Ô∏è CLI Reference","text":"<p>This documentation is auto-generated from test cases.</p> <p>üîç Quick Reference - All options on one page for Ctrl+F search</p>","path":["CLI Reference","üñ•Ô∏è CLI Reference"],"tags":[]},{"location":"cli-reference/#categories","level":2,"title":"üìÇ Categories","text":"Category Options Description üìÅ Base Options 5 Input/output configuration üîß Typing Customization 16 Type annotation and import behavior üè∑Ô∏è Field Customization 20 Field naming and docstring behavior üèóÔ∏è Model Customization 26 Model generation behavior üé® Template Customization 16 Output formatting and custom rendering üìò OpenAPI-only Options 5 OpenAPI-specific features ‚öôÔ∏è General Options 13 Utilities and meta options üìù Utility Options 5 Help, version, debug options","path":["CLI Reference","üñ•Ô∏è CLI Reference"],"tags":[]},{"location":"cli-reference/#all-options","level":2,"title":"All Options","text":"<p>Jump to: A ¬∑ B ¬∑ C ¬∑ D ¬∑ E ¬∑ F ¬∑ G ¬∑ H ¬∑ I ¬∑ K ¬∑ N ¬∑ O ¬∑ P ¬∑ R ¬∑ S ¬∑ T ¬∑ U ¬∑ V ¬∑ W</p>","path":["CLI Reference","üñ•Ô∏è CLI Reference"],"tags":[]},{"location":"cli-reference/#a","level":3,"title":"A","text":"<ul> <li><code>--additional-imports</code></li> <li><code>--aliases</code></li> <li><code>--all-exports-collision-strategy</code></li> <li><code>--all-exports-scope</code></li> <li><code>--allof-merge-mode</code></li> <li><code>--allow-extra-fields</code></li> <li><code>--allow-population-by-field-name</code></li> </ul>","path":["CLI Reference","üñ•Ô∏è CLI Reference"],"tags":[]},{"location":"cli-reference/#b","level":3,"title":"B","text":"<ul> <li><code>--base-class</code></li> </ul>","path":["CLI Reference","üñ•Ô∏è CLI Reference"],"tags":[]},{"location":"cli-reference/#c","level":3,"title":"C","text":"<ul> <li><code>--capitalize-enum-members</code></li> <li><code>--check</code></li> <li><code>--class-name</code></li> <li><code>--collapse-root-models</code></li> <li><code>--custom-file-header</code></li> <li><code>--custom-file-header-path</code></li> <li><code>--custom-formatters</code></li> <li><code>--custom-formatters-kwargs</code></li> <li><code>--custom-template-dir</code></li> </ul>","path":["CLI Reference","üñ•Ô∏è CLI Reference"],"tags":[]},{"location":"cli-reference/#d","level":3,"title":"D","text":"<ul> <li><code>--dataclass-arguments</code></li> <li><code>--debug</code></li> <li><code>--disable-appending-item-suffix</code></li> <li><code>--disable-future-imports</code></li> <li><code>--disable-timestamp</code></li> <li><code>--disable-warnings</code></li> </ul>","path":["CLI Reference","üñ•Ô∏è CLI Reference"],"tags":[]},{"location":"cli-reference/#e","level":3,"title":"E","text":"<ul> <li><code>--empty-enum-field-name</code></li> <li><code>--enable-command-header</code></li> <li><code>--enable-faux-immutability</code></li> <li><code>--enable-version-header</code></li> <li><code>--encoding</code></li> <li><code>--enum-field-as-literal</code></li> <li><code>--extra-fields</code></li> <li><code>--extra-template-data</code></li> </ul>","path":["CLI Reference","üñ•Ô∏è CLI Reference"],"tags":[]},{"location":"cli-reference/#f","level":3,"title":"F","text":"<ul> <li><code>--field-constraints</code></li> <li><code>--field-extra-keys</code></li> <li><code>--field-extra-keys-without-x-prefix</code></li> <li><code>--field-include-all-keys</code></li> <li><code>--force-optional</code></li> <li><code>--formatters</code></li> <li><code>--frozen-dataclasses</code></li> </ul>","path":["CLI Reference","üñ•Ô∏è CLI Reference"],"tags":[]},{"location":"cli-reference/#g","level":3,"title":"G","text":"<ul> <li><code>--generate-cli-command</code></li> <li><code>--generate-pyproject-config</code></li> </ul>","path":["CLI Reference","üñ•Ô∏è CLI Reference"],"tags":[]},{"location":"cli-reference/#h","level":3,"title":"H","text":"<ul> <li><code>--help</code></li> <li><code>--http-headers</code></li> <li><code>--http-ignore-tls</code></li> <li><code>--http-query-parameters</code></li> </ul>","path":["CLI Reference","üñ•Ô∏è CLI Reference"],"tags":[]},{"location":"cli-reference/#i","level":3,"title":"I","text":"<ul> <li><code>--ignore-pyproject</code></li> <li><code>--include-path-parameters</code></li> <li><code>--input</code></li> <li><code>--input-file-type</code></li> </ul>","path":["CLI Reference","üñ•Ô∏è CLI Reference"],"tags":[]},{"location":"cli-reference/#k","level":3,"title":"K","text":"<ul> <li><code>--keep-model-order</code></li> <li><code>--keyword-only</code></li> </ul>","path":["CLI Reference","üñ•Ô∏è CLI Reference"],"tags":[]},{"location":"cli-reference/#n","level":3,"title":"N","text":"<ul> <li><code>--no-alias</code></li> <li><code>--no-color</code></li> <li><code>--no-use-specialized-enum</code></li> </ul>","path":["CLI Reference","üñ•Ô∏è CLI Reference"],"tags":[]},{"location":"cli-reference/#o","level":3,"title":"O","text":"<ul> <li><code>--openapi-scopes</code></li> <li><code>--original-field-name-delimiter</code></li> <li><code>--output</code></li> <li><code>--output-datetime-class</code></li> <li><code>--output-model-type</code></li> </ul>","path":["CLI Reference","üñ•Ô∏è CLI Reference"],"tags":[]},{"location":"cli-reference/#p","level":3,"title":"P","text":"<ul> <li><code>--parent-scoped-naming</code></li> <li><code>--profile</code></li> </ul>","path":["CLI Reference","üñ•Ô∏è CLI Reference"],"tags":[]},{"location":"cli-reference/#r","level":3,"title":"R","text":"<ul> <li><code>--read-only-write-only-model-type</code></li> <li><code>--remove-special-field-name-prefix</code></li> <li><code>--reuse-model</code></li> <li><code>--reuse-scope</code></li> </ul>","path":["CLI Reference","üñ•Ô∏è CLI Reference"],"tags":[]},{"location":"cli-reference/#s","level":3,"title":"S","text":"<ul> <li><code>--set-default-enum-member</code></li> <li><code>--shared-module-name</code></li> <li><code>--skip-root-model</code></li> <li><code>--snake-case-field</code></li> <li><code>--special-field-name-prefix</code></li> <li><code>--strict-nullable</code></li> <li><code>--strict-types</code></li> <li><code>--strip-default-none</code></li> </ul>","path":["CLI Reference","üñ•Ô∏è CLI Reference"],"tags":[]},{"location":"cli-reference/#t","level":3,"title":"T","text":"<ul> <li><code>--target-python-version</code></li> <li><code>--treat-dot-as-module</code></li> <li><code>--type-mappings</code></li> </ul>","path":["CLI Reference","üñ•Ô∏è CLI Reference"],"tags":[]},{"location":"cli-reference/#u","level":3,"title":"U","text":"<ul> <li><code>--union-mode</code></li> <li><code>--url</code></li> <li><code>--use-annotated</code></li> <li><code>--use-attribute-docstrings</code></li> <li><code>--use-decimal-for-multiple-of</code></li> <li><code>--use-default</code></li> <li><code>--use-default-kwarg</code></li> <li><code>--use-double-quotes</code></li> <li><code>--use-enum-values-in-discriminator</code></li> <li><code>--use-exact-imports</code></li> <li><code>--use-field-description</code></li> <li><code>--use-frozen-field</code></li> <li><code>--use-generic-container-types</code></li> <li><code>--use-inline-field-description</code></li> <li><code>--use-non-positive-negative-number-constrained-types</code></li> <li><code>--use-one-literal-as-default</code></li> <li><code>--use-operation-id-as-name</code></li> <li><code>--use-pendulum</code></li> <li><code>--use-schema-description</code></li> <li><code>--use-serialize-as-any</code></li> <li><code>--use-standard-collections</code></li> <li><code>--use-subclass-enum</code></li> <li><code>--use-title-as-name</code></li> <li><code>--use-type-alias</code></li> <li><code>--use-union-operator</code></li> <li><code>--use-unique-items-as-set</code></li> </ul>","path":["CLI Reference","üñ•Ô∏è CLI Reference"],"tags":[]},{"location":"cli-reference/#v","level":3,"title":"V","text":"<ul> <li><code>--validation</code></li> <li><code>--version</code></li> </ul>","path":["CLI Reference","üñ•Ô∏è CLI Reference"],"tags":[]},{"location":"cli-reference/#w","level":3,"title":"W","text":"<ul> <li><code>--watch</code></li> <li><code>--watch-delay</code></li> <li><code>--wrap-string-literal</code></li> </ul>","path":["CLI Reference","üñ•Ô∏è CLI Reference"],"tags":[]},{"location":"cli-reference/base-options/","level":1,"title":"üìÅ Base Options","text":"","path":["CLI Reference","üìÅ Base Options"],"tags":[]},{"location":"cli-reference/base-options/#options","level":2,"title":"üìã Options","text":"Option Description <code>--encoding</code> Specify character encoding for input and output files. <code>--input</code> Specify the input schema file path. <code>--input-file-type</code> Specify the input file type for code generation. <code>--output</code> Specify the destination path for generated Python code. <code>--url</code> Fetch schema from URL with custom HTTP headers.","path":["CLI Reference","üìÅ Base Options"],"tags":[]},{"location":"cli-reference/base-options/#encoding","level":2,"title":"<code>--encoding</code>","text":"<p>Specify character encoding for input and output files.</p> <p>The <code>--encoding</code> flag sets the character encoding used when reading the schema file and writing the generated Python code. This is useful for schemas containing non-ASCII characters (e.g., Japanese, Chinese). Default is utf-8.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --encoding utf-8 # (1)!\n</code></pre> <ol> <li> <code>--encoding</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Êó•Êú¨Ë™ûModel\",\n  \"description\": \"„É¢„Éá„É´„ÅÆË™¨ÊòéÊñá\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"ÂêçÂâç\": {\n      \"type\": \"string\",\n      \"description\": \"„É¶„Éº„Ç∂„ÉºÂêç\"\n    },\n    \"Âπ¥ÈΩ¢\": {\n      \"type\": \"integer\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  encoding_test.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Êó•Êú¨Ë™ûModel(BaseModel):\n    ÂêçÂâç: Optional[str] = Field(None, description='„É¶„Éº„Ç∂„ÉºÂêç')\n    Âπ¥ÈΩ¢: Optional[int] = None\n</code></pre>","path":["CLI Reference","üìÅ Base Options"],"tags":[]},{"location":"cli-reference/base-options/#input","level":2,"title":"<code>--input</code>","text":"<p>Specify the input schema file path.</p> <p>The <code>--input</code> flag specifies the path to the schema file (JSON Schema, OpenAPI, GraphQL, etc.). Multiple input files can be specified to merge schemas. Required unless using <code>--url</code> to fetch schema from a URL.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --input pet_simple.json --output output.py # (1)!\n</code></pre> <ol> <li> <code>--input</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Pet\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"tag\": {\n      \"type\": \"string\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  pet_simple.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    id: Optional[int] = None\n    name: Optional[str] = None\n    tag: Optional[str] = None\n</code></pre>","path":["CLI Reference","üìÅ Base Options"],"tags":[]},{"location":"cli-reference/base-options/#input-file-type","level":2,"title":"<code>--input-file-type</code>","text":"<p>Specify the input file type for code generation.</p> <p>The <code>--input-file-type</code> flag explicitly sets the input format when it cannot be auto-detected from the file extension. Supported types: openapi, jsonschema, json, yaml, csv, graphql.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --input-file-type json # (1)!\n</code></pre> <ol> <li> <code>--input-file-type</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"Pet\": {\n    \"name\": \"dog\",\n    \"age\": 2\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  pet.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    name: str\n    age: int\n\n\nclass Model(BaseModel):\n    Pet: Pet\n</code></pre>","path":["CLI Reference","üìÅ Base Options"],"tags":[]},{"location":"cli-reference/base-options/#output","level":2,"title":"<code>--output</code>","text":"<p>Specify the destination path for generated Python code.</p> <p>The <code>--output</code> flag specifies where to write the generated Python code. It can be either a file path (single-file output) or a directory path (multi-file output for modular schemas). If omitted, the generated code is written to stdout.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --input pet_simple.json --output output.py # (1)!\n</code></pre> <ol> <li> <code>--output</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Pet\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"tag\": {\n      \"type\": \"string\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  pet_simple.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    id: Optional[int] = None\n    name: Optional[str] = None\n    tag: Optional[str] = None\n</code></pre>","path":["CLI Reference","üìÅ Base Options"],"tags":[]},{"location":"cli-reference/base-options/#url","level":2,"title":"<code>--url</code>","text":"<p>Fetch schema from URL with custom HTTP headers.</p> <p>The <code>--url</code> flag specifies a remote URL to fetch the schema from instead of a local file. The <code>--http-headers</code> flag adds custom HTTP headers to the request, useful for authentication (e.g., Bearer tokens) or custom API requirements. Format: <code>HeaderName:HeaderValue</code>.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --url https://api.example.com/schema.json --http-headers \"Authorization:Bearer token\" # (1)!\n</code></pre> <ol> <li> <code>--url</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Pet\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"tag\": {\n      \"type\": \"string\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  https://api.example.com/schema.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    id: Optional[int] = None\n    name: Optional[str] = None\n    tag: Optional[str] = None\n</code></pre>","path":["CLI Reference","üìÅ Base Options"],"tags":[]},{"location":"cli-reference/field-customization/","level":1,"title":"üè∑Ô∏è Field Customization","text":"","path":["CLI Reference","üè∑Ô∏è Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#options","level":2,"title":"üìã Options","text":"Option Description <code>--aliases</code> Apply custom field and class name aliases from JSON file. <code>--capitalize-enum-members</code> Capitalize enum member names to UPPER_CASE format. <code>--empty-enum-field-name</code> Name for empty string enum field values. <code>--extra-fields</code> Configure how generated models handle extra fields not defin... <code>--field-constraints</code> Generate Field() with validation constraints from schema. <code>--field-extra-keys</code> Include specific extra keys in Field() definitions. <code>--field-extra-keys-without-x-prefix</code> Include specified schema extension keys in Field() without r... <code>--field-include-all-keys</code> Include all schema keys in Field() json_schema_extra. <code>--no-alias</code> Disable Field alias generation for non-Python-safe property ... <code>--original-field-name-delimiter</code> Specify delimiter for original field names when using snake-... <code>--remove-special-field-name-prefix</code> Remove the special prefix from field names. <code>--set-default-enum-member</code> Set the first enum member as the default value for enum fiel... <code>--snake-case-field</code> Convert field names to snake_case format. <code>--special-field-name-prefix</code> Prefix to add to special field names (like reserved keywords... <code>--use-attribute-docstrings</code> Generate field descriptions as attribute docstrings instead ... <code>--use-enum-values-in-discriminator</code> Use enum values in discriminator mappings for union types. <code>--use-field-description</code> Include schema descriptions as Field docstrings. <code>--use-inline-field-description</code> Add field descriptions as inline comments. <code>--use-schema-description</code> Use schema description as class docstring. <code>--use-title-as-name</code> Use schema title as the generated class name.","path":["CLI Reference","üè∑Ô∏è Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#aliases","level":2,"title":"<code>--aliases</code>","text":"<p>Apply custom field and class name aliases from JSON file.</p> <p>The <code>--aliases</code> option allows renaming fields and classes via a JSON mapping file, providing fine-grained control over generated names independent of schema definitions.</p> <p>See also: Field Aliases</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --aliases openapi/aliases.json --target-python 3.9 # (1)!\n</code></pre> <ol> <li> <code>--aliases</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: error result\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output Pydantic v1msgspec <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id_: int = Field(..., alias='id')\n    name_: str = Field(..., alias='name')\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass User(BaseModel):\n    id_: int = Field(..., alias='id')\n    name_: str = Field(..., alias='name')\n    tag: Optional[str] = None\n\n\nclass Users(BaseModel):\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    name_: Optional[str] = Field(None, alias='name')\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Annotated, List, Union\n\nfrom msgspec import UNSET, Meta, Struct, UnsetType, field\nfrom typing_extensions import TypeAlias\n\n\nclass Pet(Struct):\n    id_: int = field(name='id')\n    name_: str = field(name='name')\n    tag: Union[str, UnsetType] = UNSET\n\n\nPets: TypeAlias = List[Pet]\n\n\nclass User(Struct):\n    id_: int = field(name='id')\n    name_: str = field(name='name')\n    tag: Union[str, UnsetType] = UNSET\n\n\nUsers: TypeAlias = List[User]\n\n\nId: TypeAlias = str\n\n\nRules: TypeAlias = List[str]\n\n\nclass Error(Struct):\n    code: int\n    message: str\n\n\nclass Api(Struct):\n    apiKey: Union[\n        Annotated[str, Meta(description='To be used as a dataset parameter value')],\n        UnsetType,\n    ] = UNSET\n    apiVersionNumber: Union[\n        Annotated[str, Meta(description='To be used as a version parameter value')],\n        UnsetType,\n    ] = UNSET\n    apiUrl: Union[\n        Annotated[str, Meta(description=\"The URL describing the dataset's fields\")],\n        UnsetType,\n    ] = UNSET\n    apiDocumentationUrl: Union[\n        Annotated[str, Meta(description='A URL to the API console for each API')],\n        UnsetType,\n    ] = UNSET\n\n\nApis: TypeAlias = List[Api]\n\n\nclass Event(Struct):\n    name_: Union[str, UnsetType] = field(name='name', default=UNSET)\n\n\nclass Result(Struct):\n    event: Union[Event, UnsetType] = UNSET\n</code></pre>","path":["CLI Reference","üè∑Ô∏è Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#capitalize-enum-members","level":2,"title":"<code>--capitalize-enum-members</code>","text":"<p>Capitalize enum member names to UPPER_CASE format.</p> <p>The <code>--capitalize-enum-members</code> flag converts enum member names to UPPER_CASE format (e.g., <code>active</code> becomes <code>ACTIVE</code>), following Python naming conventions for constants.</p> <p>Aliases: <code>--capitalise-enum-members</code> | Related: <code>--snake-case-field</code></p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --capitalize-enum-members # (1)!\n</code></pre> <ol> <li> <code>--capitalize-enum-members</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"snake_case\",\n    \"CAP_CASE\",\n    \"CamelCase\",\n    \"UPPERCASE\"\n  ]\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  many_case_enum.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\n\n\nclass Model(Enum):\n    SNAKE_CASE = 'snake_case'\n    CAP_CASE = 'CAP_CASE'\n    CAMEL_CASE = 'CamelCase'\n    UPPERCASE = 'UPPERCASE'\n</code></pre>","path":["CLI Reference","üè∑Ô∏è Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#empty-enum-field-name","level":2,"title":"<code>--empty-enum-field-name</code>","text":"<p>Name for empty string enum field values.</p> <p>The <code>--empty-enum-field-name</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --empty-enum-field-name empty # (1)!\n</code></pre> <ol> <li> <code>--empty-enum-field-name</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"string\",\n  \"enum\": [\n    true,\n    false,\n    \"\",\n    \"\\n\",\n    \"\\r\\n\",\n    \"\\t\",\n    \"\\b\",\n    null,\n    \"\\\\\"\n  ]\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  special_enum.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass ModelEnum(Enum):\n    True_ = True\n    False_ = False\n    empty = ''\n    field_ = '\\n'\n    field__ = '\\r\\n'\n    field__1 = '\\t'\n    field__2 = '\\b'\n    field__3 = '\\\\'\n\n\nclass Model(BaseModel):\n    __root__: Optional[ModelEnum] = None\n</code></pre>","path":["CLI Reference","üè∑Ô∏è Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#extra-fields","level":2,"title":"<code>--extra-fields</code>","text":"<p>Configure how generated models handle extra fields not defined in schema.</p> <p>The <code>--extra-fields</code> flag sets the generated models to allow, forbid, or ignore extra fields. With <code>--extra-fields allow</code>, models will accept and store fields not defined in the schema. Options: allow, ignore, forbid.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --extra-fields allow # (1)!\n</code></pre> <ol> <li> <code>--extra-fields</code> - the option documented here</li> </ol> Input Schema <pre><code>type Person {\n    id: ID!\n    name: String!\n    height: Int\n    mass: Int\n    hair_color: String\n    skin_color: String\n    eye_color: String\n    birth_year: String\n    gender: String\n\n    # Relationships\n    homeworld_id: ID\n    homeworld: Planet\n    species: [Species!]!\n    species_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n    starships: [Starship!]!\n    starships_ids: [ID!]!\n    vehicles: [Vehicle!]!\n    vehicles_ids: [ID!]!\n}\n\ntype Planet {\n    id: ID!\n    name: String!\n    rotation_period: String\n    orbital_period: String\n    diameter: String\n    climate: String\n    gravity: String\n    terrain: String\n    surface_water: String\n    population: String\n\n    # Relationships\n    residents: [Person!]!\n    residents_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n}\n\ntype Species {\n    id: ID!\n    name: String!\n    classification: String\n    designation: String\n    average_height: String\n    skin_colors: String\n    hair_colors: String\n    eye_colors: String\n    average_lifespan: String\n    language: String\n\n    # Relationships\n    people: [Person!]!\n    people_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n}\n\ntype Vehicle {\n    id: ID!\n    name: String!\n    model: String\n    manufacturer: String\n    cost_in_credits: String\n    length: String\n    max_atmosphering_speed: String\n    crew: String\n    passengers: String\n    cargo_capacity: String\n    consumables: String\n    vehicle_class: String\n\n    # Relationships\n    pilots: [Person!]!\n    pilots_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n}\n\ntype Starship {\n    id: ID!\n    name: String!\n    model: String\n    manufacturer: String\n    cost_in_credits: String\n    length: String\n    max_atmosphering_speed: String\n    crew: String\n    passengers: String\n    cargo_capacity: String\n    consumables: String\n    hyperdrive_rating: String\n    MGLT: String\n    starship_class: String\n\n    # Relationships\n    pilots: [Person!]!\n    pilots_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n}\n\ntype Film {\n  id: ID!\n  title: String!\n  episode_id: Int!\n  opening_crawl: String!\n  director: String!\n  producer: String\n  release_date: String!\n\n  # Relationships\n  characters: [Person!]!\n  characters_ids: [ID!]!\n  planets: [Planet!]!\n  planets_ids: [ID!]!\n  starships: [Starship!]!\n  starships_ids: [ID!]!\n  vehicles: [Vehicle!]!\n  vehicles_ids: [ID!]!\n  species: [Species!]!\n  species_ids: [ID!]!\n}\n\ntype Query {\n  planet(id: ID!): Planet\n  listPlanets(page: Int): [Planet!]!\n  person(id: ID!): Person\n  listPeople(page: Int): [Person!]!\n  species(id: ID!): Species\n  listSpecies(page: Int): [Species!]!\n  film(id: ID!): Film\n  listFilms(page: Int): [Film!]!\n  starship(id: ID!): Starship\n  listStarships(page: Int): [Starship!]!\n  vehicle(id: ID!): Vehicle\n  listVehicles(page: Int): [Vehicle!]!\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  simple-star-wars.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Literal, Optional\n\nfrom pydantic import BaseModel, Extra, Field\nfrom typing_extensions import TypeAlias\n\nBoolean: TypeAlias = bool\n\"\"\"\nThe `Boolean` scalar type represents `true` or `false`.\n\"\"\"\n\n\nID: TypeAlias = str\n\"\"\"\nThe `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `\"4\"`) or integer (such as `4`) input value will be accepted as an ID.\n\"\"\"\n\n\nInt: TypeAlias = int\n\"\"\"\nThe `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\n\"\"\"\n\n\nString: TypeAlias = str\n\"\"\"\nThe `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\n\"\"\"\n\n\nclass Film(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    characters: List[Person]\n    characters_ids: List[ID]\n    director: String\n    episode_id: Int\n    id: ID\n    opening_crawl: String\n    planets: List[Planet]\n    planets_ids: List[ID]\n    producer: Optional[String] = None\n    release_date: String\n    species: List[Species]\n    species_ids: List[ID]\n    starships: List[Starship]\n    starships_ids: List[ID]\n    title: String\n    vehicles: List[Vehicle]\n    vehicles_ids: List[ID]\n    typename__: Optional[Literal['Film']] = Field('Film', alias='__typename')\n\n\nclass Person(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    birth_year: Optional[String] = None\n    eye_color: Optional[String] = None\n    films: List[Film]\n    films_ids: List[ID]\n    gender: Optional[String] = None\n    hair_color: Optional[String] = None\n    height: Optional[Int] = None\n    homeworld: Optional[Planet] = None\n    homeworld_id: Optional[ID] = None\n    id: ID\n    mass: Optional[Int] = None\n    name: String\n    skin_color: Optional[String] = None\n    species: List[Species]\n    species_ids: List[ID]\n    starships: List[Starship]\n    starships_ids: List[ID]\n    vehicles: List[Vehicle]\n    vehicles_ids: List[ID]\n    typename__: Optional[Literal['Person']] = Field('Person', alias='__typename')\n\n\nclass Planet(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    climate: Optional[String] = None\n    diameter: Optional[String] = None\n    films: List[Film]\n    films_ids: List[ID]\n    gravity: Optional[String] = None\n    id: ID\n    name: String\n    orbital_period: Optional[String] = None\n    population: Optional[String] = None\n    residents: List[Person]\n    residents_ids: List[ID]\n    rotation_period: Optional[String] = None\n    surface_water: Optional[String] = None\n    terrain: Optional[String] = None\n    typename__: Optional[Literal['Planet']] = Field('Planet', alias='__typename')\n\n\nclass Species(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    average_height: Optional[String] = None\n    average_lifespan: Optional[String] = None\n    classification: Optional[String] = None\n    designation: Optional[String] = None\n    eye_colors: Optional[String] = None\n    films: List[Film]\n    films_ids: List[ID]\n    hair_colors: Optional[String] = None\n    id: ID\n    language: Optional[String] = None\n    name: String\n    people: List[Person]\n    people_ids: List[ID]\n    skin_colors: Optional[String] = None\n    typename__: Optional[Literal['Species']] = Field('Species', alias='__typename')\n\n\nclass Starship(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    MGLT: Optional[String] = None\n    cargo_capacity: Optional[String] = None\n    consumables: Optional[String] = None\n    cost_in_credits: Optional[String] = None\n    crew: Optional[String] = None\n    films: List[Film]\n    films_ids: List[ID]\n    hyperdrive_rating: Optional[String] = None\n    id: ID\n    length: Optional[String] = None\n    manufacturer: Optional[String] = None\n    max_atmosphering_speed: Optional[String] = None\n    model: Optional[String] = None\n    name: String\n    passengers: Optional[String] = None\n    pilots: List[Person]\n    pilots_ids: List[ID]\n    starship_class: Optional[String] = None\n    typename__: Optional[Literal['Starship']] = Field('Starship', alias='__typename')\n\n\nclass Vehicle(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    cargo_capacity: Optional[String] = None\n    consumables: Optional[String] = None\n    cost_in_credits: Optional[String] = None\n    crew: Optional[String] = None\n    films: List[Film]\n    films_ids: List[ID]\n    id: ID\n    length: Optional[String] = None\n    manufacturer: Optional[String] = None\n    max_atmosphering_speed: Optional[String] = None\n    model: Optional[String] = None\n    name: String\n    passengers: Optional[String] = None\n    pilots: List[Person]\n    pilots_ids: List[ID]\n    vehicle_class: Optional[String] = None\n    typename__: Optional[Literal['Vehicle']] = Field('Vehicle', alias='__typename')\n\n\nFilm.update_forward_refs()\nPerson.update_forward_refs()\n</code></pre>","path":["CLI Reference","üè∑Ô∏è Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#field-constraints","level":2,"title":"<code>--field-constraints</code>","text":"<p>Generate Field() with validation constraints from schema.</p> <p>The <code>--field-constraints</code> flag generates Pydantic Field() definitions with validation constraints (min/max length, pattern, etc.) from the schema. Output differs between Pydantic v1 and v2 due to API changes.</p> <p>See also: Field Constraints</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --field-constraints # (1)!\n</code></pre> <ol> <li> <code>--field-constraints</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n            minimum: 0\n            maximum: 100\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          minimum: 0\n          maximum: 9223372036854775807\n        name:\n          type: string\n          maxLength: 256\n        tag:\n          type: string\n          maxLength: 64\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n      maxItems: 10\n      minItems: 1\n      uniqueItems: true\n    UID:\n      type: integer\n      minimum: 0\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n          - uid\n        properties:\n          id:\n            type: integer\n            format: int64\n            minimum: 0\n          name:\n            type: string\n            maxLength: 256\n          tag:\n            type: string\n            maxLength: 64\n          uid:\n            $ref: '#/components/schemas/UID'\n          phones:\n            type: array\n            items:\n              type: string\n              minLength: 3\n            maxItems: 10\n          fax:\n            type: array\n            items:\n              type: string\n              minLength: 3\n          height:\n            type:\n              - integer\n              - number\n            minimum: 1\n            maximum: 300\n          weight:\n            type:\n              - number\n              - integer\n            minimum: 1.0\n            maximum: 1000.0\n          age:\n            type: integer\n            minimum: 0.0\n            maximum: 200.0\n            exclusiveMinimum: true\n          rating:\n            type: number\n            minimum: 0\n            exclusiveMinimum: True\n            maximum: 5\n\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            minLength: 1\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output Pydantic v1Pydantic v2 <pre><code># generated by datamodel-codegen:\n#   filename:  api_constrained.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional, Union\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int = Field(..., ge=0, le=9223372036854775807)\n    name: str = Field(..., max_length=256)\n    tag: Optional[str] = Field(None, max_length=64)\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet] = Field(..., max_items=10, min_items=1, unique_items=True)\n\n\nclass UID(BaseModel):\n    __root__: int = Field(..., ge=0)\n\n\nclass Phone(BaseModel):\n    __root__: str = Field(..., min_length=3)\n\n\nclass FaxItem(BaseModel):\n    __root__: str = Field(..., min_length=3)\n\n\nclass User(BaseModel):\n    id: int = Field(..., ge=0)\n    name: str = Field(..., max_length=256)\n    tag: Optional[str] = Field(None, max_length=64)\n    uid: UID\n    phones: Optional[List[Phone]] = Field(None, max_items=10)\n    fax: Optional[List[FaxItem]] = None\n    height: Optional[Union[int, float]] = Field(None, ge=1.0, le=300.0)\n    weight: Optional[Union[float, int]] = Field(None, ge=1.0, le=1000.0)\n    age: Optional[int] = Field(None, gt=0, le=200)\n    rating: Optional[float] = Field(None, gt=0.0, le=5.0)\n\n\nclass Users(BaseModel):\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  api_constrained.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional, Union\n\nfrom pydantic import AnyUrl, BaseModel, Field, RootModel\n\n\nclass Pet(BaseModel):\n    id: int = Field(..., ge=0, le=9223372036854775807)\n    name: str = Field(..., max_length=256)\n    tag: Optional[str] = Field(None, max_length=64)\n\n\nclass Pets(RootModel[List[Pet]]):\n    root: List[Pet] = Field(..., max_length=10, min_length=1)\n\n\nclass UID(RootModel[int]):\n    root: int = Field(..., ge=0)\n\n\nclass Phone(RootModel[str]):\n    root: str = Field(..., min_length=3)\n\n\nclass FaxItem(RootModel[str]):\n    root: str = Field(..., min_length=3)\n\n\nclass User(BaseModel):\n    id: int = Field(..., ge=0)\n    name: str = Field(..., max_length=256)\n    tag: Optional[str] = Field(None, max_length=64)\n    uid: UID\n    phones: Optional[List[Phone]] = Field(None, max_length=10)\n    fax: Optional[List[FaxItem]] = None\n    height: Optional[Union[int, float]] = Field(None, ge=1.0, le=300.0)\n    weight: Optional[Union[float, int]] = Field(None, ge=1.0, le=1000.0)\n    age: Optional[int] = Field(None, gt=0, le=200)\n    rating: Optional[float] = Field(None, gt=0.0, le=5.0)\n\n\nclass Users(RootModel[List[User]]):\n    root: List[User]\n\n\nclass Id(RootModel[str]):\n    root: str\n\n\nclass Rules(RootModel[List[str]]):\n    root: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(RootModel[List[Api]]):\n    root: List[Api]\n\n\nclass Event(BaseModel):\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","üè∑Ô∏è Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#field-extra-keys","level":2,"title":"<code>--field-extra-keys</code>","text":"<p>Include specific extra keys in Field() definitions.</p> <p>The <code>--field-extra-keys</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --field-extra-keys key2 --field-extra-keys-without-x-prefix x-repr # (1)!\n</code></pre> <ol> <li> <code>--field-extra-keys</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Extras\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\",\n      \"description\": \"normal key\",\n      \"key1\": 123,\n      \"key2\": 456,\n      \"$exclude\": 123,\n      \"invalid-key-1\": \"abc\",\n      \"-invalid+key_2\": \"efg\",\n      \"$comment\": \"comment\",\n      \"$id\": \"#name\",\n      \"register\": \"hij\",\n      \"schema\": \"klm\",\n      \"x-repr\": true,\n      \"x-abc\": true,\n      \"example\": \"example\",\n      \"readOnly\": true\n    },\n    \"age\": {\n      \"type\": \"integer\",\n      \"example\": 12,\n      \"writeOnly\": true,\n      \"examples\": [\n        13,\n        20\n      ]\n    }\n  }\n}\n</code></pre> Output Pydantic v1Pydantic v2 <pre><code># generated by datamodel-codegen:\n#   filename:  extras.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Extras(BaseModel):\n    name: Optional[str] = Field(\n        None,\n        description='normal key',\n        example='example',\n        invalid_key_1='abc',\n        key2=456,\n        repr=True,\n    )\n    age: Optional[int] = Field(None, example=12, examples=[13, 20])\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  extras.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Extras(BaseModel):\n    name: Optional[str] = Field(\n        None,\n        description='normal key',\n        examples=['example'],\n        json_schema_extra={'key2': 456, 'invalid-key-1': 'abc'},\n        repr=True,\n    )\n    age: Optional[int] = Field(\n        None, examples=[13, 20], json_schema_extra={'example': 12}\n    )\n</code></pre>","path":["CLI Reference","üè∑Ô∏è Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#field-extra-keys-without-x-prefix","level":2,"title":"<code>--field-extra-keys-without-x-prefix</code>","text":"<p>Include specified schema extension keys in Field() without requiring 'x-' prefix.</p> <p>The --field-extra-keys-without-x-prefix option allows you to specify custom schema extension keys that should be included in Pydantic Field() extras without the 'x-' prefix requirement. For example, 'x-repr' in the schema becomes 'repr' in Field(). This is useful for custom schema extensions and vendor-specific metadata.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --field-include-all-keys --field-extra-keys-without-x-prefix x-repr # (1)!\n</code></pre> <ol> <li> <code>--field-extra-keys-without-x-prefix</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Extras\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\",\n      \"description\": \"normal key\",\n      \"key1\": 123,\n      \"key2\": 456,\n      \"$exclude\": 123,\n      \"invalid-key-1\": \"abc\",\n      \"-invalid+key_2\": \"efg\",\n      \"$comment\": \"comment\",\n      \"$id\": \"#name\",\n      \"register\": \"hij\",\n      \"schema\": \"klm\",\n      \"x-repr\": true,\n      \"x-abc\": true,\n      \"example\": \"example\",\n      \"readOnly\": true\n    },\n    \"age\": {\n      \"type\": \"integer\",\n      \"example\": 12,\n      \"writeOnly\": true,\n      \"examples\": [\n        13,\n        20\n      ]\n    }\n  }\n}\n</code></pre> Output Pydantic v1Pydantic v2 <pre><code># generated by datamodel-codegen:\n#   filename:  extras.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Extras(BaseModel):\n    name: Optional[str] = Field(\n        None,\n        description='normal key',\n        example='example',\n        field_comment='comment',\n        field_exclude=123,\n        field_invalid_key_2='efg',\n        invalid_key_1='abc',\n        key1=123,\n        key2=456,\n        readOnly=True,\n        register_='hij',\n        repr=True,\n        schema_='klm',\n        x_abc=True,\n    )\n    age: Optional[int] = Field(None, example=12, examples=[13, 20], writeOnly=True)\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  extras.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Extras(BaseModel):\n    name: Optional[str] = Field(\n        None,\n        description='normal key',\n        examples=['example'],\n        json_schema_extra={\n            'key1': 123,\n            'key2': 456,\n            '$exclude': 123,\n            'invalid-key-1': 'abc',\n            '-invalid+key_2': 'efg',\n            '$comment': 'comment',\n            'register': 'hij',\n            'schema': 'klm',\n            'x-abc': True,\n            'readOnly': True,\n        },\n        repr=True,\n    )\n    age: Optional[int] = Field(\n        None, examples=[13, 20], json_schema_extra={'example': 12, 'writeOnly': True}\n    )\n</code></pre>","path":["CLI Reference","üè∑Ô∏è Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#field-include-all-keys","level":2,"title":"<code>--field-include-all-keys</code>","text":"<p>Include all schema keys in Field() json_schema_extra.</p> <p>The <code>--field-include-all-keys</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --field-include-all-keys # (1)!\n</code></pre> <ol> <li> <code>--field-include-all-keys</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Person\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"firstName\": {\n      \"type\": \"string\",\n      \"description\": \"The person's first name.\"\n    },\n    \"lastName\": {\n      \"type\": [\"string\", \"null\"],\n      \"description\": \"The person's last name.\"\n    },\n    \"age\": {\n      \"description\": \"Age in years which must be equal to or greater than zero.\",\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"friends\": {\n      \"type\": \"array\"\n    },\n    \"comment\": {\n      \"type\": \"null\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  person.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Any, List, Optional\n\nfrom pydantic import BaseModel, Field, conint\n\n\nclass Person(BaseModel):\n    firstName: Optional[str] = Field(None, description=\"The person's first name.\")\n    lastName: Optional[str] = Field(None, description=\"The person's last name.\")\n    age: Optional[conint(ge=0)] = Field(\n        None, description='Age in years which must be equal to or greater than zero.'\n    )\n    friends: Optional[List[Any]] = None\n    comment: None = None\n</code></pre>","path":["CLI Reference","üè∑Ô∏è Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#no-alias","level":2,"title":"<code>--no-alias</code>","text":"<p>Disable Field alias generation for non-Python-safe property names.</p> <p>The <code>--no-alias</code> flag disables automatic alias generation when JSON property names contain characters invalid in Python (like hyphens). Without this flag, fields are renamed to Python-safe names with <code>Field(alias='original-name')</code>. With this flag, only Python-safe names are used without aliases.</p> <p>See also: Field Aliases</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --no-alias # (1)!\n</code></pre> <ol> <li> <code>--no-alias</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Person\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"first-name\": {\n      \"type\": \"string\"\n    },\n    \"last-name\": {\n      \"type\": \"string\"\n    },\n    \"email_address\": {\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\"first-name\", \"last-name\"]\n}\n</code></pre> Output With OptionWithout Option <pre><code># generated by datamodel-codegen:\n#   filename:  no_alias.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Person(BaseModel):\n    first_name: str\n    last_name: str\n    email_address: Optional[str] = None\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  no_alias.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Person(BaseModel):\n    first_name: str = Field(..., alias='first-name')\n    last_name: str = Field(..., alias='last-name')\n    email_address: Optional[str] = None\n</code></pre>","path":["CLI Reference","üè∑Ô∏è Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#original-field-name-delimiter","level":2,"title":"<code>--original-field-name-delimiter</code>","text":"<p>Specify delimiter for original field names when using snake-case conversion.</p> <p>The <code>--original-field-name-delimiter</code> option works with <code>--snake-case-field</code> to specify the delimiter used in original field names. This is useful when field names contain delimiters like spaces or hyphens that should be treated as word boundaries during snake_case conversion.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --snake-case-field --original-field-name-delimiter \" \" # (1)!\n</code></pre> <ol> <li> <code>--original-field-name-delimiter</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"SpaceIF\": {\n      \"$ref\": \"#/definitions/SpaceIF\"\n    }\n  },\n  \"definitions\": {\n    \"SpaceIF\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"Space Field\"\n      ]\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  space_field_enum.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass SpaceIF(Enum):\n    space_field = 'Space Field'\n\n\nclass Model(BaseModel):\n    space_if: Optional[SpaceIF] = Field(None, alias='SpaceIF')\n</code></pre>","path":["CLI Reference","üè∑Ô∏è Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#remove-special-field-name-prefix","level":2,"title":"<code>--remove-special-field-name-prefix</code>","text":"<p>Remove the special prefix from field names.</p> <p>The <code>--remove-special-field-name-prefix</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --remove-special-field-name-prefix # (1)!\n</code></pre> <ol> <li> <code>--remove-special-field-name-prefix</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n    \"$id\": \"schema_v2.json\",\n    \"$schema\": \"http://json-schema.org/schema#\",\n\n    \"type\": \"object\",\n    \"properties\": {\n        \"@id\": {\n            \"type\": \"string\",\n            \"format\": \"uri\",\n            \"pattern\": \"^http.*$\",\n            \"title\": \"Id must be presesnt and must be a URI\"\n        },\n        \"@type\": { \"type\": \"string\" },\n        \"@+!type\": { \"type\": \"string\" },\n        \"@-!type\": { \"type\": \"string\" },\n        \"profile\": { \"type\": \"string\" }\n    },\n    \"required\": [\"@id\", \"@type\"]\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  special_prefix_model.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Model(BaseModel):\n    id: AnyUrl = Field(..., alias='@id', title='Id must be presesnt and must be a URI')\n    type: str = Field(..., alias='@type')\n    type_1: Optional[str] = Field(None, alias='@+!type')\n    type_2: Optional[str] = Field(None, alias='@-!type')\n    profile: Optional[str] = None\n</code></pre>","path":["CLI Reference","üè∑Ô∏è Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#set-default-enum-member","level":2,"title":"<code>--set-default-enum-member</code>","text":"<p>Set the first enum member as the default value for enum fields.</p> <p>The <code>--set-default-enum-member</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --reuse-model --set-default-enum-member # (1)!\n</code></pre> <ol> <li> <code>--set-default-enum-member</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema\",\n  \"title\": \"User\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"animal\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"dog\",\n        \"cat\",\n        \"snake\"\n      ],\n      \"default\": \"dog\"\n    },\n    \"pet\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"dog\",\n        \"cat\",\n        \"snake\"\n      ],\n      \"default\": \"cat\"\n    },\n    \"redistribute\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\",\n        \"enum\": [\n          \"static\",\n          \"connected\"\n        ]\n      }\n    }\n  },\n  \"definitions\": {\n    \"redistribute\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\",\n        \"enum\": [\n          \"static\",\n          \"connected\"\n        ]\n      },\n      \"description\": \"Redistribute type for routes.\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  duplicate_enum.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Animal(Enum):\n    dog = 'dog'\n    cat = 'cat'\n    snake = 'snake'\n\n\nclass RedistributeEnum(Enum):\n    static = 'static'\n    connected = 'connected'\n\n\nclass User(BaseModel):\n    name: Optional[str] = None\n    animal: Optional[Animal] = Animal.dog\n    pet: Optional[Animal] = Animal.cat\n    redistribute: Optional[List[RedistributeEnum]] = None\n\n\nclass Redistribute(BaseModel):\n    __root__: List[RedistributeEnum] = Field(\n        ..., description='Redistribute type for routes.'\n    )\n</code></pre>","path":["CLI Reference","üè∑Ô∏è Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#snake-case-field","level":2,"title":"<code>--snake-case-field</code>","text":"<p>Convert field names to snake_case format.</p> <p>The <code>--snake-case-field</code> flag converts camelCase or PascalCase field names to snake_case format in the generated Python code, following Python naming conventions (PEP 8).</p> <p>Related: <code>--capitalize-enum-members</code></p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --snake-case-field # (1)!\n</code></pre> <ol> <li> <code>--snake-case-field</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"InvalidEnum\",\n  \"type\": \"string\",\n  \"enum\": [\n    \"1 value\",\n    \" space\",\n    \"*- special\",\n    \"schema\",\n    \"MRO\",\n    \"mro\"\n  ]\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  invalid_enum_name.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\n\n\nclass InvalidEnum(Enum):\n    field_1_value = '1 value'\n    field_space = ' space'\n    field___special = '*- special'\n    schema = 'schema'\n    mro_1 = 'MRO'\n    mro_ = 'mro'\n</code></pre>","path":["CLI Reference","üè∑Ô∏è Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#special-field-name-prefix","level":2,"title":"<code>--special-field-name-prefix</code>","text":"<p>Prefix to add to special field names (like reserved keywords).</p> <p>The <code>--special-field-name-prefix</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --special-field-name-prefix special # (1)!\n</code></pre> <ol> <li> <code>--special-field-name-prefix</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"string\",\n  \"enum\": [\n    true,\n    false,\n    \"\",\n    \"\\n\",\n    \"\\r\\n\",\n    \"\\t\",\n    \"\\b\",\n    null,\n    \"\\\\\"\n  ]\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  special_enum.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass ModelEnum(Enum):\n    True_ = True\n    False_ = False\n    special_ = ''\n    special__1 = '\\n'\n    special__ = '\\r\\n'\n    special__2 = '\\t'\n    special__3 = '\\b'\n    special__4 = '\\\\'\n\n\nclass Model(BaseModel):\n    __root__: Optional[ModelEnum] = None\n</code></pre>","path":["CLI Reference","üè∑Ô∏è Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#use-attribute-docstrings","level":2,"title":"<code>--use-attribute-docstrings</code>","text":"<p>Generate field descriptions as attribute docstrings instead of Field descriptions.</p> <p>The <code>--use-attribute-docstrings</code> flag places field descriptions in Python docstring format (PEP 224 attribute docstrings) rather than in Field(..., description=...). This provides better IDE support for hovering over attributes. Requires <code>--use-field-description</code> to be enabled.</p> <p>Related: <code>--use-field-description</code></p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --output-model-type pydantic_v2.BaseModel --use-field-description --use-attribute-docstrings # (1)!\n</code></pre> <ol> <li> <code>--use-attribute-docstrings</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"object\",\n  \"title\": \"Person\",\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\",\n      \"description\": \"The person's full name\"\n    },\n    \"age\": {\n      \"type\": \"integer\",\n      \"description\": \"The person's age in years\"\n    }\n  },\n  \"required\": [\"name\"]\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  use_attribute_docstrings_test.json\n#   timestamp: 1985-10-26T08:21:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Person(BaseModel):\n    model_config = ConfigDict(\n        use_attribute_docstrings=True,\n    )\n    name: str\n    \"\"\"\n    The person's full name\n    \"\"\"\n    age: Optional[int] = None\n    \"\"\"\n    The person's age in years\n    \"\"\"\n</code></pre>","path":["CLI Reference","üè∑Ô∏è Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#use-enum-values-in-discriminator","level":2,"title":"<code>--use-enum-values-in-discriminator</code>","text":"<p>Use enum values in discriminator mappings for union types.</p> <p>The <code>--use-enum-values-in-discriminator</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-enum-values-in-discriminator --output-model-type pydantic_v2.BaseModel # (1)!\n</code></pre> <ol> <li> <code>--use-enum-values-in-discriminator</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ncomponents:\n  schemas:\n    Request:\n      oneOf:\n        - $ref: '#/components/schemas/RequestV1'\n        - $ref: '#/components/schemas/RequestV2'\n      discriminator:\n        propertyName: version\n        mapping:\n          v1: '#/components/schemas/RequestV1'\n          v2: '#/components/schemas/RequestV2'\n\n    RequestVersionEnum:\n      type: string\n      description: this is not included!\n      title: no title!\n      enum:\n        - v1\n        - v2\n    RequestBase:\n      properties:\n        version:\n          $ref: '#/components/schemas/RequestVersionEnum'\n      required:\n        - version\n\n    RequestV1:\n      allOf:\n        - $ref: '#/components/schemas/RequestBase'\n      properties:\n        request_id:\n          type: string\n          title: test title\n          description: there is description\n      required:\n        - request_id\n    RequestV2:\n      allOf:\n        - $ref: '#/components/schemas/RequestBase'\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  discriminator_enum.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, RootModel\n\n\nclass RequestVersionEnum(Enum):\n    v1 = 'v1'\n    v2 = 'v2'\n\n\nclass RequestBase(BaseModel):\n    version: RequestVersionEnum\n\n\nclass RequestV1(RequestBase):\n    request_id: str = Field(..., description='there is description', title='test title')\n    version: Literal[RequestVersionEnum.v1]\n\n\nclass RequestV2(RequestBase):\n    version: Literal[RequestVersionEnum.v2]\n\n\nclass Request(RootModel[Union[RequestV1, RequestV2]]):\n    root: Union[RequestV1, RequestV2] = Field(..., discriminator='version')\n</code></pre>","path":["CLI Reference","üè∑Ô∏è Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#use-field-description","level":2,"title":"<code>--use-field-description</code>","text":"<p>Include schema descriptions as Field docstrings.</p> <p>The <code>--use-field-description</code> flag extracts the <code>description</code> property from schema fields and includes them as docstrings or Field descriptions in the generated models, preserving documentation from the original schema.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-type-alias --use-field-description # (1)!\n</code></pre> <ol> <li> <code>--use-field-description</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"definitions\": {\n    \"SimpleString\": {\n      \"type\": \"string\"\n    },\n    \"UnionType\": {\n      \"anyOf\": [\n        {\"type\": \"string\"},\n        {\"type\": \"integer\"}\n      ]\n    },\n    \"ArrayType\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"}\n    },\n    \"AnnotatedType\": {\n      \"title\": \"MyAnnotatedType\",\n      \"description\": \"An annotated union type\",\n      \"anyOf\": [\n        {\"type\": \"string\"},\n        {\"type\": \"boolean\"}\n      ]\n    },\n    \"ModelWithTypeAliasField\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"simple_field\": {\"$ref\": \"#/definitions/SimpleString\"},\n        \"union_field\": {\"$ref\": \"#/definitions/UnionType\"},\n        \"array_field\": {\"$ref\": \"#/definitions/ArrayType\"},\n        \"annotated_field\": {\"$ref\": \"#/definitions/AnnotatedType\"}\n      }\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  type_alias.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Annotated, Any, List, Optional, Union\n\nfrom pydantic import BaseModel, Field\nfrom typing_extensions import TypeAlias\n\nModel: TypeAlias = Any\n\n\nSimpleString: TypeAlias = str\n\n\nUnionType: TypeAlias = Union[str, int]\n\n\nArrayType: TypeAlias = List[str]\n\n\nAnnotatedType: TypeAlias = Annotated[\n    Union[str, bool], Field(..., title='MyAnnotatedType')\n]\n\"\"\"\nAn annotated union type\n\"\"\"\n\n\nclass ModelWithTypeAliasField(BaseModel):\n    simple_field: Optional[SimpleString] = None\n    union_field: Optional[UnionType] = None\n    array_field: Optional[ArrayType] = None\n    annotated_field: Optional[AnnotatedType] = None\n</code></pre>","path":["CLI Reference","üè∑Ô∏è Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#use-inline-field-description","level":2,"title":"<code>--use-inline-field-description</code>","text":"<p>Add field descriptions as inline comments.</p> <p>The <code>--use-inline-field-description</code> flag adds the <code>description</code> property from schema fields as inline comments after each field definition. This provides documentation without using Field() wrappers.</p> <p>Related: <code>--use-field-description</code>, <code>--use-schema-description</code></p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-inline-field-description # (1)!\n</code></pre> <ol> <li> <code>--use-inline-field-description</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: \"error result.\\nNow with multi-line docstrings.\"\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: \"To be used as a dataset parameter value.\\nNow also with multi-line docstrings.\"\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  api_multiline_docstrings.yaml\n#   timestamp: 2022-11-11T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(BaseModel):\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None,\n        description='To be used as a dataset parameter value.\\nNow also with multi-line docstrings.',\n    )\n    \"\"\"\n    To be used as a dataset parameter value.\n    Now also with multi-line docstrings.\n    \"\"\"\n\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    \"\"\"To be used as a version parameter value\"\"\"\n\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    \"\"\"The URL describing the dataset's fields\"\"\"\n\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n    \"\"\"A URL to the API console for each API\"\"\"\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","üè∑Ô∏è Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#use-schema-description","level":2,"title":"<code>--use-schema-description</code>","text":"<p>Use schema description as class docstring.</p> <p>The <code>--use-schema-description</code> flag extracts the <code>description</code> property from schema definitions and adds it as a docstring to the generated class. This is useful for preserving documentation from your schema in the generated code.</p> <p>Related: <code>--use-field-description</code>, <code>--use-inline-field-description</code></p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-schema-description # (1)!\n</code></pre> <ol> <li> <code>--use-schema-description</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: \"error result.\\nNow with multi-line docstrings.\"\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: \"To be used as a dataset parameter value.\\nNow also with multi-line docstrings.\"\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  api_multiline_docstrings.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(BaseModel):\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    \"\"\"\n    error result.\n    Now with multi-line docstrings.\n    \"\"\"\n\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None,\n        description='To be used as a dataset parameter value.\\nNow also with multi-line docstrings.',\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    \"\"\"\n    Event object\n    \"\"\"\n\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","üè∑Ô∏è Field Customization"],"tags":[]},{"location":"cli-reference/field-customization/#use-title-as-name","level":2,"title":"<code>--use-title-as-name</code>","text":"<p>Use schema title as the generated class name.</p> <p>The <code>--use-title-as-name</code> flag uses the <code>title</code> property from the schema as the class name instead of deriving it from the property name or path. This is useful when schemas have descriptive titles that should be preserved.</p> <p>Related: <code>--class-name</code></p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-title-as-name # (1)!\n</code></pre> <ol> <li> <code>--use-title-as-name</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"definitions\": {\n    \"ProcessingStatus\": {\n      \"title\": \"Processing Status Title\",\n      \"enum\": [\n        \"COMPLETED\",\n        \"PENDING\",\n        \"FAILED\"\n      ],\n      \"type\": \"string\",\n      \"description\": \"The processing status\"\n    },\n    \"kind\": {\n      \"type\": \"string\"\n    },\n    \"ExtendedProcessingTask\": {\n      \"title\": \"Extended Processing Task Title\",\n      \"oneOf\": [\n        {\n          \"$ref\": \"#\"\n        },\n        {\n          \"type\": \"object\",\n          \"title\": \"NestedCommentTitle\",\n          \"properties\": {\n            \"comment\": {\n              \"type\": \"string\"\n            }\n          }\n        }\n      ]\n    },\n    \"ExtendedProcessingTasks\": {\n      \"title\": \"Extended Processing Tasks Title\",\n      \"type\": \"array\",\n      \"items\": [\n        {\n          \"$ref\": \"#/definitions/ExtendedProcessingTask\"\n        }\n      ]\n    },\n    \"ProcessingTask\": {\n      \"title\": \"Processing Task Title\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"processing_status_union\": {\n          \"title\": \"Processing Status Union Title\",\n          \"oneOf\": [\n            {\n              \"title\": \"Processing Status Detail\",\n              \"type\": \"object\",\n              \"properties\": {\n                \"id\": {\n                  \"type\": \"integer\"\n                },\n                \"description\": {\n                  \"type\": \"string\"\n                }\n              }\n            },\n            {\n              \"$ref\": \"#/definitions/ExtendedProcessingTask\"\n            },\n            {\n              \"$ref\": \"#/definitions/ProcessingStatus\"\n            }\n          ],\n          \"default\": \"COMPLETED\"\n        },\n        \"processing_status\": {\n          \"$ref\": \"#/definitions/ProcessingStatus\",\n          \"default\": \"COMPLETED\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"kind\": {\n          \"$ref\": \"#/definitions/kind\"\n        }\n      }\n    }\n  },\n  \"title\": \"Processing Tasks Title\",\n  \"type\": \"array\",\n      \"items\": [\n        {\n          \"$ref\": \"#/definitions/ProcessingTask\"\n        }\n      ]\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  titles.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import List, Optional, Union\n\nfrom pydantic import BaseModel, Field\n\n\nclass ProcessingStatusTitle(Enum):\n    COMPLETED = 'COMPLETED'\n    PENDING = 'PENDING'\n    FAILED = 'FAILED'\n\n\nclass Kind(BaseModel):\n    __root__: str\n\n\nclass NestedCommentTitle(BaseModel):\n    comment: Optional[str] = None\n\n\nclass ProcessingStatusDetail(BaseModel):\n    id: Optional[int] = None\n    description: Optional[str] = None\n\n\nclass ProcessingTasksTitle(BaseModel):\n    __root__: List[ProcessingTaskTitle] = Field(..., title='Processing Tasks Title')\n\n\nclass ExtendedProcessingTask(BaseModel):\n    __root__: Union[ProcessingTasksTitle, NestedCommentTitle] = Field(\n        ..., title='Extended Processing Task Title'\n    )\n\n\nclass ExtendedProcessingTasksTitle(BaseModel):\n    __root__: List[ExtendedProcessingTask] = Field(\n        ..., title='Extended Processing Tasks Title'\n    )\n\n\nclass ProcessingTaskTitle(BaseModel):\n    processing_status_union: Optional[\n        Union[ProcessingStatusDetail, ExtendedProcessingTask, ProcessingStatusTitle]\n    ] = Field('COMPLETED', title='Processing Status Union Title')\n    processing_status: Optional[ProcessingStatusTitle] = 'COMPLETED'\n    name: Optional[str] = None\n    kind: Optional[Kind] = None\n\n\nProcessingTasksTitle.update_forward_refs()\n</code></pre>","path":["CLI Reference","üè∑Ô∏è Field Customization"],"tags":[]},{"location":"cli-reference/general-options/","level":1,"title":"‚öôÔ∏è General Options","text":"","path":["CLI Reference","‚öôÔ∏è General Options"],"tags":[]},{"location":"cli-reference/general-options/#options","level":2,"title":"üìã Options","text":"Option Description <code>--all-exports-collision-strategy</code> Handle name collisions when exporting recursive module hiera... <code>--all-exports-scope</code> Generate all exports for child modules in init.py fi... <code>--check</code> Verify generated code matches existing output without modify... <code>--disable-warnings</code> Suppress warning messages during code generation. <code>--generate-cli-command</code> Generate CLI command from pyproject.toml configuration. <code>--generate-pyproject-config</code> Generate pyproject.toml configuration from CLI arguments. <code>--http-headers</code> Fetch schema from URL with custom HTTP headers. <code>--http-ignore-tls</code> Disable TLS certificate verification for HTTPS requests. <code>--http-query-parameters</code> Add query parameters to HTTP requests for remote schemas. <code>--ignore-pyproject</code> Ignore pyproject.toml configuration file. <code>--shared-module-name</code> Customize the name of the shared module for deduplicated mod... <code>--watch</code> Watch mode cannot be used with --check mode. <code>--watch-delay</code> Watch mode starts file watcher and handles clean exit.","path":["CLI Reference","‚öôÔ∏è General Options"],"tags":[]},{"location":"cli-reference/general-options/#all-exports-collision-strategy","level":2,"title":"<code>--all-exports-collision-strategy</code>","text":"<p>Handle name collisions when exporting recursive module hierarchies.</p> <p>The <code>--all-exports-collision-strategy</code> flag determines how to resolve naming conflicts when using <code>--all-exports-scope=recursive</code>. The 'minimal-prefix' strategy adds the minimum module path prefix needed to disambiguate colliding names, while 'full-prefix' uses the complete module path. Requires <code>--all-exports-scope=recursive</code>.</p> <p>Related: <code>--all-exports-scope</code></p> <p>See also: Module Structure and Exports</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --all-exports-scope recursive --all-exports-collision-strategy minimal-prefix # (1)!\n</code></pre> <ol> <li> <code>--all-exports-collision-strategy</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Modular Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/collections.Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/collections.Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    models.Species:\n      type: string\n      enum:\n        - dog\n        - cat\n        - snake\n    models.Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        tag:\n          type: string\n        species:\n          $ref: '#/components/schemas/models.Species'\n    models.User:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        tag:\n          type: string\n    collections.Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/models.Pet\"\n    collections.Users:\n      type: array\n      items:\n        $ref: \"#/components/schemas/models.User\"\n    optional:\n      type: string\n    Id:\n      type: string\n    collections.Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    collections.apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n          stage:\n            type: string\n            enum: [\n              \"test\",\n              \"dev\",\n              \"stg\",\n              \"prod\"\n            ]\n    models.Event:\n      type: object\n      properties:\n        name:\n          anyOf:\n            - type: string\n            - type: number\n            - type: integer\n            - type: boolean\n            - type: object\n            - type: array\n              items:\n                type: string\n    Result:\n      type: object\n      properties:\n        event:\n          $ref: '#/components/schemas/models.Event'\n    foo.bar.Thing:\n      properties:\n        attributes:\n          type: object\n    foo.bar.Thang:\n      properties:\n        attributes:\n          type: array\n          items:\n            type: object\n    foo.bar.Clone:\n      allOf:\n        - $ref: '#/components/schemas/foo.bar.Thing'\n        - type: object\n          properties:\n            others:\n              type: object\n              properties:\n                 name:\n                   type: string\n\n    foo.Tea:\n      properties:\n        flavour:\n          type: string\n        id:\n          $ref: '#/components/schemas/Id'\n    Source:\n      properties:\n        country:\n          type: string\n    foo.Cocoa:\n      properties:\n        quality:\n          type: integer\n    bar.Field:\n      type: string\n      example: green\n    woo.boo.Chocolate:\n      properties:\n        flavour:\n          type: string\n        source:\n          $ref: '#/components/schemas/Source'\n        cocoa:\n          $ref: '#/components/schemas/foo.Cocoa'\n        field:\n          $ref: '#/components/schemas/bar.Field'\n    differentTea:\n      type: object\n      properties:\n        foo:\n          $ref: '#/components/schemas/foo.Tea'\n        nested:\n          $ref: '#/components/schemas/nested.foo.Tea'\n    nested.foo.Tea:\n      properties:\n        flavour:\n          type: string\n        id:\n          $ref: '#/components/schemas/Id'\n        self:\n          $ref: '#/components/schemas/nested.foo.Tea'\n        optional:\n          type: array\n          items:\n            $ref: '#/components/schemas/optional'\n    nested.foo.TeaClone:\n      properties:\n        flavour:\n          type: string\n        id:\n          $ref: '#/components/schemas/Id'\n        self:\n          $ref: '#/components/schemas/nested.foo.Tea'\n        optional:\n          type: array\n          items:\n            $ref: '#/components/schemas/optional'\n    nested.foo.List:\n      type: array\n      items:\n        $ref: '#/components/schemas/nested.foo.Tea'\n</code></pre> Output <pre><code># __init__.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom ._internal import DifferentTea, Error, Id, OptionalModel, Result, Source\n\n__all__ = [\"DifferentTea\", \"Error\", \"Id\", \"OptionalModel\", \"Result\", \"Source\"]\n\n# _internal.py\n# generated by datamodel-codegen:\n#   filename:  _internal\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel\n\nfrom . import models\n\n\nclass OptionalModel(BaseModel):\n    __root__: str\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Result(BaseModel):\n    event: Optional[models.Event] = None\n\n\nclass Source(BaseModel):\n    country: Optional[str] = None\n\n\nclass DifferentTea(BaseModel):\n    foo: Optional[Tea] = None\n    nested: Optional[Tea_1] = None\n\n\nclass Tea(BaseModel):\n    flavour: Optional[str] = None\n    id: Optional[Id] = None\n\n\nclass Cocoa(BaseModel):\n    quality: Optional[int] = None\n\n\nclass Tea_1(BaseModel):\n    flavour: Optional[str] = None\n    id: Optional[Id] = None\n    self: Optional[Tea_1] = None\n    optional: Optional[List[OptionalModel]] = None\n\n\nclass TeaClone(BaseModel):\n    flavour: Optional[str] = None\n    id: Optional[Id] = None\n    self: Optional[Tea_1] = None\n    optional: Optional[List[OptionalModel]] = None\n\n\nclass ListModel(BaseModel):\n    __root__: List[Tea_1]\n\n\nTea_1.update_forward_refs()\n\n# bar.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel, Field\n\n\nclass FieldModel(BaseModel):\n    __root__: str = Field(..., example='green')\n\n# collections.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\nfrom . import models\n\n\nclass Pets(BaseModel):\n    __root__: List[models.Pet]\n\n\nclass Users(BaseModel):\n    __root__: List[models.User]\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Stage(Enum):\n    test = 'test'\n    dev = 'dev'\n    stg = 'stg'\n    prod = 'prod'\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n    stage: Optional[Stage] = None\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n# foo/__init__.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom .._internal import Cocoa, Tea\n\n__all__ = [\"Cocoa\", \"Tea\"]\n\n# foo/bar.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom __future__ import annotations\n\nfrom typing import Any, Dict, List, Optional\n\nfrom pydantic import BaseModel\n\n\nclass Thing(BaseModel):\n    attributes: Optional[Dict[str, Any]] = None\n\n\nclass Thang(BaseModel):\n    attributes: Optional[List[Dict[str, Any]]] = None\n\n\nclass Others(BaseModel):\n    name: Optional[str] = None\n\n\nclass Clone(Thing):\n    others: Optional[Others] = None\n\n# models.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Union\n\nfrom pydantic import BaseModel\n\n\nclass Species(Enum):\n    dog = 'dog'\n    cat = 'cat'\n    snake = 'snake'\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n    species: Optional[Species] = None\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Event(BaseModel):\n    name: Optional[Union[str, float, int, bool, Dict[str, Any], List[str]]] = None\n\n# nested/__init__.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\n# nested/foo.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom .._internal import ListModel\nfrom .._internal import Tea_1 as Tea\nfrom .._internal import TeaClone\n\n__all__ = [\"ListModel\", \"Tea\", \"TeaClone\"]\n\n# woo/__init__.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom __future__ import annotations\n\nfrom .boo import Chocolate\n\n__all__ = [\n    \"Chocolate\",\n]\n\n# woo/boo.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\nfrom .. import bar\nfrom .._internal import Cocoa, Source\n\n\nclass Chocolate(BaseModel):\n    flavour: Optional[str] = None\n    source: Optional[Source] = None\n    cocoa: Optional[Cocoa] = None\n    field: Optional[bar.FieldModel] = None\n</code></pre>","path":["CLI Reference","‚öôÔ∏è General Options"],"tags":[]},{"location":"cli-reference/general-options/#all-exports-scope","level":2,"title":"<code>--all-exports-scope</code>","text":"<p>Generate all exports for child modules in init.py files.</p> <p>The <code>--all-exports-scope=children</code> flag adds all to each init.py containing exports from direct child modules. This improves IDE autocomplete and explicit exports. Use 'recursive' to include all descendant exports with collision handling.</p> <p>Related: <code>--all-exports-collision-strategy</code></p> <p>See also: Module Structure and Exports</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --all-exports-scope children # (1)!\n</code></pre> <ol> <li> <code>--all-exports-scope</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Modular Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/collections.Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/collections.Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    models.Species:\n      type: string\n      enum:\n        - dog\n        - cat\n        - snake\n    models.Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        tag:\n          type: string\n        species:\n          $ref: '#/components/schemas/models.Species'\n    models.User:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        tag:\n          type: string\n    collections.Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/models.Pet\"\n    collections.Users:\n      type: array\n      items:\n        $ref: \"#/components/schemas/models.User\"\n    optional:\n      type: string\n    Id:\n      type: string\n    collections.Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    collections.apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n          stage:\n            type: string\n            enum: [\n              \"test\",\n              \"dev\",\n              \"stg\",\n              \"prod\"\n            ]\n    models.Event:\n      type: object\n      properties:\n        name:\n          anyOf:\n            - type: string\n            - type: number\n            - type: integer\n            - type: boolean\n            - type: object\n            - type: array\n              items:\n                type: string\n    Result:\n      type: object\n      properties:\n        event:\n          $ref: '#/components/schemas/models.Event'\n    foo.bar.Thing:\n      properties:\n        attributes:\n          type: object\n    foo.bar.Thang:\n      properties:\n        attributes:\n          type: array\n          items:\n            type: object\n    foo.bar.Clone:\n      allOf:\n        - $ref: '#/components/schemas/foo.bar.Thing'\n        - type: object\n          properties:\n            others:\n              type: object\n              properties:\n                 name:\n                   type: string\n\n    foo.Tea:\n      properties:\n        flavour:\n          type: string\n        id:\n          $ref: '#/components/schemas/Id'\n    Source:\n      properties:\n        country:\n          type: string\n    foo.Cocoa:\n      properties:\n        quality:\n          type: integer\n    bar.Field:\n      type: string\n      example: green\n    woo.boo.Chocolate:\n      properties:\n        flavour:\n          type: string\n        source:\n          $ref: '#/components/schemas/Source'\n        cocoa:\n          $ref: '#/components/schemas/foo.Cocoa'\n        field:\n          $ref: '#/components/schemas/bar.Field'\n    differentTea:\n      type: object\n      properties:\n        foo:\n          $ref: '#/components/schemas/foo.Tea'\n        nested:\n          $ref: '#/components/schemas/nested.foo.Tea'\n    nested.foo.Tea:\n      properties:\n        flavour:\n          type: string\n        id:\n          $ref: '#/components/schemas/Id'\n        self:\n          $ref: '#/components/schemas/nested.foo.Tea'\n        optional:\n          type: array\n          items:\n            $ref: '#/components/schemas/optional'\n    nested.foo.TeaClone:\n      properties:\n        flavour:\n          type: string\n        id:\n          $ref: '#/components/schemas/Id'\n        self:\n          $ref: '#/components/schemas/nested.foo.Tea'\n        optional:\n          type: array\n          items:\n            $ref: '#/components/schemas/optional'\n    nested.foo.List:\n      type: array\n      items:\n        $ref: '#/components/schemas/nested.foo.Tea'\n</code></pre> Output <pre><code># __init__.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom ._internal import DifferentTea, Error, Id, OptionalModel, Result, Source\n\n__all__ = [\"DifferentTea\", \"Error\", \"Id\", \"OptionalModel\", \"Result\", \"Source\"]\n\n# _internal.py\n# generated by datamodel-codegen:\n#   filename:  _internal\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel\n\nfrom . import models\n\n\nclass OptionalModel(BaseModel):\n    __root__: str\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Result(BaseModel):\n    event: Optional[models.Event] = None\n\n\nclass Source(BaseModel):\n    country: Optional[str] = None\n\n\nclass DifferentTea(BaseModel):\n    foo: Optional[Tea] = None\n    nested: Optional[Tea_1] = None\n\n\nclass Tea(BaseModel):\n    flavour: Optional[str] = None\n    id: Optional[Id] = None\n\n\nclass Cocoa(BaseModel):\n    quality: Optional[int] = None\n\n\nclass Tea_1(BaseModel):\n    flavour: Optional[str] = None\n    id: Optional[Id] = None\n    self: Optional[Tea_1] = None\n    optional: Optional[List[OptionalModel]] = None\n\n\nclass TeaClone(BaseModel):\n    flavour: Optional[str] = None\n    id: Optional[Id] = None\n    self: Optional[Tea_1] = None\n    optional: Optional[List[OptionalModel]] = None\n\n\nclass ListModel(BaseModel):\n    __root__: List[Tea_1]\n\n\nTea_1.update_forward_refs()\n\n# bar.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel, Field\n\n\nclass FieldModel(BaseModel):\n    __root__: str = Field(..., example='green')\n\n# collections.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\nfrom . import models\n\n\nclass Pets(BaseModel):\n    __root__: List[models.Pet]\n\n\nclass Users(BaseModel):\n    __root__: List[models.User]\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Stage(Enum):\n    test = 'test'\n    dev = 'dev'\n    stg = 'stg'\n    prod = 'prod'\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n    stage: Optional[Stage] = None\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n# foo/__init__.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom .._internal import Cocoa, Tea\n\n__all__ = [\"Cocoa\", \"Tea\"]\n\n# foo/bar.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom __future__ import annotations\n\nfrom typing import Any, Dict, List, Optional\n\nfrom pydantic import BaseModel\n\n\nclass Thing(BaseModel):\n    attributes: Optional[Dict[str, Any]] = None\n\n\nclass Thang(BaseModel):\n    attributes: Optional[List[Dict[str, Any]]] = None\n\n\nclass Others(BaseModel):\n    name: Optional[str] = None\n\n\nclass Clone(Thing):\n    others: Optional[Others] = None\n\n# models.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Union\n\nfrom pydantic import BaseModel\n\n\nclass Species(Enum):\n    dog = 'dog'\n    cat = 'cat'\n    snake = 'snake'\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n    species: Optional[Species] = None\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Event(BaseModel):\n    name: Optional[Union[str, float, int, bool, Dict[str, Any], List[str]]] = None\n\n# nested/__init__.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\n# nested/foo.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom .._internal import ListModel\nfrom .._internal import Tea_1 as Tea\nfrom .._internal import TeaClone\n\n__all__ = [\"ListModel\", \"Tea\", \"TeaClone\"]\n\n# woo/__init__.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom __future__ import annotations\n\nfrom .boo import Chocolate\n\n__all__ = [\n    \"Chocolate\",\n]\n\n# woo/boo.py\n# generated by datamodel-codegen:\n#   filename:  modular.yaml\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\nfrom .. import bar\nfrom .._internal import Cocoa, Source\n\n\nclass Chocolate(BaseModel):\n    flavour: Optional[str] = None\n    source: Optional[Source] = None\n    cocoa: Optional[Cocoa] = None\n    field: Optional[bar.FieldModel] = None\n</code></pre>","path":["CLI Reference","‚öôÔ∏è General Options"],"tags":[]},{"location":"cli-reference/general-options/#check","level":2,"title":"<code>--check</code>","text":"<p>Verify generated code matches existing output without modifying files.</p> <p>The <code>--check</code> flag compares the generated output with existing files and exits with a non-zero status if they differ. Useful for CI/CD validation to ensure schemas and generated code stay in sync. Works with both single files and directory outputs.</p> <p>See also: CI/CD Integration</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --disable-timestamp --check # (1)!\n</code></pre> <ol> <li> <code>--check</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Person\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"firstName\": {\n      \"type\": \"string\",\n      \"description\": \"The person's first name.\"\n    },\n    \"lastName\": {\n      \"type\": [\"string\", \"null\"],\n      \"description\": \"The person's last name.\"\n    },\n    \"age\": {\n      \"description\": \"Age in years which must be equal to or greater than zero.\",\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"friends\": {\n      \"type\": \"array\"\n    },\n    \"comment\": {\n      \"type\": \"null\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  person.json\n\nfrom __future__ import annotations\n\nfrom typing import Any, List, Optional\n\nfrom pydantic import BaseModel, Field, conint\n\n\nclass Person(BaseModel):\n    firstName: Optional[str] = Field(None, description=\"The person's first name.\")\n    lastName: Optional[str] = Field(None, description=\"The person's last name.\")\n    age: Optional[conint(ge=0)] = Field(\n        None, description='Age in years which must be equal to or greater than zero.'\n    )\n    friends: Optional[List[Any]] = None\n    comment: None = None\n</code></pre>","path":["CLI Reference","‚öôÔ∏è General Options"],"tags":[]},{"location":"cli-reference/general-options/#disable-warnings","level":2,"title":"<code>--disable-warnings</code>","text":"<p>Suppress warning messages during code generation.</p> <p>The --disable-warnings option silences all warning messages that the generator might emit during processing (e.g., about unsupported features, ambiguous schemas, or potential issues). Useful for clean output in CI/CD pipelines.</p> <p>See also: Model Reuse and Deduplication</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --disable-warnings # (1)!\n</code></pre> <ol> <li> <code>--disable-warnings</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Pet\",\n  \"allOf\": [\n    {\n      \"$ref\": \"#/definitions/Home\"\n    },\n    {\n      \"$ref\": \"#/definitions/Kind\"\n    },\n    {\n      \"$ref\": \"#/definitions/Id\"\n    },\n    {\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"type\": \"string\"\n        }\n      }\n    }\n  ],\n  \"type\": [\n    \"object\"\n  ],\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"age\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"definitions\": {\n    \"Home\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"address\": {\n          \"type\": \"string\"\n        },\n        \"zip\": {\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"Kind\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"description\": {\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"Id\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"id\": {\n          \"type\": \"integer\"\n        }\n      }\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  all_of_with_object.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Home(BaseModel):\n    address: Optional[str] = None\n    zip: Optional[str] = None\n\n\nclass Kind(BaseModel):\n    description: Optional[str] = None\n\n\nclass Id(BaseModel):\n    id: Optional[int] = None\n\n\nclass Pet(Home, Kind, Id):\n    name: Optional[str] = None\n    age: Optional[int] = None\n</code></pre>","path":["CLI Reference","‚öôÔ∏è General Options"],"tags":[]},{"location":"cli-reference/general-options/#generate-cli-command","level":2,"title":"<code>--generate-cli-command</code>","text":"<p>Generate CLI command from pyproject.toml configuration.</p> <p>The <code>--generate-cli-command</code> flag reads your pyproject.toml configuration and outputs the equivalent CLI command. This is useful for debugging configuration issues or sharing commands with others.</p> <p>See also: pyproject.toml Configuration</p> <p>Usage</p> <pre><code>datamodel-codegen --generate-cli-command # (1)!\n</code></pre> <ol> <li> <code>--generate-cli-command</code> - the option documented here</li> </ol> Configuration (pyproject.toml) <pre><code>[tool.datamodel-codegen]\ninput = \"schema.yaml\"\noutput = \"model.py\"\n</code></pre> Output <pre><code>datamodel-codegen --input schema.yaml --output model.py\n</code></pre>","path":["CLI Reference","‚öôÔ∏è General Options"],"tags":[]},{"location":"cli-reference/general-options/#generate-pyproject-config","level":2,"title":"<code>--generate-pyproject-config</code>","text":"<p>Generate pyproject.toml configuration from CLI arguments.</p> <p>The <code>--generate-pyproject-config</code> flag outputs a pyproject.toml configuration snippet based on the provided CLI arguments. This is useful for converting a working CLI command into a reusable configuration file.</p> <p>See also: pyproject.toml Configuration</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --generate-pyproject-config --input schema.yaml --output model.py # (1)!\n</code></pre> <ol> <li> <code>--generate-pyproject-config</code> - the option documented here</li> </ol> Output <pre><code>[tool.datamodel-codegen]\ninput = \"schema.yaml\"\noutput = \"model.py\"\n</code></pre>","path":["CLI Reference","‚öôÔ∏è General Options"],"tags":[]},{"location":"cli-reference/general-options/#http-headers","level":2,"title":"<code>--http-headers</code>","text":"<p>Fetch schema from URL with custom HTTP headers.</p> <p>The <code>--url</code> flag specifies a remote URL to fetch the schema from instead of a local file. The <code>--http-headers</code> flag adds custom HTTP headers to the request, useful for authentication (e.g., Bearer tokens) or custom API requirements. Format: <code>HeaderName:HeaderValue</code>.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --url https://api.example.com/schema.json --http-headers \"Authorization:Bearer token\" # (1)!\n</code></pre> <ol> <li> <code>--http-headers</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Pet\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"tag\": {\n      \"type\": \"string\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  https://api.example.com/schema.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    id: Optional[int] = None\n    name: Optional[str] = None\n    tag: Optional[str] = None\n</code></pre>","path":["CLI Reference","‚öôÔ∏è General Options"],"tags":[]},{"location":"cli-reference/general-options/#http-ignore-tls","level":2,"title":"<code>--http-ignore-tls</code>","text":"<p>Disable TLS certificate verification for HTTPS requests.</p> <p>The <code>--http-ignore-tls</code> flag disables SSL/TLS certificate verification when fetching schemas from HTTPS URLs. This is useful for development environments with self-signed certificates. Not recommended for production.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --url https://api.example.com/schema.json --http-ignore-tls # (1)!\n</code></pre> <ol> <li> <code>--http-ignore-tls</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Pet\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"tag\": {\n      \"type\": \"string\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  https://api.example.com/schema.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    id: Optional[int] = None\n    name: Optional[str] = None\n    tag: Optional[str] = None\n</code></pre>","path":["CLI Reference","‚öôÔ∏è General Options"],"tags":[]},{"location":"cli-reference/general-options/#http-query-parameters","level":2,"title":"<code>--http-query-parameters</code>","text":"<p>Add query parameters to HTTP requests for remote schemas.</p> <p>The <code>--http-query-parameters</code> flag adds query parameters to HTTP requests when fetching schemas from URLs. Useful for APIs that require version or format parameters. Format: <code>key=value</code>. Multiple parameters can be specified: <code>--http-query-parameters version=v2 format=json</code>.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --url https://api.example.com/schema.json --http-query-parameters version=v2 format=json # (1)!\n</code></pre> <ol> <li> <code>--http-query-parameters</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Pet\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"tag\": {\n      \"type\": \"string\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  https://api.example.com/schema.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    id: Optional[int] = None\n    name: Optional[str] = None\n    tag: Optional[str] = None\n</code></pre>","path":["CLI Reference","‚öôÔ∏è General Options"],"tags":[]},{"location":"cli-reference/general-options/#ignore-pyproject","level":2,"title":"<code>--ignore-pyproject</code>","text":"<p>Ignore pyproject.toml configuration file.</p> <p>The <code>--ignore-pyproject</code> flag tells datamodel-codegen to ignore any [tool.datamodel-codegen] configuration in pyproject.toml. This is useful when you want to override project defaults with CLI arguments, or when testing without project configuration.</p> <p>See also: pyproject.toml Configuration</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --ignore-pyproject # (1)!\n</code></pre> <ol> <li> <code>--ignore-pyproject</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"firstName\": {\"type\": \"string\"},\n    \"lastName\": {\"type\": \"string\"}\n  }\n}\n</code></pre> Output With OptionWithout Option <pre><code># generated by datamodel-codegen:\n#   filename:  schema.json\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    firstName: Optional[str] = None\n    lastName: Optional[str] = None\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  schema.json\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    first_name: Optional[str] = Field(None, alias='firstName')\n    last_name: Optional[str] = Field(None, alias='lastName')\n</code></pre>","path":["CLI Reference","‚öôÔ∏è General Options"],"tags":[]},{"location":"cli-reference/general-options/#shared-module-name","level":2,"title":"<code>--shared-module-name</code>","text":"<p>Customize the name of the shared module for deduplicated models.</p> <p>The <code>--shared-module-name</code> flag sets the name of the shared module created when using <code>--reuse-model</code> with <code>--reuse-scope=tree</code>. This module contains deduplicated models that are referenced from multiple files. Default is <code>shared</code>. Use this if your schema already has a file named <code>shared</code>.</p> <p>Note: This option only affects modular output with tree-level model reuse.</p> <p>See also: Model Reuse and Deduplication</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --shared-module-name my_shared # (1)!\n</code></pre> <ol> <li> <code>--shared-module-name</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Pet\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"tag\": {\n      \"type\": \"string\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  pet_simple.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    id: Optional[int] = None\n    name: Optional[str] = None\n    tag: Optional[str] = None\n</code></pre>","path":["CLI Reference","‚öôÔ∏è General Options"],"tags":[]},{"location":"cli-reference/general-options/#watch","level":2,"title":"<code>--watch</code>","text":"<p>Watch mode cannot be used with --check mode.</p> <p>The <code>--watch</code> flag enables file watching for automatic regeneration. It cannot be combined with <code>--check</code> since check mode requires a single comparison, not continuous watching.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --watch --check # (1)!\n</code></pre> <ol> <li> <code>--watch</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Person\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"firstName\": {\n      \"type\": \"string\",\n      \"description\": \"The person's first name.\"\n    },\n    \"lastName\": {\n      \"type\": [\"string\", \"null\"],\n      \"description\": \"The person's last name.\"\n    },\n    \"age\": {\n      \"description\": \"Age in years which must be equal to or greater than zero.\",\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"friends\": {\n      \"type\": \"array\"\n    },\n    \"comment\": {\n      \"type\": \"null\"\n    }\n  }\n}\n</code></pre> Output <p>Error: File not found: /home/runner/work/datamodel-code-generator/datamodel-code-generator/tests/data/expected/Error: --watch and --check cannot be used together</p>","path":["CLI Reference","‚öôÔ∏è General Options"],"tags":[]},{"location":"cli-reference/general-options/#watch-delay","level":2,"title":"<code>--watch-delay</code>","text":"<p>Watch mode starts file watcher and handles clean exit.</p> <p>The <code>--watch</code> flag starts a file watcher that monitors the input file or directory for changes. The <code>--watch-delay</code> option sets the debounce delay in seconds (default: 0.5) to prevent multiple regenerations for rapid file changes. Press Ctrl+C to stop watching.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --watch --watch-delay 1.5 # (1)!\n</code></pre> <ol> <li> <code>--watch-delay</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Person\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"firstName\": {\n      \"type\": \"string\",\n      \"description\": \"The person's first name.\"\n    },\n    \"lastName\": {\n      \"type\": [\"string\", \"null\"],\n      \"description\": \"The person's last name.\"\n    },\n    \"age\": {\n      \"description\": \"Age in years which must be equal to or greater than zero.\",\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"friends\": {\n      \"type\": \"array\"\n    },\n    \"comment\": {\n      \"type\": \"null\"\n    }\n  }\n}\n</code></pre> Output <p>Error: File not found: /home/runner/work/datamodel-code-generator/datamodel-code-generator/tests/data/expected/Watching</p>","path":["CLI Reference","‚öôÔ∏è General Options"],"tags":[]},{"location":"cli-reference/model-customization/","level":1,"title":"üèóÔ∏è Model Customization","text":"","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#options","level":2,"title":"üìã Options","text":"Option Description <code>--allow-extra-fields</code> Allow extra fields in generated Pydantic models (extra='allo... <code>--allow-population-by-field-name</code> Allow Pydantic model population by field name (not just alia... <code>--base-class</code> Specify a custom base class for generated models. <code>--class-name</code> Override the auto-generated class name with a custom name. <code>--collapse-root-models</code> Inline root model definitions instead of creating separate w... <code>--dataclass-arguments</code> Customize dataclass decorator arguments via JSON dictionary.... <code>--enable-faux-immutability</code> Enable faux immutability in Pydantic v1 models (allow_mutati... <code>--force-optional</code> Force all fields to be Optional regardless of required statu... <code>--frozen-dataclasses</code> Generate frozen dataclasses with optional keyword-only field... <code>--keep-model-order</code> Keep model definition order as specified in schema. <code>--keyword-only</code> Generate dataclasses with keyword-only fields (Python 3.10+)... <code>--output-model-type</code> Select the output model type (Pydantic v1/v2, dataclasses, T... <code>--parent-scoped-naming</code> Namespace models by their parent scope to avoid naming confl... <code>--reuse-model</code> Reuse identical model definitions instead of generating dupl... <code>--reuse-scope</code> Scope for model reuse detection (root or tree). <code>--skip-root-model</code> Skip generation of root model when schema contains nested de... <code>--strict-nullable</code> Strictly handle nullable types in OpenAPI schemas. <code>--strip-default-none</code> Remove fields with None as default value from generated mode... <code>--target-python-version</code> Target Python version for generated code syntax and imports.... <code>--union-mode</code> Union mode for combining anyOf/oneOf schemas (smart or left_... <code>--use-default</code> Use default values from schema in generated models. <code>--use-default-kwarg</code> Use default= keyword argument instead of positional argument... <code>--use-frozen-field</code> Generate frozen (immutable) field definitions for readOnly p... <code>--use-one-literal-as-default</code> Use single literal value as default when enum has only one o... <code>--use-serialize-as-any</code> Wrap fields with subtypes in Pydantic's SerializeAsAny. <code>--use-subclass-enum</code> Generate typed Enum subclasses for enums with specific field...","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#allow-extra-fields","level":2,"title":"<code>--allow-extra-fields</code>","text":"<p>Allow extra fields in generated Pydantic models (extra='allow').</p> <p>The <code>--allow-extra-fields</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --allow-extra-fields # (1)!\n</code></pre> <ol> <li> <code>--allow-extra-fields</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: error result\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output Pydantic v1Pydantic v2 <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Extra, Field\n\n\nclass Pet(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    __root__: List[Pet]\n\n\nclass User(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    __root__: str\n\n\nclass Rules(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    class Config:\n        extra = Extra.allow\n\n    event: Optional[Event] = None\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, ConfigDict, Field, RootModel\n\n\nclass Pet(BaseModel):\n    model_config = ConfigDict(\n        extra='allow',\n    )\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(RootModel[List[Pet]]):\n    root: List[Pet]\n\n\nclass User(BaseModel):\n    model_config = ConfigDict(\n        extra='allow',\n    )\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(RootModel[List[User]]):\n    root: List[User]\n\n\nclass Id(RootModel[str]):\n    root: str\n\n\nclass Rules(RootModel[List[str]]):\n    root: List[str]\n\n\nclass Error(BaseModel):\n    model_config = ConfigDict(\n        extra='allow',\n    )\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    model_config = ConfigDict(\n        extra='allow',\n    )\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(RootModel[List[Api]]):\n    root: List[Api]\n\n\nclass Event(BaseModel):\n    model_config = ConfigDict(\n        extra='allow',\n    )\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    model_config = ConfigDict(\n        extra='allow',\n    )\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#allow-population-by-field-name","level":2,"title":"<code>--allow-population-by-field-name</code>","text":"<p>Allow Pydantic model population by field name (not just alias).</p> <p>The <code>--allow-population-by-field-name</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --allow-population-by-field-name # (1)!\n</code></pre> <ol> <li> <code>--allow-population-by-field-name</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: error result\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output Pydantic v1Pydantic v2 <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    class Config:\n        allow_population_by_field_name = True\n\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    class Config:\n        allow_population_by_field_name = True\n\n    __root__: List[Pet]\n\n\nclass User(BaseModel):\n    class Config:\n        allow_population_by_field_name = True\n\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(BaseModel):\n    class Config:\n        allow_population_by_field_name = True\n\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    class Config:\n        allow_population_by_field_name = True\n\n    __root__: str\n\n\nclass Rules(BaseModel):\n    class Config:\n        allow_population_by_field_name = True\n\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    class Config:\n        allow_population_by_field_name = True\n\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    class Config:\n        allow_population_by_field_name = True\n\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    class Config:\n        allow_population_by_field_name = True\n\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    class Config:\n        allow_population_by_field_name = True\n\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    class Config:\n        allow_population_by_field_name = True\n\n    event: Optional[Event] = None\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, ConfigDict, Field, RootModel\n\n\nclass Pet(BaseModel):\n    model_config = ConfigDict(\n        populate_by_name=True,\n    )\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(RootModel[List[Pet]]):\n    model_config = ConfigDict(\n        populate_by_name=True,\n    )\n    root: List[Pet]\n\n\nclass User(BaseModel):\n    model_config = ConfigDict(\n        populate_by_name=True,\n    )\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(RootModel[List[User]]):\n    model_config = ConfigDict(\n        populate_by_name=True,\n    )\n    root: List[User]\n\n\nclass Id(RootModel[str]):\n    model_config = ConfigDict(\n        populate_by_name=True,\n    )\n    root: str\n\n\nclass Rules(RootModel[List[str]]):\n    model_config = ConfigDict(\n        populate_by_name=True,\n    )\n    root: List[str]\n\n\nclass Error(BaseModel):\n    model_config = ConfigDict(\n        populate_by_name=True,\n    )\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    model_config = ConfigDict(\n        populate_by_name=True,\n    )\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(RootModel[List[Api]]):\n    model_config = ConfigDict(\n        populate_by_name=True,\n    )\n    root: List[Api]\n\n\nclass Event(BaseModel):\n    model_config = ConfigDict(\n        populate_by_name=True,\n    )\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    model_config = ConfigDict(\n        populate_by_name=True,\n    )\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#base-class","level":2,"title":"<code>--base-class</code>","text":"<p>Specify a custom base class for generated models.</p> <p>The <code>--base-class</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --base-class custom_module.Base # (1)!\n</code></pre> <ol> <li> <code>--base-class</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: error result\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, Field\n\nfrom custom_module import Base\n\n\nclass Pet(Base):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(Base):\n    __root__: List[Pet]\n\n\nclass User(Base):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(Base):\n    __root__: List[User]\n\n\nclass Id(Base):\n    __root__: str\n\n\nclass Rules(Base):\n    __root__: List[str]\n\n\nclass Error(Base):\n    code: int\n    message: str\n\n\nclass Api(Base):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(Base):\n    __root__: List[Api]\n\n\nclass Event(Base):\n    name: Optional[str] = None\n\n\nclass Result(Base):\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#class-name","level":2,"title":"<code>--class-name</code>","text":"<p>Override the auto-generated class name with a custom name.</p> <p>The --class-name option allows you to specify a custom class name for the generated model. This is useful when the schema title is invalid as a Python class name (e.g., starts with a number) or when you want to use a different naming convention than what's in the schema.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --class-name ValidModelName # (1)!\n</code></pre> <ol> <li> <code>--class-name</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"1 xyz\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"firstName\": {\n      \"type\": \"string\",\n      \"description\": \"The person's first name.\"\n    },\n    \"lastName\": {\n      \"type\": \"string\",\n      \"description\": \"The person's last name.\"\n    },\n    \"age\": {\n      \"description\": \"Age in years which must be equal to or greater than zero.\",\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"friends\": {\n      \"type\": \"array\"\n    },\n    \"comment\": {\n      \"type\": \"null\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  invalid_model_name.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Any, List, Optional\n\nfrom pydantic import BaseModel, Field, conint\n\n\nclass ValidModelName(BaseModel):\n    firstName: Optional[str] = Field(None, description=\"The person's first name.\")\n    lastName: Optional[str] = Field(None, description=\"The person's last name.\")\n    age: Optional[conint(ge=0)] = Field(\n        None, description='Age in years which must be equal to or greater than zero.'\n    )\n    friends: Optional[List[Any]] = None\n    comment: None = None\n</code></pre>","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#collapse-root-models","level":2,"title":"<code>--collapse-root-models</code>","text":"<p>Inline root model definitions instead of creating separate wrapper classes.</p> <p>The <code>--collapse-root-models</code> option generates simpler output by inlining root models directly instead of creating separate wrapper types. This shows how different output model types (Pydantic v1/v2, dataclass, TypedDict, msgspec) handle const fields.</p> <p>See also: Model Reuse and Deduplication</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --collapse-root-models # (1)!\n</code></pre> <ol> <li> <code>--collapse-root-models</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: '3.0.2'\ncomponents:\n  schemas:\n    ApiVersion:\n      description: The version of this API\n      type: string\n      const: v1\n    Api:\n      type: object\n      required:\n        - version\n      properties:\n        version:\n          $ref: \"#/components/schemas/ApiVersion\"\n</code></pre> Output Pydantic v1Pydantic v2dataclassTypedDictmsgspecWithout Option (Baseline) <pre><code># generated by datamodel-codegen:\n#   filename:  const.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel, Field\n\n\nclass Api(BaseModel):\n    version: str = Field('v1', const=True, description='The version of this API')\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  const.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import BaseModel, Field\n\n\nclass Api(BaseModel):\n    version: Literal['v1'] = Field(..., description='The version of this API')\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  const.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import Literal\n\n\n@dataclass\nclass Api:\n    version: Literal['v1']\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  const.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Literal, TypedDict\n\n\nclass Api(TypedDict):\n    version: Literal['v1']\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  const.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Annotated, Literal\n\nfrom msgspec import Meta, Struct\n\n\nclass Api(Struct):\n    version: Annotated[Literal['v1'], Meta(description='The version of this API')]\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  const.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel, Field\n\n\nclass ApiVersion(BaseModel):\n    __root__: str = Field('v1', const=True, description='The version of this API')\n\n\nclass Api(BaseModel):\n    version: ApiVersion\n</code></pre>","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#dataclass-arguments","level":2,"title":"<code>--dataclass-arguments</code>","text":"<p>Customize dataclass decorator arguments via JSON dictionary.</p> <p>The <code>--dataclass-arguments</code> flag accepts custom dataclass arguments as a JSON dictionary (e.g., '{\"frozen\": true, \"kw_only\": true, \"slots\": true, \"order\": true}'). This overrides individual flags like --frozen-dataclasses and provides fine-grained control over dataclass generation.</p> <p>Related: <code>--frozen-dataclasses</code>, <code>--keyword-only</code></p> <p>See also: Output Model Types</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --output-model-type dataclasses.dataclass --dataclass-arguments \"{\"slots\": true, \"order\": true}\" # (1)!\n</code></pre> <ol> <li> <code>--dataclass-arguments</code> - the option documented here</li> </ol> Input Schema <pre><code>type Person {\n    id: ID!\n    name: String!\n    height: Int\n    mass: Int\n    hair_color: String\n    skin_color: String\n    eye_color: String\n    birth_year: String\n    gender: String\n\n    # Relationships\n    homeworld_id: ID\n    homeworld: Planet\n    species: [Species!]!\n    species_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n    starships: [Starship!]!\n    starships_ids: [ID!]!\n    vehicles: [Vehicle!]!\n    vehicles_ids: [ID!]!\n}\n\ntype Planet {\n    id: ID!\n    name: String!\n    rotation_period: String\n    orbital_period: String\n    diameter: String\n    climate: String\n    gravity: String\n    terrain: String\n    surface_water: String\n    population: String\n\n    # Relationships\n    residents: [Person!]!\n    residents_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n}\n\ntype Species {\n    id: ID!\n    name: String!\n    classification: String\n    designation: String\n    average_height: String\n    skin_colors: String\n    hair_colors: String\n    eye_colors: String\n    average_lifespan: String\n    language: String\n\n    # Relationships\n    people: [Person!]!\n    people_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n}\n\ntype Vehicle {\n    id: ID!\n    name: String!\n    model: String\n    manufacturer: String\n    cost_in_credits: String\n    length: String\n    max_atmosphering_speed: String\n    crew: String\n    passengers: String\n    cargo_capacity: String\n    consumables: String\n    vehicle_class: String\n\n    # Relationships\n    pilots: [Person!]!\n    pilots_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n}\n\ntype Starship {\n    id: ID!\n    name: String!\n    model: String\n    manufacturer: String\n    cost_in_credits: String\n    length: String\n    max_atmosphering_speed: String\n    crew: String\n    passengers: String\n    cargo_capacity: String\n    consumables: String\n    hyperdrive_rating: String\n    MGLT: String\n    starship_class: String\n\n    # Relationships\n    pilots: [Person!]!\n    pilots_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n}\n\ntype Film {\n  id: ID!\n  title: String!\n  episode_id: Int!\n  opening_crawl: String!\n  director: String!\n  producer: String\n  release_date: String!\n\n  # Relationships\n  characters: [Person!]!\n  characters_ids: [ID!]!\n  planets: [Planet!]!\n  planets_ids: [ID!]!\n  starships: [Starship!]!\n  starships_ids: [ID!]!\n  vehicles: [Vehicle!]!\n  vehicles_ids: [ID!]!\n  species: [Species!]!\n  species_ids: [ID!]!\n}\n\ntype Query {\n  planet(id: ID!): Planet\n  listPlanets(page: Int): [Planet!]!\n  person(id: ID!): Person\n  listPeople(page: Int): [Person!]!\n  species(id: ID!): Species\n  listSpecies(page: Int): [Species!]!\n  film(id: ID!): Film\n  listFilms(page: Int): [Film!]!\n  starship(id: ID!): Starship\n  listStarships(page: Int): [Starship!]!\n  vehicle(id: ID!): Vehicle\n  listVehicles(page: Int): [Vehicle!]!\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  simple-star-wars.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import List, Literal, Optional\n\nfrom typing_extensions import TypeAlias\n\nBoolean: TypeAlias = bool\n\"\"\"\nThe `Boolean` scalar type represents `true` or `false`.\n\"\"\"\n\n\nID: TypeAlias = str\n\"\"\"\nThe `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `\"4\"`) or integer (such as `4`) input value will be accepted as an ID.\n\"\"\"\n\n\nInt: TypeAlias = int\n\"\"\"\nThe `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\n\"\"\"\n\n\nString: TypeAlias = str\n\"\"\"\nThe `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\n\"\"\"\n\n\n@dataclass(order=True, slots=True)\nclass Film:\n    characters: List[Person]\n    characters_ids: List[ID]\n    director: String\n    episode_id: Int\n    id: ID\n    opening_crawl: String\n    planets: List[Planet]\n    planets_ids: List[ID]\n    release_date: String\n    species: List[Species]\n    species_ids: List[ID]\n    starships: List[Starship]\n    starships_ids: List[ID]\n    title: String\n    vehicles: List[Vehicle]\n    vehicles_ids: List[ID]\n    producer: Optional[String] = None\n    typename__: Optional[Literal['Film']] = 'Film'\n\n\n@dataclass(order=True, slots=True)\nclass Person:\n    films: List[Film]\n    films_ids: List[ID]\n    id: ID\n    name: String\n    species: List[Species]\n    species_ids: List[ID]\n    starships: List[Starship]\n    starships_ids: List[ID]\n    vehicles: List[Vehicle]\n    vehicles_ids: List[ID]\n    birth_year: Optional[String] = None\n    eye_color: Optional[String] = None\n    gender: Optional[String] = None\n    hair_color: Optional[String] = None\n    height: Optional[Int] = None\n    homeworld: Optional[Planet] = None\n    homeworld_id: Optional[ID] = None\n    mass: Optional[Int] = None\n    skin_color: Optional[String] = None\n    typename__: Optional[Literal['Person']] = 'Person'\n\n\n@dataclass(order=True, slots=True)\nclass Planet:\n    films: List[Film]\n    films_ids: List[ID]\n    id: ID\n    name: String\n    residents: List[Person]\n    residents_ids: List[ID]\n    climate: Optional[String] = None\n    diameter: Optional[String] = None\n    gravity: Optional[String] = None\n    orbital_period: Optional[String] = None\n    population: Optional[String] = None\n    rotation_period: Optional[String] = None\n    surface_water: Optional[String] = None\n    terrain: Optional[String] = None\n    typename__: Optional[Literal['Planet']] = 'Planet'\n\n\n@dataclass(order=True, slots=True)\nclass Species:\n    films: List[Film]\n    films_ids: List[ID]\n    id: ID\n    name: String\n    people: List[Person]\n    people_ids: List[ID]\n    average_height: Optional[String] = None\n    average_lifespan: Optional[String] = None\n    classification: Optional[String] = None\n    designation: Optional[String] = None\n    eye_colors: Optional[String] = None\n    hair_colors: Optional[String] = None\n    language: Optional[String] = None\n    skin_colors: Optional[String] = None\n    typename__: Optional[Literal['Species']] = 'Species'\n\n\n@dataclass(order=True, slots=True)\nclass Starship:\n    films: List[Film]\n    films_ids: List[ID]\n    id: ID\n    name: String\n    pilots: List[Person]\n    pilots_ids: List[ID]\n    MGLT: Optional[String] = None\n    cargo_capacity: Optional[String] = None\n    consumables: Optional[String] = None\n    cost_in_credits: Optional[String] = None\n    crew: Optional[String] = None\n    hyperdrive_rating: Optional[String] = None\n    length: Optional[String] = None\n    manufacturer: Optional[String] = None\n    max_atmosphering_speed: Optional[String] = None\n    model: Optional[String] = None\n    passengers: Optional[String] = None\n    starship_class: Optional[String] = None\n    typename__: Optional[Literal['Starship']] = 'Starship'\n\n\n@dataclass(order=True, slots=True)\nclass Vehicle:\n    films: List[Film]\n    films_ids: List[ID]\n    id: ID\n    name: String\n    pilots: List[Person]\n    pilots_ids: List[ID]\n    cargo_capacity: Optional[String] = None\n    consumables: Optional[String] = None\n    cost_in_credits: Optional[String] = None\n    crew: Optional[String] = None\n    length: Optional[String] = None\n    manufacturer: Optional[String] = None\n    max_atmosphering_speed: Optional[String] = None\n    model: Optional[String] = None\n    passengers: Optional[String] = None\n    vehicle_class: Optional[String] = None\n    typename__: Optional[Literal['Vehicle']] = 'Vehicle'\n</code></pre>","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#enable-faux-immutability","level":2,"title":"<code>--enable-faux-immutability</code>","text":"<p>Enable faux immutability in Pydantic v1 models (allow_mutation=False).</p> <p>The <code>--enable-faux-immutability</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --enable-faux-immutability # (1)!\n</code></pre> <ol> <li> <code>--enable-faux-immutability</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: error result\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output Pydantic v1Pydantic v2 <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    class Config:\n        allow_mutation = False\n\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    class Config:\n        allow_mutation = False\n\n    __root__: List[Pet]\n\n\nclass User(BaseModel):\n    class Config:\n        allow_mutation = False\n\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(BaseModel):\n    class Config:\n        allow_mutation = False\n\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    class Config:\n        allow_mutation = False\n\n    __root__: str\n\n\nclass Rules(BaseModel):\n    class Config:\n        allow_mutation = False\n\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    class Config:\n        allow_mutation = False\n\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    class Config:\n        allow_mutation = False\n\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    class Config:\n        allow_mutation = False\n\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    class Config:\n        allow_mutation = False\n\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    class Config:\n        allow_mutation = False\n\n    event: Optional[Event] = None\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, ConfigDict, Field, RootModel\n\n\nclass Pet(BaseModel):\n    model_config = ConfigDict(\n        frozen=True,\n    )\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(RootModel[List[Pet]]):\n    model_config = ConfigDict(\n        frozen=True,\n    )\n    root: List[Pet]\n\n\nclass User(BaseModel):\n    model_config = ConfigDict(\n        frozen=True,\n    )\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(RootModel[List[User]]):\n    model_config = ConfigDict(\n        frozen=True,\n    )\n    root: List[User]\n\n\nclass Id(RootModel[str]):\n    model_config = ConfigDict(\n        frozen=True,\n    )\n    root: str\n\n\nclass Rules(RootModel[List[str]]):\n    model_config = ConfigDict(\n        frozen=True,\n    )\n    root: List[str]\n\n\nclass Error(BaseModel):\n    model_config = ConfigDict(\n        frozen=True,\n    )\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    model_config = ConfigDict(\n        frozen=True,\n    )\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(RootModel[List[Api]]):\n    model_config = ConfigDict(\n        frozen=True,\n    )\n    root: List[Api]\n\n\nclass Event(BaseModel):\n    model_config = ConfigDict(\n        frozen=True,\n    )\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    model_config = ConfigDict(\n        frozen=True,\n    )\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#force-optional","level":2,"title":"<code>--force-optional</code>","text":"<p>Force all fields to be Optional regardless of required status.</p> <p>The <code>--force-optional</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --force-optional # (1)!\n</code></pre> <ol> <li> <code>--force-optional</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: error result\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: Optional[int] = 1\n    name: Optional[str] = None\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: Optional[List[Pet]] = None\n\n\nclass User(BaseModel):\n    id: Optional[int] = None\n    name: Optional[str] = None\n    tag: Optional[str] = None\n\n\nclass Users(BaseModel):\n    __root__: Optional[List[User]] = None\n\n\nclass Id(BaseModel):\n    __root__: Optional[str] = None\n\n\nclass Rules(BaseModel):\n    __root__: Optional[List[str]] = None\n\n\nclass Error(BaseModel):\n    code: Optional[int] = None\n    message: Optional[str] = None\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: Optional[List[Api]] = None\n\n\nclass Event(BaseModel):\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#frozen-dataclasses","level":2,"title":"<code>--frozen-dataclasses</code>","text":"<p>Generate frozen dataclasses with optional keyword-only fields.</p> <p>The <code>--frozen-dataclasses</code> flag generates dataclass instances that are immutable (frozen=True). Combined with <code>--keyword-only</code> (Python 3.10+), all fields become keyword-only arguments.</p> <p>Related: <code>--keyword-only</code>, <code>--output-model-type</code></p> <p>See also: Output Model Types</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --output-model-type dataclasses.dataclass --frozen-dataclasses # (1)!\n</code></pre> <ol> <li> <code>--frozen-dataclasses</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"object\",\n  \"title\": \"User\",\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"age\": {\n      \"type\": \"integer\"\n    },\n    \"email\": {\n      \"type\": \"string\",\n      \"format\": \"email\"\n    }\n  },\n  \"required\": [\"name\", \"age\"]\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  simple_frozen_test.json\n#   timestamp: 1985-10-26T08:21:00+00:00\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import Optional\n\n\n@dataclass(frozen=True)\nclass User:\n    name: str\n    age: int\n    email: Optional[str] = None\n</code></pre>","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#keep-model-order","level":2,"title":"<code>--keep-model-order</code>","text":"<p>Keep model definition order as specified in schema.</p> <p>The <code>--keep-model-order</code> flag preserves the original definition order from the schema instead of reordering models based on dependencies. This is useful when the order of model definitions matters for documentation or readability.</p> <p>Related: <code>--collapse-root-models</code></p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --keep-model-order # (1)!\n</code></pre> <ol> <li> <code>--keep-model-order</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n    \"title\": \"PersonsBestFriend\",\n    \"description\": \"This is the main model.\",\n    \"type\": \"object\",\n    \"properties\": {\n      \"people\": {\n        \"title\": \"People\",\n        \"type\": \"array\",\n        \"items\": {\n          \"$ref\": \"#/definitions/Person\"\n        }\n      },\n      \"dogs\": {\n        \"title\": \"Dogs\",\n        \"type\": \"array\",\n        \"items\": {\n          \"$ref\": \"#/definitions/Dog\"\n        }\n      },\n      \"dog_base\": {\n        \"$ref\": \"#/definitions/DogBase\"\n      },\n      \"dog_relationships\": {\n        \"$ref\": \"#/definitions/DogRelationships\"\n      },\n      \"person_base\": {\n        \"$ref\": \"#/definitions/PersonBase\"\n      },\n      \"person_relationships\": {\n        \"$ref\": \"#/definitions/PersonRelationships\"\n      }\n    },\n    \"definitions\": {\n      \"Person\": {\n        \"title\": \"Person\",\n        \"allOf\": [\n            {\"$ref\": \"#/definitions/PersonBase\"},\n            {\"$ref\": \"#/definitions/PersonRelationships\"}\n        ]\n      },\n      \"Dog\": {\n        \"title\": \"Dog\",\n        \"allOf\": [\n            {\"$ref\": \"#/definitions/DogBase\"},\n            {\"$ref\": \"#/definitions/DogRelationships\"}\n        ]\n      },\n      \"DogBase\": {\n        \"title\": \"DogBase\",\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"title\": \"Name\",\n            \"type\": \"string\"\n          },\n          \"woof\": {\n            \"title\": \"Woof\",\n            \"default\": true,\n            \"type\": \"boolean\"\n          }\n        }\n      },\n      \"DogRelationships\": {\n        \"title\": \"DogRelationships\",\n        \"type\": \"object\",\n        \"properties\": {\n          \"people\": {\n            \"title\": \"People\",\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/definitions/Person\"\n            }\n          }\n        }\n      },\n      \"PersonBase\": {\n        \"title\": \"PersonBase\",\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"title\": \"Name\",\n            \"type\": \"string\"\n          }\n        }\n      },\n      \"PersonRelationships\": {\n        \"title\": \"PersonRelationships\",\n        \"type\": \"object\",\n        \"properties\": {\n          \"people\": {\n            \"title\": \"People\",\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/definitions/Person\"\n            }\n          }\n        }\n      }\n    }\n  }\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  inheritance_forward_ref.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass DogBase(BaseModel):\n    name: Optional[str] = Field(None, title='Name')\n    woof: Optional[bool] = Field(True, title='Woof')\n\n\nclass DogRelationships(BaseModel):\n    people: Optional[List[Person]] = Field(None, title='People')\n\n\nclass Dog(DogBase, DogRelationships):\n    pass\n\n\nclass PersonBase(BaseModel):\n    name: Optional[str] = Field(None, title='Name')\n\n\nclass PersonRelationships(BaseModel):\n    people: Optional[List[Person]] = Field(None, title='People')\n\n\nclass Person(PersonBase, PersonRelationships):\n    pass\n\n\nclass PersonsBestFriend(BaseModel):\n    people: Optional[List[Person]] = Field(None, title='People')\n    dogs: Optional[List[Dog]] = Field(None, title='Dogs')\n    dog_base: Optional[DogBase] = None\n    dog_relationships: Optional[DogRelationships] = None\n    person_base: Optional[PersonBase] = None\n    person_relationships: Optional[PersonRelationships] = None\n\n\nDogRelationships.update_forward_refs()\nDog.update_forward_refs()\nPersonRelationships.update_forward_refs()\nPerson.update_forward_refs()\nPersonsBestFriend.update_forward_refs()\n</code></pre>","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#keyword-only","level":2,"title":"<code>--keyword-only</code>","text":"<p>Generate dataclasses with keyword-only fields (Python 3.10+).</p> <p>The <code>--keyword-only</code> flag generates dataclasses where all fields must be specified as keyword arguments (kw_only=True). This is only available for Python 3.10+. When combined with <code>--frozen</code>, it creates immutable dataclasses with keyword-only arguments, improving code clarity and preventing positional argument errors.</p> <p>Related: <code>--frozen-dataclasses</code>, <code>--target-python-version</code>, <code>--output-model-type</code></p> <p>See also: Output Model Types</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --output-model-type dataclasses.dataclass --frozen-dataclasses --keyword-only --target-python-version 3.10 # (1)!\n</code></pre> <ol> <li> <code>--keyword-only</code> - the option documented here</li> </ol> Input Schema <pre><code>type Person {\n    id: ID!\n    name: String!\n    height: Int\n    mass: Int\n    hair_color: String\n    skin_color: String\n    eye_color: String\n    birth_year: String\n    gender: String\n\n    # Relationships\n    homeworld_id: ID\n    homeworld: Planet\n    species: [Species!]!\n    species_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n    starships: [Starship!]!\n    starships_ids: [ID!]!\n    vehicles: [Vehicle!]!\n    vehicles_ids: [ID!]!\n}\n\ntype Planet {\n    id: ID!\n    name: String!\n    rotation_period: String\n    orbital_period: String\n    diameter: String\n    climate: String\n    gravity: String\n    terrain: String\n    surface_water: String\n    population: String\n\n    # Relationships\n    residents: [Person!]!\n    residents_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n}\n\ntype Species {\n    id: ID!\n    name: String!\n    classification: String\n    designation: String\n    average_height: String\n    skin_colors: String\n    hair_colors: String\n    eye_colors: String\n    average_lifespan: String\n    language: String\n\n    # Relationships\n    people: [Person!]!\n    people_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n}\n\ntype Vehicle {\n    id: ID!\n    name: String!\n    model: String\n    manufacturer: String\n    cost_in_credits: String\n    length: String\n    max_atmosphering_speed: String\n    crew: String\n    passengers: String\n    cargo_capacity: String\n    consumables: String\n    vehicle_class: String\n\n    # Relationships\n    pilots: [Person!]!\n    pilots_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n}\n\ntype Starship {\n    id: ID!\n    name: String!\n    model: String\n    manufacturer: String\n    cost_in_credits: String\n    length: String\n    max_atmosphering_speed: String\n    crew: String\n    passengers: String\n    cargo_capacity: String\n    consumables: String\n    hyperdrive_rating: String\n    MGLT: String\n    starship_class: String\n\n    # Relationships\n    pilots: [Person!]!\n    pilots_ids: [ID!]!\n    films: [Film!]!\n    films_ids: [ID!]!\n}\n\ntype Film {\n  id: ID!\n  title: String!\n  episode_id: Int!\n  opening_crawl: String!\n  director: String!\n  producer: String\n  release_date: String!\n\n  # Relationships\n  characters: [Person!]!\n  characters_ids: [ID!]!\n  planets: [Planet!]!\n  planets_ids: [ID!]!\n  starships: [Starship!]!\n  starships_ids: [ID!]!\n  vehicles: [Vehicle!]!\n  vehicles_ids: [ID!]!\n  species: [Species!]!\n  species_ids: [ID!]!\n}\n\ntype Query {\n  planet(id: ID!): Planet\n  listPlanets(page: Int): [Planet!]!\n  person(id: ID!): Person\n  listPeople(page: Int): [Person!]!\n  species(id: ID!): Species\n  listSpecies(page: Int): [Species!]!\n  film(id: ID!): Film\n  listFilms(page: Int): [Film!]!\n  starship(id: ID!): Starship\n  listStarships(page: Int): [Starship!]!\n  vehicle(id: ID!): Vehicle\n  listVehicles(page: Int): [Vehicle!]!\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  simple-star-wars.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import List, Literal, Optional, TypeAlias\n\nBoolean: TypeAlias = bool\n\"\"\"\nThe `Boolean` scalar type represents `true` or `false`.\n\"\"\"\n\n\nID: TypeAlias = str\n\"\"\"\nThe `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `\"4\"`) or integer (such as `4`) input value will be accepted as an ID.\n\"\"\"\n\n\nInt: TypeAlias = int\n\"\"\"\nThe `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\n\"\"\"\n\n\nString: TypeAlias = str\n\"\"\"\nThe `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\n\"\"\"\n\n\n@dataclass(frozen=True, kw_only=True)\nclass Film:\n    characters: List[Person]\n    characters_ids: List[ID]\n    director: String\n    episode_id: Int\n    id: ID\n    opening_crawl: String\n    planets: List[Planet]\n    planets_ids: List[ID]\n    release_date: String\n    species: List[Species]\n    species_ids: List[ID]\n    starships: List[Starship]\n    starships_ids: List[ID]\n    title: String\n    vehicles: List[Vehicle]\n    vehicles_ids: List[ID]\n    producer: Optional[String] = None\n    typename__: Optional[Literal['Film']] = 'Film'\n\n\n@dataclass(frozen=True, kw_only=True)\nclass Person:\n    films: List[Film]\n    films_ids: List[ID]\n    id: ID\n    name: String\n    species: List[Species]\n    species_ids: List[ID]\n    starships: List[Starship]\n    starships_ids: List[ID]\n    vehicles: List[Vehicle]\n    vehicles_ids: List[ID]\n    birth_year: Optional[String] = None\n    eye_color: Optional[String] = None\n    gender: Optional[String] = None\n    hair_color: Optional[String] = None\n    height: Optional[Int] = None\n    homeworld: Optional[Planet] = None\n    homeworld_id: Optional[ID] = None\n    mass: Optional[Int] = None\n    skin_color: Optional[String] = None\n    typename__: Optional[Literal['Person']] = 'Person'\n\n\n@dataclass(frozen=True, kw_only=True)\nclass Planet:\n    films: List[Film]\n    films_ids: List[ID]\n    id: ID\n    name: String\n    residents: List[Person]\n    residents_ids: List[ID]\n    climate: Optional[String] = None\n    diameter: Optional[String] = None\n    gravity: Optional[String] = None\n    orbital_period: Optional[String] = None\n    population: Optional[String] = None\n    rotation_period: Optional[String] = None\n    surface_water: Optional[String] = None\n    terrain: Optional[String] = None\n    typename__: Optional[Literal['Planet']] = 'Planet'\n\n\n@dataclass(frozen=True, kw_only=True)\nclass Species:\n    films: List[Film]\n    films_ids: List[ID]\n    id: ID\n    name: String\n    people: List[Person]\n    people_ids: List[ID]\n    average_height: Optional[String] = None\n    average_lifespan: Optional[String] = None\n    classification: Optional[String] = None\n    designation: Optional[String] = None\n    eye_colors: Optional[String] = None\n    hair_colors: Optional[String] = None\n    language: Optional[String] = None\n    skin_colors: Optional[String] = None\n    typename__: Optional[Literal['Species']] = 'Species'\n\n\n@dataclass(frozen=True, kw_only=True)\nclass Starship:\n    films: List[Film]\n    films_ids: List[ID]\n    id: ID\n    name: String\n    pilots: List[Person]\n    pilots_ids: List[ID]\n    MGLT: Optional[String] = None\n    cargo_capacity: Optional[String] = None\n    consumables: Optional[String] = None\n    cost_in_credits: Optional[String] = None\n    crew: Optional[String] = None\n    hyperdrive_rating: Optional[String] = None\n    length: Optional[String] = None\n    manufacturer: Optional[String] = None\n    max_atmosphering_speed: Optional[String] = None\n    model: Optional[String] = None\n    passengers: Optional[String] = None\n    starship_class: Optional[String] = None\n    typename__: Optional[Literal['Starship']] = 'Starship'\n\n\n@dataclass(frozen=True, kw_only=True)\nclass Vehicle:\n    films: List[Film]\n    films_ids: List[ID]\n    id: ID\n    name: String\n    pilots: List[Person]\n    pilots_ids: List[ID]\n    cargo_capacity: Optional[String] = None\n    consumables: Optional[String] = None\n    cost_in_credits: Optional[String] = None\n    crew: Optional[String] = None\n    length: Optional[String] = None\n    manufacturer: Optional[String] = None\n    max_atmosphering_speed: Optional[String] = None\n    model: Optional[String] = None\n    passengers: Optional[String] = None\n    vehicle_class: Optional[String] = None\n    typename__: Optional[Literal['Vehicle']] = 'Vehicle'\n</code></pre>","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#output-model-type","level":2,"title":"<code>--output-model-type</code>","text":"<p>Select the output model type (Pydantic v1/v2, dataclasses, TypedDict, msgspec).</p> <p>The <code>--output-model-type</code> flag specifies which Python data model framework to use for the generated code. Supported values include <code>pydantic.BaseModel</code>, <code>pydantic_v2.BaseModel</code>, <code>dataclasses.dataclass</code>, <code>typing.TypedDict</code>, and <code>msgspec.Struct</code>.</p> <p>See also: Output Model Types</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --output-model-type pydantic.BaseModel # (1)!\n</code></pre> <ol> <li> <code>--output-model-type</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n    \"$schema\": \"http://json-schema.org/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"my_obj\": {\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"items\": {\n                        \"type\": [\n                            \"array\",\n                            \"null\"\n                        ]\n                    }\n                },\n                \"required\": [\n                    \"items\"\n                ]\n            }\n        }\n    },\n    \"required\": [\n        \"my_obj\"\n    ]\n}\n</code></pre> Output Pydantic v1Pydantic v2 <pre><code># generated by datamodel-codegen:\n#   filename:  null_and_array.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Any, List, Optional\n\nfrom pydantic import BaseModel\n\n\nclass MyObjItem(BaseModel):\n    items: Optional[List[Any]]\n\n\nclass Model(BaseModel):\n    my_obj: List[MyObjItem]\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  null_and_array.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Any, List, Optional\n\nfrom pydantic import BaseModel\n\n\nclass MyObjItem(BaseModel):\n    items: Optional[List[Any]] = None\n\n\nclass Model(BaseModel):\n    my_obj: List[MyObjItem]\n</code></pre>","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#parent-scoped-naming","level":2,"title":"<code>--parent-scoped-naming</code>","text":"<p>Namespace models by their parent scope to avoid naming conflicts.</p> <p>The <code>--parent-scoped-naming</code> flag prefixes model names with their parent scope (operation/path/parameter) to prevent name collisions when the same model name appears in different contexts within an OpenAPI specification.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --parent-scoped-naming --use-operation-id-as-name --openapi-scopes paths schemas parameters # (1)!\n</code></pre> <ol> <li> <code>--parent-scoped-naming</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: Get pet\n      operationId: getPets\n      responses:\n        '200':\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pet\"\n  /cars:\n    get:\n      summary: Get car\n      operationId: getCar\n      responses:\n        '200':\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Cars\"\n\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n        - type\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        tag:\n          type: string\n        type:\n          type: string\n          enum: [ 'pet' ]\n        details:\n          type: object\n          properties:\n            race: { type: string }\n    Car:\n      required:\n        - id\n        - name\n        - type\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        tag:\n          type: string\n        type:\n          type: string\n          enum: [ 'car' ]\n        details:\n          type: object\n          properties:\n            brand: { type: string }\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  duplicate_models2.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Any, Optional\n\nfrom pydantic import BaseModel, RootModel\n\n\nclass PetType(Enum):\n    pet = 'pet'\n\n\nclass PetDetails(BaseModel):\n    race: Optional[str] = None\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n    type: PetType\n    details: Optional[PetDetails] = None\n\n\nclass CarType(Enum):\n    car = 'car'\n\n\nclass CarDetails(BaseModel):\n    brand: Optional[str] = None\n\n\nclass Car(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n    type: CarType\n    details: Optional[CarDetails] = None\n\n\nclass Cars(RootModel[Any]):\n    root: Any\n</code></pre>","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#reuse-model","level":2,"title":"<code>--reuse-model</code>","text":"<p>Reuse identical model definitions instead of generating duplicates.</p> <p>The <code>--reuse-model</code> flag detects identical enum or model definitions across the schema and generates a single shared definition, reducing code duplication in the output.</p> <p>Related: <code>--collapse-root-models</code></p> <p>See also: Model Reuse and Deduplication</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --reuse-model # (1)!\n</code></pre> <ol> <li> <code>--reuse-model</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema\",\n  \"title\": \"User\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"animal\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"dog\",\n        \"cat\",\n        \"snake\"\n      ],\n      \"default\": \"dog\"\n    },\n    \"pet\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"dog\",\n        \"cat\",\n        \"snake\"\n      ],\n      \"default\": \"cat\"\n    },\n    \"redistribute\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\",\n        \"enum\": [\n          \"static\",\n          \"connected\"\n        ]\n      }\n    }\n  },\n  \"definitions\": {\n    \"redistribute\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\",\n        \"enum\": [\n          \"static\",\n          \"connected\"\n        ]\n      },\n      \"description\": \"Redistribute type for routes.\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  duplicate_enum.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Animal(Enum):\n    dog = 'dog'\n    cat = 'cat'\n    snake = 'snake'\n\n\nclass RedistributeEnum(Enum):\n    static = 'static'\n    connected = 'connected'\n\n\nclass User(BaseModel):\n    name: Optional[str] = None\n    animal: Optional[Animal] = 'dog'\n    pet: Optional[Animal] = 'cat'\n    redistribute: Optional[List[RedistributeEnum]] = None\n\n\nclass Redistribute(BaseModel):\n    __root__: List[RedistributeEnum] = Field(\n        ..., description='Redistribute type for routes.'\n    )\n</code></pre>","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#reuse-scope","level":2,"title":"<code>--reuse-scope</code>","text":"<p>Scope for model reuse detection (root or tree).</p> <p>The <code>--reuse-scope</code> flag configures the code generation behavior.</p> <p>See also: Model Reuse and Deduplication</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --reuse-model --reuse-scope tree # (1)!\n</code></pre> <ol> <li> <code>--reuse-scope</code> - the option documented here</li> </ol> Input Schema <pre><code># schema_a.json\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"data\": { \"$ref\": \"#/$defs/SharedModel\" }\n  },\n  \"$defs\": {\n    \"SharedModel\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"id\": { \"type\": \"integer\" },\n        \"name\": { \"type\": \"string\" }\n      }\n    }\n  }\n}\n\n# schema_b.json\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"info\": { \"$ref\": \"#/$defs/SharedModel\" }\n  },\n  \"$defs\": {\n    \"SharedModel\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"id\": { \"type\": \"integer\" },\n        \"name\": { \"type\": \"string\" }\n      }\n    }\n  }\n}\n</code></pre> Output <pre><code># __init__.py\n# generated by datamodel-codegen:\n#   filename:  reuse_scope_tree\n#   timestamp: 2019-07-26T00:00:00+00:00\n\n# schema_a.py\n# generated by datamodel-codegen:\n#   filename:  reuse_scope_tree\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\nfrom .shared import SharedModel as SharedModel_1\n\n\nclass SharedModel(SharedModel_1):\n    pass\n\n\nclass Model(BaseModel):\n    data: Optional[SharedModel] = None\n\n# schema_b.py\n# generated by datamodel-codegen:\n#   filename:  schema_b.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\nfrom . import shared\n\n\nclass Model(BaseModel):\n    info: Optional[shared.SharedModel] = None\n\n# shared.py\n# generated by datamodel-codegen:\n#   filename:  shared.py\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass SharedModel(BaseModel):\n    id: Optional[int] = None\n    name: Optional[str] = None\n</code></pre>","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#skip-root-model","level":2,"title":"<code>--skip-root-model</code>","text":"<p>Skip generation of root model when schema contains nested definitions.</p> <p>The <code>--skip-root-model</code> flag prevents generating a model for the root schema object when the schema primarily contains reusable definitions. This is useful when the root object is just a container for $defs and not a meaningful model itself.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --output-model-type pydantic_v2.BaseModel --skip-root-model # (1)!\n</code></pre> <ol> <li> <code>--skip-root-model</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"_Placeholder\",\n  \"type\": \"null\",\n  \"$defs\": {\n    \"Person\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\"type\": \"string\"},\n        \"age\": {\"type\": \"integer\"}\n      },\n      \"required\": [\"name\"]\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  skip_root_model_test.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Person(BaseModel):\n    name: str\n    age: Optional[int] = None\n</code></pre>","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#strict-nullable","level":2,"title":"<code>--strict-nullable</code>","text":"<p>Strictly handle nullable types in OpenAPI schemas.</p> <p>The <code>--strict-nullable</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --strict-nullable # (1)!\n</code></pre> <ol> <li> <code>--strict-nullable</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: 3.0.3\ninfo:\n  version: 1.0.0\n  title: testapi\n  license:\n    name: proprietary\nservers: []\npaths: {}\ncomponents:\n  schemas:\n    TopLevel:\n      type: object\n      properties:\n        cursors:\n          type: object\n          properties:\n            prev:\n              type: string\n              nullable: true\n            next:\n              type: string\n              default: last\n            index:\n              type: number\n            tag:\n              type: string\n          required:\n          - prev\n          - index\n      required:\n      - cursors\n    User:\n      type: object\n      properties:\n        info:\n          type: object\n          properties:\n            name:\n              type: string\n          required:\n            - name\n      required:\n        - info\n    apis:\n      type: array\n      nullable: true\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n            nullable: true\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n            nullable: true\n    email:\n      type: array\n      items:\n        type: object\n        properties:\n          author:\n            type: string\n          address:\n            type: string\n            description: email address\n          description:\n            type: string\n            default: empty\n          tag:\n            type: string\n        required:\n          - author\n          - address\n    id:\n      type: integer\n      default: 1\n    description:\n      type: string\n      nullable: true\n      default: example\n    name:\n      type: string\n      nullable: true\n    tag:\n      type: string\n    notes:\n      type: object\n      properties:\n        comments:\n          type: array\n          items:\n              type: string\n          default_factory: list\n          nullable: false\n    options:\n      type: object\n      properties:\n        comments:\n          type: array\n          items:\n              type: string\n              nullable: true\n        oneOfComments:\n           type: array\n           items:\n               oneOf:\n                - type: string\n                - type: number\n               nullable: true\n      required:\n        - comments\n        - oneOfComments\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  nullable.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional, Union\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Cursors(BaseModel):\n    prev: Optional[str] = Field(...)\n    next: str = 'last'\n    index: float\n    tag: Optional[str] = None\n\n\nclass TopLevel(BaseModel):\n    cursors: Cursors\n\n\nclass Info(BaseModel):\n    name: str\n\n\nclass User(BaseModel):\n    info: Info\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: Optional[List[Api]] = Field(...)\n\n\nclass EmailItem(BaseModel):\n    author: str\n    address: str = Field(..., description='email address')\n    description: str = 'empty'\n    tag: Optional[str] = None\n\n\nclass Email(BaseModel):\n    __root__: List[EmailItem]\n\n\nclass Id(BaseModel):\n    __root__: int\n\n\nclass Description(BaseModel):\n    __root__: Optional[str] = 'example'\n\n\nclass Name(BaseModel):\n    __root__: Optional[str] = None\n\n\nclass Tag(BaseModel):\n    __root__: str\n\n\nclass Notes(BaseModel):\n    comments: List[str] = Field(default_factory=list)\n\n\nclass Options(BaseModel):\n    comments: List[Optional[str]]\n    oneOfComments: List[Union[Optional[str], Optional[float]]]\n</code></pre>","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#strip-default-none","level":2,"title":"<code>--strip-default-none</code>","text":"<p>Remove fields with None as default value from generated models.</p> <p>The <code>--strip-default-none</code> option removes fields that have None as their default value from the generated models. This results in cleaner model definitions by excluding optional fields that default to None.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --strip-default-none # (1)!\n</code></pre> <ol> <li> <code>--strip-default-none</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: error result\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str]\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str]\n\n\nclass Users(BaseModel):\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    name: Optional[str]\n\n\nclass Result(BaseModel):\n    event: Optional[Event]\n</code></pre>","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#target-python-version","level":2,"title":"<code>--target-python-version</code>","text":"<p>Target Python version for generated code syntax and imports.</p> <p>The <code>--target-python-version</code> flag controls Python version-specific syntax:</p> <ul> <li>Python 3.9: Uses <code>Optional[X]</code> for optional types, <code>typing.Dict/List</code></li> <li>Python 3.10+: Can use <code>X | None</code> union operator, built-in <code>dict/list</code></li> </ul> <p>This affects import statements and type annotation syntax in generated code.</p> <p>See also: Output Model Types, CI/CD Integration, Python Version Compatibility</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --target-python-version 3.9 --use-standard-collections # (1)!\n</code></pre> <ol> <li> <code>--target-python-version</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Person\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"firstName\": {\n      \"type\": \"string\",\n      \"description\": \"The person's first name.\"\n    },\n    \"lastName\": {\n      \"type\": [\"string\", \"null\"],\n      \"description\": \"The person's last name.\"\n    },\n    \"age\": {\n      \"description\": \"Age in years which must be equal to or greater than zero.\",\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"friends\": {\n      \"type\": \"array\"\n    },\n    \"comment\": {\n      \"type\": \"null\"\n    }\n  }\n}\n</code></pre> Output Python 3.9Python 3.10 <pre><code># generated by datamodel-codegen:\n#   filename:  person.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Any, Optional\n\nfrom pydantic import BaseModel, Field, conint\n\n\nclass Person(BaseModel):\n    firstName: Optional[str] = Field(None, description=\"The person's first name.\")\n    lastName: Optional[str] = Field(None, description=\"The person's last name.\")\n    age: Optional[conint(ge=0)] = Field(\n        None, description='Age in years which must be equal to or greater than zero.'\n    )\n    friends: Optional[list[Any]] = None\n    comment: None = None\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  person.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Any\n\nfrom pydantic import BaseModel, Field, conint\n\n\nclass Person(BaseModel):\n    firstName: str | None = Field(None, description=\"The person's first name.\")\n    lastName: str | None = Field(None, description=\"The person's last name.\")\n    age: conint(ge=0) | None = Field(\n        None, description='Age in years which must be equal to or greater than zero.'\n    )\n    friends: list[Any] | None = None\n    comment: None = None\n</code></pre>","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#union-mode","level":2,"title":"<code>--union-mode</code>","text":"<p>Union mode for combining anyOf/oneOf schemas (smart or left_to_right).</p> <p>The <code>--union-mode</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --union-mode left_to_right --output-model-type pydantic_v2.BaseModel # (1)!\n</code></pre> <ol> <li> <code>--union-mode</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"type\": \"object\",\n    \"title\": \"My schema\",\n    \"additionalProperties\": true,\n    \"properties\": {\n        \"AddressLine1\": { \"type\": \"string\" },\n        \"AddressLine2\": { \"type\": \"string\" },\n        \"City\":         { \"type\": \"string\" }\n    },\n    \"required\": [ \"AddressLine1\" ],\n    \"anyOf\": [\n        {\n            \"type\": \"object\",\n            \"properties\": {\n                \"State\":   { \"type\": \"string\" },\n                \"ZipCode\": { \"type\": \"string\" }\n            },\n            \"required\": [ \"ZipCode\" ]\n        },\n        {\n            \"type\": \"object\",\n            \"properties\": {\n                \"County\":   { \"type\": \"string\" },\n                \"PostCode\": { \"type\": \"string\" }\n            },\n            \"required\": [ \"PostCode\" ]\n        },\n        { \"$ref\": \"#/definitions/US\" }\n    ],\n    \"definitions\": {\n        \"US\":  {\n            \"type\": \"object\",\n            \"properties\": {\n                \"County\":   { \"type\": \"string\" },\n                \"PostCode\": { \"type\": \"string\" }\n            },\n            \"required\": [ \"PostCode\" ]\n        }\n    }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  combine_any_of_object.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional, Union\n\nfrom pydantic import BaseModel, ConfigDict, Field, RootModel\n\n\nclass MySchema1(BaseModel):\n    model_config = ConfigDict(\n        extra='allow',\n    )\n    AddressLine1: str\n    AddressLine2: Optional[str] = None\n    City: Optional[str] = None\n    State: Optional[str] = None\n    ZipCode: str\n\n\nclass MySchema2(BaseModel):\n    model_config = ConfigDict(\n        extra='allow',\n    )\n    AddressLine1: str\n    AddressLine2: Optional[str] = None\n    City: Optional[str] = None\n    County: Optional[str] = None\n    PostCode: str\n\n\nclass US(BaseModel):\n    County: Optional[str] = None\n    PostCode: str\n\n\nclass MySchema3(US):\n    model_config = ConfigDict(\n        extra='allow',\n    )\n    AddressLine1: str\n    AddressLine2: Optional[str] = None\n    City: Optional[str] = None\n\n\nclass MySchema(RootModel[Union[MySchema1, MySchema2, MySchema3]]):\n    root: Union[MySchema1, MySchema2, MySchema3] = Field(\n        ..., title='My schema', union_mode='left_to_right'\n    )\n</code></pre>","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#use-default","level":2,"title":"<code>--use-default</code>","text":"<p>Use default values from schema in generated models.</p> <p>The <code>--use-default</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --output-model-type pydantic_v2.BaseModel --use-default # (1)!\n</code></pre> <ol> <li> <code>--use-default</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"title\": \"Use default with const\",\n    \"properties\": {\n        \"foo\": {\n            \"const\": \"foo\"\n        }\n    }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  use_default_with_const.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import BaseModel\n\n\nclass UseDefaultWithConst(BaseModel):\n    foo: Literal['foo'] = 'foo'\n</code></pre>","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#use-default-kwarg","level":2,"title":"<code>--use-default-kwarg</code>","text":"<p>Use default= keyword argument instead of positional argument for fields with defaults.</p> <p>The <code>--use-default-kwarg</code> flag generates Field() declarations using <code>default=</code> as a keyword argument instead of a positional argument for fields that have default values.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-default-kwarg # (1)!\n</code></pre> <ol> <li> <code>--use-default-kwarg</code> - the option documented here</li> </ol> Input Schema <pre><code>type A {\n    field: String!\n    optionalField: String\n    listField: [String!]!\n    listOptionalField: [String]!\n    optionalListField: [String!]\n    optionalListOptionalField: [String]\n    listListField:[[String!]!]!\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  annotated.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Literal, Optional\n\nfrom pydantic import BaseModel, Field\nfrom typing_extensions import TypeAlias\n\nBoolean: TypeAlias = bool\n\"\"\"\nThe `Boolean` scalar type represents `true` or `false`.\n\"\"\"\n\n\nString: TypeAlias = str\n\"\"\"\nThe `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\n\"\"\"\n\n\nclass A(BaseModel):\n    field: String\n    listField: List[String]\n    listListField: List[List[String]]\n    listOptionalField: List[Optional[String]]\n    optionalField: Optional[String] = None\n    optionalListField: Optional[List[String]] = None\n    optionalListOptionalField: Optional[List[Optional[String]]] = None\n    typename__: Optional[Literal['A']] = Field(default='A', alias='__typename')\n</code></pre>","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#use-frozen-field","level":2,"title":"<code>--use-frozen-field</code>","text":"<p>Generate frozen (immutable) field definitions for readOnly properties.</p> <p>The <code>--use-frozen-field</code> flag generates frozen field definitions: - Pydantic v1: <code>Field(allow_mutation=False)</code> - Pydantic v2: <code>Field(frozen=True)</code> - Dataclasses: silently ignored (no frozen fields generated)</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-frozen-field # (1)!\n</code></pre> <ol> <li> <code>--use-frozen-field</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"User\",\n  \"type\": \"object\",\n  \"required\": [\"id\", \"name\", \"password\"],\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\",\n      \"description\": \"Server-generated ID\",\n      \"readOnly\": true\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"password\": {\n      \"type\": \"string\",\n      \"description\": \"User password\",\n      \"writeOnly\": true\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\",\n      \"readOnly\": true\n    }\n  }\n}\n</code></pre> Output Pydantic v1Pydantic v2dataclass <pre><code># generated by datamodel-codegen:\n#   filename:  use_frozen_field.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    class Config:\n        validate_assignment = True\n\n    id: int = Field(..., allow_mutation=False, description='Server-generated ID')\n    name: str\n    password: str = Field(..., description='User password')\n    created_at: Optional[datetime] = Field(None, allow_mutation=False)\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  use_frozen_field.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import AwareDatetime, BaseModel, Field\n\n\nclass User(BaseModel):\n    id: int = Field(..., description='Server-generated ID', frozen=True)\n    name: str\n    password: str = Field(..., description='User password')\n    created_at: Optional[AwareDatetime] = Field(None, frozen=True)\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  use_frozen_field.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import Optional\n\n\n@dataclass\nclass User:\n    id: int\n    name: str\n    password: str\n    created_at: Optional[str] = None\n</code></pre>","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#use-one-literal-as-default","level":2,"title":"<code>--use-one-literal-as-default</code>","text":"<p>Use single literal value as default when enum has only one option.</p> <p>The <code>--use-one-literal-as-default</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-one-literal-as-default --enum-field-as-literal one # (1)!\n</code></pre> <ol> <li> <code>--use-one-literal-as-default</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n        - number\n        - boolean\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        tag:\n          type: string\n        kind:\n          type: string\n          enum: ['dog', 'cat']\n        type:\n          type: string\n          enum: [ 'animal' ]\n        number:\n          type: integer\n          enum: [ 1 ]\n        boolean:\n          type: boolean\n          enum: [ true ]\n\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    animal:\n      type: object\n      properties:\n        kind:\n          type: string\n          enum: ['snake', 'rabbit']\n    Error:\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    EnumObject:\n      type: object\n      properties:\n        type:\n          enum: ['a', 'b']\n          type: string\n    EnumRoot:\n      enum: ['a', 'b']\n      type: string\n    IntEnum:\n      enum: [1,2]\n      type: number\n    AliasEnum:\n      enum: [1,2,3]\n      type: number\n      x-enum-varnames: ['a', 'b', 'c']\n    MultipleTypeEnum:\n      enum: [ \"red\", \"amber\", \"green\", null, 42 ]\n    singleEnum:\n      enum: [ \"pet\" ]\n      type: string\n    arrayEnum:\n      type: array\n      items: [\n        { enum: [ \"cat\" ] },\n        { enum: [ \"dog\"]}\n      ]\n    nestedNullableEnum:\n      type: object\n      properties:\n        nested_version:\n          type: string\n          nullable: true\n          default: RC1\n          description: nullable enum\n          example: RC2\n          enum:\n            - RC1\n            - RC1N\n            - RC2\n            - RC2N\n            - RC3\n            - RC4\n            - null\n    version:\n      type: string\n      nullable: true\n      default: RC1\n      description: nullable enum\n      example: RC2\n      enum:\n      - RC1\n      - RC1N\n      - RC2\n      - RC2N\n      - RC3\n      - RC4\n      - null\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  enum_models.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import List, Literal, Optional, Union\n\nfrom pydantic import BaseModel, Field\n\n\nclass Kind(Enum):\n    dog = 'dog'\n    cat = 'cat'\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n    kind: Optional[Kind] = None\n    type: Optional[Literal['animal']] = None\n    number: Literal[1] = 1\n    boolean: Literal[True] = True\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass Kind1(Enum):\n    snake = 'snake'\n    rabbit = 'rabbit'\n\n\nclass Animal(BaseModel):\n    kind: Optional[Kind1] = None\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Type(Enum):\n    a = 'a'\n    b = 'b'\n\n\nclass EnumObject(BaseModel):\n    type: Optional[Type] = None\n\n\nclass EnumRoot(Enum):\n    a = 'a'\n    b = 'b'\n\n\nclass IntEnum(Enum):\n    number_1 = 1\n    number_2 = 2\n\n\nclass AliasEnum(Enum):\n    a = 1\n    b = 2\n    c = 3\n\n\nclass MultipleTypeEnum(Enum):\n    red = 'red'\n    amber = 'amber'\n    green = 'green'\n    NoneType_None = None\n    int_42 = 42\n\n\nclass SingleEnum(BaseModel):\n    __root__: Literal['pet'] = 'pet'\n\n\nclass ArrayEnum(BaseModel):\n    __root__: List[Union[Literal['cat'], Literal['dog']]]\n\n\nclass NestedVersionEnum(Enum):\n    RC1 = 'RC1'\n    RC1N = 'RC1N'\n    RC2 = 'RC2'\n    RC2N = 'RC2N'\n    RC3 = 'RC3'\n    RC4 = 'RC4'\n\n\nclass NestedVersion(BaseModel):\n    __root__: Optional[NestedVersionEnum] = Field(\n        'RC1', description='nullable enum', example='RC2'\n    )\n\n\nclass NestedNullableEnum(BaseModel):\n    nested_version: Optional[NestedVersion] = Field(\n        default_factory=lambda: NestedVersion.parse_obj('RC1'),\n        description='nullable enum',\n        example='RC2',\n    )\n\n\nclass VersionEnum(Enum):\n    RC1 = 'RC1'\n    RC1N = 'RC1N'\n    RC2 = 'RC2'\n    RC2N = 'RC2N'\n    RC3 = 'RC3'\n    RC4 = 'RC4'\n\n\nclass Version(BaseModel):\n    __root__: Optional[VersionEnum] = Field(\n        'RC1', description='nullable enum', example='RC2'\n    )\n</code></pre>","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#use-serialize-as-any","level":2,"title":"<code>--use-serialize-as-any</code>","text":"<p>Wrap fields with subtypes in Pydantic's SerializeAsAny.</p> <p>The <code>--use-serialize-as-any</code> flag applies Pydantic v2's SerializeAsAny wrapper to fields that have subtype relationships, ensuring proper serialization of polymorphic types and inheritance hierarchies.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-serialize-as-any # (1)!\n</code></pre> <ol> <li> <code>--use-serialize-as-any</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: SerializeAsAny Test\n  description: Test schema for SerializeAsAny annotation on types with subtypes\npaths: {}\ncomponents:\n  schemas:\n    User:\n      type: object\n      description: Base user model\n      properties:\n        name:\n          type: string\n          description: User's name\n      required:\n        - name\n\n    AdminUser:\n      allOf:\n        - $ref: '#/components/schemas/User'\n        - type: object\n          description: Admin user with additional permissions\n          properties:\n            admin_level:\n              type: integer\n              description: Admin permission level\n          required:\n            - admin_level\n\n    Container:\n      type: object\n      description: Container that holds user references\n      properties:\n        admin_user_field:\n          $ref: '#/components/schemas/AdminUser'\n          description: Field that should not use SerializeAsAny\n        user_field:\n          $ref: '#/components/schemas/User'\n          description: Field that should use SerializeAsAny\n        user_list:\n          type: array\n          description: List of users that should use SerializeAsAny\n          items:\n            $ref: '#/components/schemas/User'\n      required:\n        - user_field\n        - user_list\n        - admin_user_field\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  serialize_as_any.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List\n\nfrom pydantic import BaseModel, Field, SerializeAsAny\n\n\nclass User(BaseModel):\n    name: str = Field(..., description=\"User's name\")\n\n\nclass AdminUser(User):\n    admin_level: int = Field(..., description='Admin permission level')\n\n\nclass Container(BaseModel):\n    admin_user_field: AdminUser = Field(\n        ..., description='Field that should not use SerializeAsAny'\n    )\n    user_field: SerializeAsAny[User] = Field(\n        ..., description='Field that should use SerializeAsAny'\n    )\n    user_list: List[SerializeAsAny[User]] = Field(\n        ..., description='List of users that should use SerializeAsAny'\n    )\n</code></pre>","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/model-customization/#use-subclass-enum","level":2,"title":"<code>--use-subclass-enum</code>","text":"<p>Generate typed Enum subclasses for enums with specific field types.</p> <p>The <code>--use-subclass-enum</code> flag generates Enum classes as subclasses of the appropriate field type (int, float, bytes, str) when an enum has a specific type, providing better type safety and IDE support.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-subclass-enum # (1)!\n</code></pre> <ol> <li> <code>--use-subclass-enum</code> - the option documented here</li> </ol> Input Schema <pre><code>\"Employee shift status\"\nenum EmployeeShiftStatus {\n  \"not on shift\"\n  NOT_ON_SHIFT\n  \"on shift\"\n  ON_SHIFT\n}\n\nenum Color {\n  RED\n  GREEN\n  BLUE\n}\n\nenum EnumWithOneField {\n    FIELD\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  enums.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\n\nfrom typing_extensions import TypeAlias\n\nBoolean: TypeAlias = bool\n\"\"\"\nThe `Boolean` scalar type represents `true` or `false`.\n\"\"\"\n\n\nString: TypeAlias = str\n\"\"\"\nThe `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\n\"\"\"\n\n\nclass Color(str, Enum):\n    BLUE = 'BLUE'\n    GREEN = 'GREEN'\n    RED = 'RED'\n\n\nclass EmployeeShiftStatus(str, Enum):\n    \"\"\"\n    Employee shift status\n    \"\"\"\n\n    NOT_ON_SHIFT = 'NOT_ON_SHIFT'\n    ON_SHIFT = 'ON_SHIFT'\n\n\nclass EnumWithOneField(str, Enum):\n    FIELD = 'FIELD'\n</code></pre>","path":["CLI Reference","üèóÔ∏è Model Customization"],"tags":[]},{"location":"cli-reference/openapi-only-options/","level":1,"title":"üìò OpenAPI-only Options","text":"","path":["CLI Reference","üìò OpenAPI-only Options"],"tags":[]},{"location":"cli-reference/openapi-only-options/#options","level":2,"title":"üìã Options","text":"Option Description <code>--include-path-parameters</code> Include OpenAPI path parameters in generated parameter model... <code>--openapi-scopes</code> Specify OpenAPI scopes to generate (schemas, paths, paramete... <code>--read-only-write-only-model-type</code> Generate separate request and response models for readOnly/w... <code>--use-operation-id-as-name</code> Use OpenAPI operationId as the generated function/class name... <code>--validation</code> Enable validation constraints (deprecated, use --field-const...","path":["CLI Reference","üìò OpenAPI-only Options"],"tags":[]},{"location":"cli-reference/openapi-only-options/#include-path-parameters","level":2,"title":"<code>--include-path-parameters</code>","text":"<p>Include OpenAPI path parameters in generated parameter models.</p> <p>The <code>--include-path-parameters</code> flag adds path parameters (like /users/{userId}) to the generated request parameter models. By default, only query parameters are included. Use this with <code>--openapi-scopes parameters</code> to generate parameter models that include both path and query parameters.</p> <p>See also: OpenAPI-Specific Options</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --include-path-parameters --openapi-scopes schemas paths parameters # (1)!\n</code></pre> <ol> <li> <code>--include-path-parameters</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: API with Path Parameters\npaths:\n  /users/{userId}/posts/{postId}:\n    get:\n      summary: Get a specific post by user\n      operationId: getUserPost\n      parameters:\n        - name: userId\n          in: path\n          required: true\n          schema:\n            type: integer\n        - name: postId\n          in: path\n          required: true\n          schema:\n            type: string\n        - name: includeComments\n          in: query\n          required: false\n          schema:\n            type: boolean\n      responses:\n        '200':\n          description: A post\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Post\"\ncomponents:\n  schemas:\n    Post:\n      type: object\n      properties:\n        id:\n          type: string\n        title:\n          type: string\n        content:\n          type: string\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  include_path_parameters.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Post(BaseModel):\n    id: Optional[str] = None\n    title: Optional[str] = None\n    content: Optional[str] = None\n\n\nclass UsersUserIdPostsPostIdGetParameters(BaseModel):\n    userId: int\n    postId: str\n    includeComments: Optional[bool] = None\n</code></pre>","path":["CLI Reference","üìò OpenAPI-only Options"],"tags":[]},{"location":"cli-reference/openapi-only-options/#openapi-scopes","level":2,"title":"<code>--openapi-scopes</code>","text":"<p>Specify OpenAPI scopes to generate (schemas, paths, parameters).</p> <p>The <code>--openapi-scopes</code> flag configures the code generation behavior.</p> <p>See also: OpenAPI-Specific Options</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --openapi-scopes paths schemas # (1)!\n</code></pre> <ol> <li> <code>--openapi-scopes</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\n  description: |\n    This description is for testing\n    multi-line\n    description\n\nservers:\n  - url: http://petstore.swagger.io/v1\nsecurity:\n  - BearerAuth: []\npaths:\n  /pets:\n    $ref: '#/components/pathItems/Pets'\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pet\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    put:\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      summary: update a pet\n      tags:\n        - pets\n      requestBody:\n        required: false\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/PetForm'\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\n  /food:\n    post:\n      summary: Create a food\n      tags:\n        - pets\n      requestBody:\n        required: true\n        content:\n          application/problem+json:\n            schema:\n              type: string\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/problem+json:\n              schema:\n                type: string\n  /food/{food_id}:\n    get:\n      summary: Info for a specific pet\n      operationId: showFoodById\n      tags:\n        - foods\n      parameters:\n        - name: food_id\n          in: path\n          description: The id of the food to retrieve\n          schema:\n            type: string\n        - name: message_texts\n          in: query\n          required: false\n          explode: true\n          schema:\n            type: array\n            items:\n              type: string\n      responses:\n        '200':\n          description: OK\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  type: integer\n              examples:\n                example-1:\n                  value:\n                    - 0\n                    - 1\n                    - 3\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\n  /foo:\n    get:\n      tags:\n        - foo\n      responses:\n        '200':\n          description: OK\n          content:\n            application/json:\n              schema:\n                type: string\n    parameters:\n    - $ref: '#/components/parameters/MyParam'\n  /bar:\n    post:\n      summary: Create a bar\n      tags:\n        - bar\n      requestBody:\n        content:\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: '#/components/schemas/PetForm'\n  /user:\n    get:\n      tags:\n        - user\n      responses:\n        '200':\n          description: OK\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  timestamp:\n                    type: string\n                    format: date-time\n                  name:\n                    type: string\n                  age:\n                    type: string\n                required:\n                  - name\n                  - timestamp\n    post:\n      tags:\n        - user\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                timestamp:\n                  type: string\n                  format: date-time\n                name:\n                  type: string\n                age:\n                  type: string\n              required:\n                - name\n                - timestamp\n      responses:\n        '201':\n          description: OK\n  /users:\n    get:\n      tags:\n        - user\n      responses:\n        '200':\n          description: OK\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  type: object\n                  properties:\n                    timestamp:\n                      type: string\n                      format: date-time\n                    name:\n                      type: string\n                    age:\n                      type: string\n                  required:\n                    - name\n                    - timestamp\n    post:\n      tags:\n        - user\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              type: array\n              items:\n                type: object\n                properties:\n                  timestamp:\n                    type: string\n                    format: date-time\n                  name:\n                    type: string\n                  age:\n                    type: string\n                required:\n                  - name\n                  - timestamp\n      responses:\n        '201':\n          description: OK\ncomponents:\n  parameters:\n    MyParam:\n      name: foo\n      in: query\n      schema:\n        type: string\n  securitySchemes:\n    BearerAuth:\n      type: http\n      scheme: bearer\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        tag:\n          type: string\n    Error:\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    PetForm:\n      title: PetForm\n      type: object\n      properties:\n        name:\n          type: string\n        age:\n          type: integer\n  pathItems:\n    Pets:\n      get:\n        summary: List all pets\n        operationId: listPets\n        tags:\n          - pets\n        security: []\n        parameters:\n          - name: limit\n            in: query\n            description: How many items to return at one time (max 100)\n            required: false\n            schema:\n              default: 0\n              type: integer\n              format: int32\n          - name: HomeAddress\n            in: query\n            required: false\n            schema:\n              default: 'Unknown'\n              type: string\n          - name: kind\n            in: query\n            required: false\n            schema:\n              default: dog\n              type: string\n        responses:\n          '200':\n            description: A paged array of pets\n            headers:\n              x-next:\n                description: A link to the next page of responses\n                schema:\n                  type: string\n            content:\n              application/json:\n                schema:\n                  type: array\n                  items:\n                  - $ref: \"#/components/schemas/Pet\"\n          default:\n            description: unexpected error\n            content:\n              application/json:\n                schema:\n                  $ref: \"#/components/schemas/Error\"\n      post:\n        summary: Create a pet\n        tags:\n          - pets\n        requestBody:\n          required: true\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/PetForm'\n        responses:\n          '201':\n            description: Null response\n          default:\n            description: unexpected error\n            content:\n              application/json:\n                schema:\n                  $ref: \"#/components/schemas/Error\"\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  body_and_parameters.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass PetForm(BaseModel):\n    name: Optional[str] = None\n    age: Optional[int] = None\n\n\nclass PetsGetResponse(BaseModel):\n    __root__: List[Pet]\n\n\nclass FoodFoodIdGetResponse(BaseModel):\n    __root__: List[int]\n\n\nclass UserGetResponse(BaseModel):\n    timestamp: datetime\n    name: str\n    age: Optional[str] = None\n\n\nclass UserPostRequest(BaseModel):\n    timestamp: datetime\n    name: str\n    age: Optional[str] = None\n\n\nclass UsersGetResponseItem(BaseModel):\n    timestamp: datetime\n    name: str\n    age: Optional[str] = None\n\n\nclass UsersGetResponse(BaseModel):\n    __root__: List[UsersGetResponseItem]\n\n\nclass UsersPostRequestItem(BaseModel):\n    timestamp: datetime\n    name: str\n    age: Optional[str] = None\n\n\nclass UsersPostRequest(BaseModel):\n    __root__: List[UsersPostRequestItem]\n</code></pre>","path":["CLI Reference","üìò OpenAPI-only Options"],"tags":[]},{"location":"cli-reference/openapi-only-options/#read-only-write-only-model-type","level":2,"title":"<code>--read-only-write-only-model-type</code>","text":"<p>Generate separate request and response models for readOnly/writeOnly fields.</p> <p>The <code>--read-only-write-only-model-type</code> option controls how models with readOnly or writeOnly properties are generated. The 'request-response' mode creates separate Request and Response variants for each schema that contains readOnly or writeOnly fields, allowing proper type validation for API requests and responses without a shared base model.</p> <p>See also: OpenAPI-Specific Options</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --output-model-type pydantic_v2.BaseModel --read-only-write-only-model-type request-response # (1)!\n</code></pre> <ol> <li> <code>--read-only-write-only-model-type</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  title: Read Only Write Only Test API\n  version: \"1.0\"\npaths: {}\ncomponents:\n  schemas:\n    User:\n      type: object\n      required:\n        - id\n        - name\n        - password\n      properties:\n        id:\n          type: integer\n          readOnly: true\n        name:\n          type: string\n        password:\n          type: string\n          writeOnly: true\n        created_at:\n          type: string\n          format: date-time\n          readOnly: true\n        secret_token:\n          type: string\n          writeOnly: true\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  read_only_write_only.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import AwareDatetime, BaseModel\n\n\nclass UserRequest(BaseModel):\n    name: str\n    password: str\n    secret_token: Optional[str] = None\n\n\nclass UserResponse(BaseModel):\n    id: int\n    name: str\n    created_at: Optional[AwareDatetime] = None\n</code></pre>","path":["CLI Reference","üìò OpenAPI-only Options"],"tags":[]},{"location":"cli-reference/openapi-only-options/#use-operation-id-as-name","level":2,"title":"<code>--use-operation-id-as-name</code>","text":"<p>Use OpenAPI operationId as the generated function/class name.</p> <p>The <code>--use-operation-id-as-name</code> flag configures the code generation behavior.</p> <p>See also: OpenAPI-Specific Options</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-operation-id-as-name --openapi-scopes paths schemas parameters # (1)!\n</code></pre> <ol> <li> <code>--use-operation-id-as-name</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: error result\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(BaseModel):\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n\n\nclass ListPetsParametersQuery(BaseModel):\n    limit: Optional[int] = None\n</code></pre>","path":["CLI Reference","üìò OpenAPI-only Options"],"tags":[]},{"location":"cli-reference/openapi-only-options/#validation","level":2,"title":"<code>--validation</code>","text":"<p>Enable validation constraints (deprecated, use --field-constraints).</p> <p>The <code>--validation</code> flag configures the code generation behavior.</p> <p>Deprecated: Use --field-constraints instead</p> <p>See also: OpenAPI-Specific Options, Field Constraints</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --validation # (1)!\n</code></pre> <ol> <li> <code>--validation</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: error result\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(BaseModel):\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","üìò OpenAPI-only Options"],"tags":[]},{"location":"cli-reference/quick-reference/","level":1,"title":"üîç Quick Reference","text":"<p>All CLI options in one page for easy Ctrl+F searching.</p> <p>üëÜ Click any option to see detailed documentation with examples.</p> <pre><code>datamodel-codegen [OPTIONS]\n</code></pre>","path":["CLI Reference","üîç Quick Reference"],"tags":[]},{"location":"cli-reference/quick-reference/#all-options-by-category","level":2,"title":"üìÇ All Options by Category","text":"","path":["CLI Reference","üîç Quick Reference"],"tags":[]},{"location":"cli-reference/quick-reference/#base-options","level":3,"title":"üìÅ Base Options","text":"Option Description <code>--encoding</code> Specify character encoding for input and output files. <code>--input</code> Specify the input schema file path. <code>--input-file-type</code> Specify the input file type for code generation. <code>--output</code> Specify the destination path for generated Python code. <code>--url</code> Fetch schema from URL with custom HTTP headers.","path":["CLI Reference","üîç Quick Reference"],"tags":[]},{"location":"cli-reference/quick-reference/#typing-customization","level":3,"title":"üîß Typing Customization","text":"Option Description <code>--allof-merge-mode</code> Merge constraints from root model references in allOf schemas. <code>--disable-future-imports</code> Prevent automatic addition of future imports in generated code. <code>--enum-field-as-literal</code> Convert all enum fields to Literal types instead of Enum classes. <code>--no-use-specialized-enum</code> Disable specialized Enum classes for Python 3.11+ code generation. <code>--output-datetime-class</code> Specify datetime class type for date-time schema fields. <code>--strict-types</code> Enable strict type validation for specified Python types. <code>--type-mappings</code> Override default type mappings for schema formats. <code>--use-annotated</code> Test GraphQL annotated types with standard collections and union operator. <code>--use-decimal-for-multiple-of</code> Generate Decimal types for fields with multipleOf constraint. <code>--use-generic-container-types</code> Use typing.Dict/List instead of dict/list for container types. <code>--use-non-positive-negative-number-constrained-types</code> Use NonPositive/NonNegative types for number constraints. <code>--use-pendulum</code> Use pendulum types for date/time fields instead of datetime module. <code>--use-standard-collections</code> Use built-in dict/list instead of typing.Dict/List. <code>--use-type-alias</code> Use TypeAlias instead of root models for type definitions (experimental). <code>--use-union-operator</code> Test GraphQL annotated types with standard collections and union operator. <code>--use-unique-items-as-set</code> Generate set types for arrays with uniqueItems constraint.","path":["CLI Reference","üîç Quick Reference"],"tags":[]},{"location":"cli-reference/quick-reference/#field-customization","level":3,"title":"üè∑Ô∏è Field Customization","text":"Option Description <code>--aliases</code> Apply custom field and class name aliases from JSON file. <code>--capitalize-enum-members</code> Capitalize enum member names to UPPER_CASE format. <code>--empty-enum-field-name</code> Name for empty string enum field values. <code>--extra-fields</code> Configure how generated models handle extra fields not defined in schema. <code>--field-constraints</code> Generate Field() with validation constraints from schema. <code>--field-extra-keys</code> Include specific extra keys in Field() definitions. <code>--field-extra-keys-without-x-prefix</code> Include specified schema extension keys in Field() without requiring 'x-' prefix... <code>--field-include-all-keys</code> Include all schema keys in Field() json_schema_extra. <code>--no-alias</code> Disable Field alias generation for non-Python-safe property names. <code>--original-field-name-delimiter</code> Specify delimiter for original field names when using snake-case conversion. <code>--remove-special-field-name-prefix</code> Remove the special prefix from field names. <code>--set-default-enum-member</code> Set the first enum member as the default value for enum fields. <code>--snake-case-field</code> Convert field names to snake_case format. <code>--special-field-name-prefix</code> Prefix to add to special field names (like reserved keywords). <code>--use-attribute-docstrings</code> Generate field descriptions as attribute docstrings instead of Field description... <code>--use-enum-values-in-discriminator</code> Use enum values in discriminator mappings for union types. <code>--use-field-description</code> Include schema descriptions as Field docstrings. <code>--use-inline-field-description</code> Add field descriptions as inline comments. <code>--use-schema-description</code> Use schema description as class docstring. <code>--use-title-as-name</code> Use schema title as the generated class name.","path":["CLI Reference","üîç Quick Reference"],"tags":[]},{"location":"cli-reference/quick-reference/#model-customization","level":3,"title":"üèóÔ∏è Model Customization","text":"Option Description <code>--allow-extra-fields</code> Allow extra fields in generated Pydantic models (extra='allow'). <code>--allow-population-by-field-name</code> Allow Pydantic model population by field name (not just alias). <code>--base-class</code> Specify a custom base class for generated models. <code>--class-name</code> Override the auto-generated class name with a custom name. <code>--collapse-root-models</code> Inline root model definitions instead of creating separate wrapper classes. <code>--dataclass-arguments</code> Customize dataclass decorator arguments via JSON dictionary. <code>--enable-faux-immutability</code> Enable faux immutability in Pydantic v1 models (allow_mutation=False). <code>--force-optional</code> Force all fields to be Optional regardless of required status. <code>--frozen-dataclasses</code> Generate frozen dataclasses with optional keyword-only fields. <code>--keep-model-order</code> Keep model definition order as specified in schema. <code>--keyword-only</code> Generate dataclasses with keyword-only fields (Python 3.10+). <code>--output-model-type</code> Select the output model type (Pydantic v1/v2, dataclasses, TypedDict, msgspec). <code>--parent-scoped-naming</code> Namespace models by their parent scope to avoid naming conflicts. <code>--reuse-model</code> Reuse identical model definitions instead of generating duplicates. <code>--reuse-scope</code> Scope for model reuse detection (root or tree). <code>--skip-root-model</code> Skip generation of root model when schema contains nested definitions. <code>--strict-nullable</code> Strictly handle nullable types in OpenAPI schemas. <code>--strip-default-none</code> Remove fields with None as default value from generated models. <code>--target-python-version</code> Target Python version for generated code syntax and imports. <code>--union-mode</code> Union mode for combining anyOf/oneOf schemas (smart or left_to_right). <code>--use-default</code> Use default values from schema in generated models. <code>--use-default-kwarg</code> Use default= keyword argument instead of positional argument for fields with def... <code>--use-frozen-field</code> Generate frozen (immutable) field definitions for readOnly properties. <code>--use-one-literal-as-default</code> Use single literal value as default when enum has only one option. <code>--use-serialize-as-any</code> Wrap fields with subtypes in Pydantic's SerializeAsAny. <code>--use-subclass-enum</code> Generate typed Enum subclasses for enums with specific field types.","path":["CLI Reference","üîç Quick Reference"],"tags":[]},{"location":"cli-reference/quick-reference/#template-customization","level":3,"title":"üé® Template Customization","text":"Option Description <code>--additional-imports</code> Add custom imports to generated output files. <code>--custom-file-header</code> Add custom header text to the generated file. <code>--custom-file-header-path</code> Add custom header content from file to generated code. <code>--custom-formatters</code> Apply custom Python code formatters to generated output. <code>--custom-formatters-kwargs</code> Pass custom arguments to custom formatters via JSON file. <code>--custom-template-dir</code> Use custom Jinja2 templates for model generation. <code>--disable-appending-item-suffix</code> Disable appending 'Item' suffix to array item types. <code>--disable-timestamp</code> Disable timestamp in generated file header for reproducible output. <code>--enable-command-header</code> Include command-line options in file header for reproducibility. <code>--enable-version-header</code> Include tool version information in file header. <code>--extra-template-data</code> Pass custom template variables from JSON file for code generation. <code>--formatters</code> Specify code formatters to apply to generated output. <code>--treat-dot-as-module</code> Treat dots in schema names as module separators. <code>--use-double-quotes</code> Use double quotes for string literals in generated code. <code>--use-exact-imports</code> Import exact types instead of modules. <code>--wrap-string-literal</code> Wrap long string literals across multiple lines.","path":["CLI Reference","üîç Quick Reference"],"tags":[]},{"location":"cli-reference/quick-reference/#openapi-only-options","level":3,"title":"üìò OpenAPI-only Options","text":"Option Description <code>--include-path-parameters</code> Include OpenAPI path parameters in generated parameter models. <code>--openapi-scopes</code> Specify OpenAPI scopes to generate (schemas, paths, parameters). <code>--read-only-write-only-model-type</code> Generate separate request and response models for readOnly/writeOnly fields. <code>--use-operation-id-as-name</code> Use OpenAPI operationId as the generated function/class name. <code>--validation</code> Enable validation constraints (deprecated, use --field-constraints).","path":["CLI Reference","üîç Quick Reference"],"tags":[]},{"location":"cli-reference/quick-reference/#general-options","level":3,"title":"‚öôÔ∏è General Options","text":"Option Description <code>--all-exports-collision-strategy</code> Handle name collisions when exporting recursive module hierarchies. <code>--all-exports-scope</code> Generate all exports for child modules in init.py files. <code>--check</code> Verify generated code matches existing output without modifying files. <code>--disable-warnings</code> Suppress warning messages during code generation. <code>--generate-cli-command</code> Generate CLI command from pyproject.toml configuration. <code>--generate-pyproject-config</code> Generate pyproject.toml configuration from CLI arguments. <code>--http-headers</code> Fetch schema from URL with custom HTTP headers. <code>--http-ignore-tls</code> Disable TLS certificate verification for HTTPS requests. <code>--http-query-parameters</code> Add query parameters to HTTP requests for remote schemas. <code>--ignore-pyproject</code> Ignore pyproject.toml configuration file. <code>--shared-module-name</code> Customize the name of the shared module for deduplicated models. <code>--watch</code> Watch mode cannot be used with --check mode. <code>--watch-delay</code> Watch mode starts file watcher and handles clean exit.","path":["CLI Reference","üîç Quick Reference"],"tags":[]},{"location":"cli-reference/quick-reference/#utility-options","level":3,"title":"üìù Utility Options","text":"Option Description <code>--debug</code> Show debug messages during code generation <code>--help</code> Show help message and exit <code>--no-color</code> Disable colorized output <code>--profile</code> Use a named profile from pyproject.toml <code>--version</code> Show program version and exit","path":["CLI Reference","üîç Quick Reference"],"tags":[]},{"location":"cli-reference/quick-reference/#alphabetical-index","level":2,"title":"üî§ Alphabetical Index","text":"<p>All options sorted alphabetically:</p> <ul> <li><code>--additional-imports</code> - Add custom imports to generated output files.</li> <li><code>--aliases</code> - Apply custom field and class name aliases from JSON file.</li> <li><code>--all-exports-collision-strategy</code> - Handle name collisions when exporting recursive module hiera...</li> <li><code>--all-exports-scope</code> - Generate all exports for child modules in init.py fi...</li> <li><code>--allof-merge-mode</code> - Merge constraints from root model references in allOf schema...</li> <li><code>--allow-extra-fields</code> - Allow extra fields in generated Pydantic models (extra='allo...</li> <li><code>--allow-population-by-field-name</code> - Allow Pydantic model population by field name (not just alia...</li> <li><code>--base-class</code> - Specify a custom base class for generated models.</li> <li><code>--capitalize-enum-members</code> - Capitalize enum member names to UPPER_CASE format.</li> <li><code>--check</code> - Verify generated code matches existing output without modify...</li> <li><code>--class-name</code> - Override the auto-generated class name with a custom name.</li> <li><code>--collapse-root-models</code> - Inline root model definitions instead of creating separate w...</li> <li><code>--custom-file-header</code> - Add custom header text to the generated file.</li> <li><code>--custom-file-header-path</code> - Add custom header content from file to generated code.</li> <li><code>--custom-formatters</code> - Apply custom Python code formatters to generated output.</li> <li><code>--custom-formatters-kwargs</code> - Pass custom arguments to custom formatters via JSON file.</li> <li><code>--custom-template-dir</code> - Use custom Jinja2 templates for model generation.</li> <li><code>--dataclass-arguments</code> - Customize dataclass decorator arguments via JSON dictionary.</li> <li><code>--debug</code> - Show debug messages during code generation</li> <li><code>--disable-appending-item-suffix</code> - Disable appending 'Item' suffix to array item types.</li> <li><code>--disable-future-imports</code> - Prevent automatic addition of future imports in generate...</li> <li><code>--disable-timestamp</code> - Disable timestamp in generated file header for reproducible ...</li> <li><code>--disable-warnings</code> - Suppress warning messages during code generation.</li> <li><code>--empty-enum-field-name</code> - Name for empty string enum field values.</li> <li><code>--enable-command-header</code> - Include command-line options in file header for reproducibil...</li> <li><code>--enable-faux-immutability</code> - Enable faux immutability in Pydantic v1 models (allow_mutati...</li> <li><code>--enable-version-header</code> - Include tool version information in file header.</li> <li><code>--encoding</code> - Specify character encoding for input and output files.</li> <li><code>--enum-field-as-literal</code> - Convert all enum fields to Literal types instead of Enum cla...</li> <li><code>--extra-fields</code> - Configure how generated models handle extra fields not defin...</li> <li><code>--extra-template-data</code> - Pass custom template variables from JSON file for code gener...</li> <li><code>--field-constraints</code> - Generate Field() with validation constraints from schema.</li> <li><code>--field-extra-keys</code> - Include specific extra keys in Field() definitions.</li> <li><code>--field-extra-keys-without-x-prefix</code> - Include specified schema extension keys in Field() without r...</li> <li><code>--field-include-all-keys</code> - Include all schema keys in Field() json_schema_extra.</li> <li><code>--force-optional</code> - Force all fields to be Optional regardless of required statu...</li> <li><code>--formatters</code> - Specify code formatters to apply to generated output.</li> <li><code>--frozen-dataclasses</code> - Generate frozen dataclasses with optional keyword-only field...</li> <li><code>--generate-cli-command</code> - Generate CLI command from pyproject.toml configuration.</li> <li><code>--generate-pyproject-config</code> - Generate pyproject.toml configuration from CLI arguments.</li> <li><code>--help</code> - Show help message and exit</li> <li><code>--http-headers</code> - Fetch schema from URL with custom HTTP headers.</li> <li><code>--http-ignore-tls</code> - Disable TLS certificate verification for HTTPS requests.</li> <li><code>--http-query-parameters</code> - Add query parameters to HTTP requests for remote schemas.</li> <li><code>--ignore-pyproject</code> - Ignore pyproject.toml configuration file.</li> <li><code>--include-path-parameters</code> - Include OpenAPI path parameters in generated parameter model...</li> <li><code>--input</code> - Specify the input schema file path.</li> <li><code>--input-file-type</code> - Specify the input file type for code generation.</li> <li><code>--keep-model-order</code> - Keep model definition order as specified in schema.</li> <li><code>--keyword-only</code> - Generate dataclasses with keyword-only fields (Python 3.10+)...</li> <li><code>--no-alias</code> - Disable Field alias generation for non-Python-safe property ...</li> <li><code>--no-color</code> - Disable colorized output</li> <li><code>--no-use-specialized-enum</code> - Disable specialized Enum classes for Python 3.11+ code gener...</li> <li><code>--openapi-scopes</code> - Specify OpenAPI scopes to generate (schemas, paths, paramete...</li> <li><code>--original-field-name-delimiter</code> - Specify delimiter for original field names when using snake-...</li> <li><code>--output</code> - Specify the destination path for generated Python code.</li> <li><code>--output-datetime-class</code> - Specify datetime class type for date-time schema fields.</li> <li><code>--output-model-type</code> - Select the output model type (Pydantic v1/v2, dataclasses, T...</li> <li><code>--parent-scoped-naming</code> - Namespace models by their parent scope to avoid naming confl...</li> <li><code>--profile</code> - Use a named profile from pyproject.toml</li> <li><code>--read-only-write-only-model-type</code> - Generate separate request and response models for readOnly/w...</li> <li><code>--remove-special-field-name-prefix</code> - Remove the special prefix from field names.</li> <li><code>--reuse-model</code> - Reuse identical model definitions instead of generating dupl...</li> <li><code>--reuse-scope</code> - Scope for model reuse detection (root or tree).</li> <li><code>--set-default-enum-member</code> - Set the first enum member as the default value for enum fiel...</li> <li><code>--shared-module-name</code> - Customize the name of the shared module for deduplicated mod...</li> <li><code>--skip-root-model</code> - Skip generation of root model when schema contains nested de...</li> <li><code>--snake-case-field</code> - Convert field names to snake_case format.</li> <li><code>--special-field-name-prefix</code> - Prefix to add to special field names (like reserved keywords...</li> <li><code>--strict-nullable</code> - Strictly handle nullable types in OpenAPI schemas.</li> <li><code>--strict-types</code> - Enable strict type validation for specified Python types.</li> <li><code>--strip-default-none</code> - Remove fields with None as default value from generated mode...</li> <li><code>--target-python-version</code> - Target Python version for generated code syntax and imports.</li> <li><code>--treat-dot-as-module</code> - Treat dots in schema names as module separators.</li> <li><code>--type-mappings</code> - Override default type mappings for schema formats.</li> <li><code>--union-mode</code> - Union mode for combining anyOf/oneOf schemas (smart or left_...</li> <li><code>--url</code> - Fetch schema from URL with custom HTTP headers.</li> <li><code>--use-annotated</code> - Test GraphQL annotated types with standard collections and u...</li> <li><code>--use-attribute-docstrings</code> - Generate field descriptions as attribute docstrings instead ...</li> <li><code>--use-decimal-for-multiple-of</code> - Generate Decimal types for fields with multipleOf constraint...</li> <li><code>--use-default</code> - Use default values from schema in generated models.</li> <li><code>--use-default-kwarg</code> - Use default= keyword argument instead of positional argument...</li> <li><code>--use-double-quotes</code> - Use double quotes for string literals in generated code.</li> <li><code>--use-enum-values-in-discriminator</code> - Use enum values in discriminator mappings for union types.</li> <li><code>--use-exact-imports</code> - Import exact types instead of modules.</li> <li><code>--use-field-description</code> - Include schema descriptions as Field docstrings.</li> <li><code>--use-frozen-field</code> - Generate frozen (immutable) field definitions for readOnly p...</li> <li><code>--use-generic-container-types</code> - Use typing.Dict/List instead of dict/list for container type...</li> <li><code>--use-inline-field-description</code> - Add field descriptions as inline comments.</li> <li><code>--use-non-positive-negative-number-constrained-types</code> - Use NonPositive/NonNegative types for number constraints.</li> <li><code>--use-one-literal-as-default</code> - Use single literal value as default when enum has only one o...</li> <li><code>--use-operation-id-as-name</code> - Use OpenAPI operationId as the generated function/class name...</li> <li><code>--use-pendulum</code> - Use pendulum types for date/time fields instead of datetime ...</li> <li><code>--use-schema-description</code> - Use schema description as class docstring.</li> <li><code>--use-serialize-as-any</code> - Wrap fields with subtypes in Pydantic's SerializeAsAny.</li> <li><code>--use-standard-collections</code> - Use built-in dict/list instead of typing.Dict/List.</li> <li><code>--use-subclass-enum</code> - Generate typed Enum subclasses for enums with specific field...</li> <li><code>--use-title-as-name</code> - Use schema title as the generated class name.</li> <li><code>--use-type-alias</code> - Use TypeAlias instead of root models for type definitions (e...</li> <li><code>--use-union-operator</code> - Test GraphQL annotated types with standard collections and u...</li> <li><code>--use-unique-items-as-set</code> - Generate set types for arrays with uniqueItems constraint.</li> <li><code>--validation</code> - Enable validation constraints (deprecated, use --field-const...</li> <li><code>--version</code> - Show program version and exit</li> <li><code>--watch</code> - Watch mode cannot be used with --check mode.</li> <li><code>--watch-delay</code> - Watch mode starts file watcher and handles clean exit.</li> <li><code>--wrap-string-literal</code> - Wrap long string literals across multiple lines.</li> </ul>","path":["CLI Reference","üîç Quick Reference"],"tags":[]},{"location":"cli-reference/template-customization/","level":1,"title":"üé® Template Customization","text":"","path":["CLI Reference","üé® Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#options","level":2,"title":"üìã Options","text":"Option Description <code>--additional-imports</code> Add custom imports to generated output files. <code>--custom-file-header</code> Add custom header text to the generated file. <code>--custom-file-header-path</code> Add custom header content from file to generated code. <code>--custom-formatters</code> Apply custom Python code formatters to generated output. <code>--custom-formatters-kwargs</code> Pass custom arguments to custom formatters via JSON file. <code>--custom-template-dir</code> Use custom Jinja2 templates for model generation. <code>--disable-appending-item-suffix</code> Disable appending 'Item' suffix to array item types. <code>--disable-timestamp</code> Disable timestamp in generated file header for reproducible ... <code>--enable-command-header</code> Include command-line options in file header for reproducibil... <code>--enable-version-header</code> Include tool version information in file header. <code>--extra-template-data</code> Pass custom template variables from JSON file for code gener... <code>--formatters</code> Specify code formatters to apply to generated output. <code>--treat-dot-as-module</code> Treat dots in schema names as module separators. <code>--use-double-quotes</code> Use double quotes for string literals in generated code. <code>--use-exact-imports</code> Import exact types instead of modules. <code>--wrap-string-literal</code> Wrap long string literals across multiple lines.","path":["CLI Reference","üé® Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#additional-imports","level":2,"title":"<code>--additional-imports</code>","text":"<p>Add custom imports to generated output files.</p> <p>The <code>--additional-imports</code> flag allows you to specify custom imports as a comma-delimited list that will be added to the generated output file. This is useful when using custom types defined in external modules (e.g., \"datetime.datetime,datetime.date,mymodule.myclass.MyCustomPythonClass\").</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --additional-imports datetime.datetime,datetime.date,mymodule.myclass.MyCustomPythonClass # (1)!\n</code></pre> <ol> <li> <code>--additional-imports</code> - the option documented here</li> </ol> Input Schema <pre><code>scalar Date\n\n\"DateTime (ISO8601, example: 2020-01-01T10:11:12+00:00)\"\nscalar DateTime\n\nscalar MyCustomClass\n\ntype A {\n  a: Date!\n  b: DateTime!\n  c: MyCustomClass!\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  additional-imports.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom datetime import date, datetime\nfrom typing import Literal, Optional\n\nfrom mymodule.myclass import MyCustomPythonClass\nfrom pydantic import BaseModel, Field\nfrom typing_extensions import TypeAlias\n\nBoolean: TypeAlias = bool\n\"\"\"\nThe `Boolean` scalar type represents `true` or `false`.\n\"\"\"\n\n\nDate: TypeAlias = date\n\n\nDateTime: TypeAlias = datetime\n\"\"\"\nDateTime (ISO8601, example: 2020-01-01T10:11:12+00:00)\n\"\"\"\n\n\nMyCustomClass: TypeAlias = MyCustomPythonClass\n\n\nString: TypeAlias = str\n\"\"\"\nThe `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\n\"\"\"\n\n\nclass A(BaseModel):\n    a: Date\n    b: DateTime\n    c: MyCustomClass\n    typename__: Optional[Literal['A']] = Field('A', alias='__typename')\n</code></pre>","path":["CLI Reference","üé® Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#custom-file-header","level":2,"title":"<code>--custom-file-header</code>","text":"<p>Add custom header text to the generated file.</p> <p>The <code>--custom-file-header</code> flag replaces the default \"generated by datamodel-codegen\" header with custom text. This is useful for adding copyright notices, license headers, or other metadata to generated files.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --custom-file-header \"# Copyright 2024 MyCompany\" # (1)!\n</code></pre> <ol> <li> <code>--custom-file-header</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Person\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"first-name\": {\n      \"type\": \"string\"\n    },\n    \"last-name\": {\n      \"type\": \"string\"\n    },\n    \"email_address\": {\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\"first-name\", \"last-name\"]\n}\n</code></pre> Output With OptionWithout Option <pre><code># Copyright 2024 MyCompany\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Person(BaseModel):\n    first_name: str = Field(..., alias='first-name')\n    last_name: str = Field(..., alias='last-name')\n    email_address: Optional[str] = None\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  no_alias.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Person(BaseModel):\n    first_name: str = Field(..., alias='first-name')\n    last_name: str = Field(..., alias='last-name')\n    email_address: Optional[str] = None\n</code></pre>","path":["CLI Reference","üé® Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#custom-file-header-path","level":2,"title":"<code>--custom-file-header-path</code>","text":"<p>Add custom header content from file to generated code.</p> <p>The <code>--custom-file-header-path</code> flag allows you to specify a file containing custom header content (like copyright notices, linting directives, or module docstrings) to be inserted at the top of generated Python files.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --custom-file-header-path custom_file_header.txt # (1)!\n</code></pre> <ol> <li> <code>--custom-file-header-path</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: error result\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output <pre><code># multiline custom ;\n# header ;\n# file ;\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(BaseModel):\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","üé® Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#custom-formatters","level":2,"title":"<code>--custom-formatters</code>","text":"<p>Apply custom Python code formatters to generated output.</p> <p>The <code>--custom-formatters</code> flag allows you to specify custom Python functions that will be applied to format the generated code. The formatter is specified as a module path (e.g., \"mymodule.formatter_function\"). This is useful for adding custom comments, modifying code structure, or applying project-specific formatting rules beyond what black/isort provide.</p> <p>See also: Custom Code Formatters</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --custom-formatters tests.data.python.custom_formatters.add_comment # (1)!\n</code></pre> <ol> <li> <code>--custom-formatters</code> - the option documented here</li> </ol> Input Schema <pre><code>scalar Long\n\ntype A {\n  id: ID!\n  duration: Long!\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  custom-scalar-types.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\n# a comment\nfrom __future__ import annotations\n\nfrom typing import Literal, Optional\n\nfrom pydantic import BaseModel, Field\nfrom typing_extensions import TypeAlias\n\nBoolean: TypeAlias = bool\n\"\"\"\nThe `Boolean` scalar type represents `true` or `false`.\n\"\"\"\n\n\nID: TypeAlias = str\n\"\"\"\nThe `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `\"4\"`) or integer (such as `4`) input value will be accepted as an ID.\n\"\"\"\n\n\nLong: TypeAlias = str\n\n\nString: TypeAlias = str\n\"\"\"\nThe `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\n\"\"\"\n\n\nclass A(BaseModel):\n    duration: Long\n    id: ID\n    typename__: Optional[Literal['A']] = Field('A', alias='__typename')\n</code></pre>","path":["CLI Reference","üé® Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#custom-formatters-kwargs","level":2,"title":"<code>--custom-formatters-kwargs</code>","text":"<p>Pass custom arguments to custom formatters via JSON file.</p> <p>The <code>--custom-formatters-kwargs</code> flag accepts a path to a JSON file containing custom configuration for custom formatters (used with --custom-formatters). The file should contain a JSON object mapping formatter names to their kwargs.</p> <p>Note: This option is primarily used with --custom-formatters to pass configuration to user-defined formatter modules.</p> <p>See also: Custom Code Formatters</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --custom-formatters-kwargs formatter_kwargs.json # (1)!\n</code></pre> <ol> <li> <code>--custom-formatters-kwargs</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Pet\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"tag\": {\n      \"type\": \"string\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  pet_simple.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    id: Optional[int] = None\n    name: Optional[str] = None\n    tag: Optional[str] = None\n</code></pre>","path":["CLI Reference","üé® Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#custom-template-dir","level":2,"title":"<code>--custom-template-dir</code>","text":"<p>Use custom Jinja2 templates for model generation.</p> <p>The <code>--custom-template-dir</code> option allows you to specify a directory containing custom Jinja2 templates to override the default templates used for generating data models. This enables full customization of the generated code structure and formatting. Use with <code>--extra-template-data</code> to pass additional data to the templates.</p> <p>See also: Custom Templates</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --custom-template-dir templates --extra-template-data openapi/extra_data.json # (1)!\n</code></pre> <ol> <li> <code>--custom-template-dir</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: error result\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 1985-10-26T08:21:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):  # 1 2, 1 2, this is just a pet\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(BaseModel):\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = None\n    apiVersionNumber: Optional[str] = None\n    apiUrl: Optional[AnyUrl] = None\n    apiDocumentationUrl: Optional[AnyUrl] = None\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","üé® Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#disable-appending-item-suffix","level":2,"title":"<code>--disable-appending-item-suffix</code>","text":"<p>Disable appending 'Item' suffix to array item types.</p> <p>The <code>--disable-appending-item-suffix</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --disable-appending-item-suffix --field-constraints # (1)!\n</code></pre> <ol> <li> <code>--disable-appending-item-suffix</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n            minimum: 0\n            maximum: 100\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          minimum: 0\n          maximum: 9223372036854775807\n        name:\n          type: string\n          maxLength: 256\n        tag:\n          type: string\n          maxLength: 64\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n      maxItems: 10\n      minItems: 1\n      uniqueItems: true\n    UID:\n      type: integer\n      minimum: 0\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n          - uid\n        properties:\n          id:\n            type: integer\n            format: int64\n            minimum: 0\n          name:\n            type: string\n            maxLength: 256\n          tag:\n            type: string\n            maxLength: 64\n          uid:\n            $ref: '#/components/schemas/UID'\n          phones:\n            type: array\n            items:\n              type: string\n              minLength: 3\n            maxItems: 10\n          fax:\n            type: array\n            items:\n              type: string\n              minLength: 3\n          height:\n            type:\n              - integer\n              - number\n            minimum: 1\n            maximum: 300\n          weight:\n            type:\n              - number\n              - integer\n            minimum: 1.0\n            maximum: 1000.0\n          age:\n            type: integer\n            minimum: 0.0\n            maximum: 200.0\n            exclusiveMinimum: true\n          rating:\n            type: number\n            minimum: 0\n            exclusiveMinimum: True\n            maximum: 5\n\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            minLength: 1\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  api_constrained.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional, Union\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int = Field(..., ge=0, le=9223372036854775807)\n    name: str = Field(..., max_length=256)\n    tag: Optional[str] = Field(None, max_length=64)\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet] = Field(..., max_items=10, min_items=1, unique_items=True)\n\n\nclass UID(BaseModel):\n    __root__: int = Field(..., ge=0)\n\n\nclass Phone(BaseModel):\n    __root__: str = Field(..., min_length=3)\n\n\nclass Fax(BaseModel):\n    __root__: str = Field(..., min_length=3)\n\n\nclass User(BaseModel):\n    id: int = Field(..., ge=0)\n    name: str = Field(..., max_length=256)\n    tag: Optional[str] = Field(None, max_length=64)\n    uid: UID\n    phones: Optional[List[Phone]] = Field(None, max_items=10)\n    fax: Optional[List[Fax]] = None\n    height: Optional[Union[int, float]] = Field(None, ge=1.0, le=300.0)\n    weight: Optional[Union[float, int]] = Field(None, ge=1.0, le=1000.0)\n    age: Optional[int] = Field(None, gt=0, le=200)\n    rating: Optional[float] = Field(None, gt=0.0, le=5.0)\n\n\nclass Users(BaseModel):\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","üé® Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#disable-timestamp","level":2,"title":"<code>--disable-timestamp</code>","text":"<p>Disable timestamp in generated file header for reproducible output.</p> <p>The <code>--disable-timestamp</code> flag configures the code generation behavior.</p> <p>See also: CI/CD Integration</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --disable-timestamp # (1)!\n</code></pre> <ol> <li> <code>--disable-timestamp</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Info\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"hostName\": {\n      \"type\": \"string\",\n      \"format\": \"hostname\"\n    },\n    \"arn\": {\n      \"type\": \"string\",\n      \"pattern\": \"(^arn:([^:]*):([^:]*):([^:]*):(|\\\\*|[\\\\d]{12}):(.+)$)|^\\\\*$\"\n    },\n    \"tel\": {\n      \"type\": \"string\",\n      \"pattern\": \"^(\\\\([0-9]{3}\\\\))?[0-9]{3}-[0-9]{4}$\"\n    },\n    \"comment\": {\n        \"type\": \"string\",\n        \"pattern\": \"[^\\b\\f\\n\\r\\t\\\\\\\\a+.?'\\\"|()]+$\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  pattern.json\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, constr\n\n\nclass Info(BaseModel):\n    hostName: Optional[\n        constr(\n            regex=r'^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]{0,61}[A-Za-z0-9])\\Z'\n        )\n    ] = None\n    arn: Optional[\n        constr(regex=r'(^arn:([^:]*):([^:]*):([^:]*):(|\\*|[\\d]{12}):(.+)$)|^\\*$')\n    ] = None\n    tel: Optional[constr(regex=r'^(\\([0-9]{3}\\))?[0-9]{3}-[0-9]{4}$')] = None\n    comment: Optional[constr(regex=r'[^\\b\\f\\n\\r\\t\\\\a+.?\\'\"|()]+$')] = None\n</code></pre>","path":["CLI Reference","üé® Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#enable-command-header","level":2,"title":"<code>--enable-command-header</code>","text":"<p>Include command-line options in file header for reproducibility.</p> <p>The <code>--enable-command-header</code> flag adds the full command-line used to generate the file to the header, making it easy to reproduce the generation.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --enable-command-header # (1)!\n</code></pre> <ol> <li> <code>--enable-command-header</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: error result\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n#   command:   datamodel-codegen [COMMAND]\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(BaseModel):\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","üé® Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#enable-version-header","level":2,"title":"<code>--enable-version-header</code>","text":"<p>Include tool version information in file header.</p> <p>The <code>--enable-version-header</code> flag configures the code generation behavior.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --enable-version-header # (1)!\n</code></pre> <ol> <li> <code>--enable-version-header</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: error result\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n#   version:   0.0.0\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(BaseModel):\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","üé® Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#extra-template-data","level":2,"title":"<code>--extra-template-data</code>","text":"<p>Pass custom template variables from JSON file for code generation.</p> <p>The <code>--extra-template-data</code> flag allows you to provide additional variables (from a JSON file) that can be used in custom templates to configure generated model settings like Config classes, enabling customization beyond standard options.</p> <p>See also: Custom Templates</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --extra-template-data openapi/extra_data.json # (1)!\n</code></pre> <ol> <li> <code>--extra-template-data</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          default: 1\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n        properties:\n          id:\n            type: integer\n            format: int64\n          name:\n            type: string\n          tag:\n            type: string\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      description: error result\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      description: Event object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output Pydantic v1Pydantic v2 <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 1985-10-26T08:21:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):  # 1 2, 1 2, this is just a pet\n    class Config:\n        arbitrary_types_allowed = True\n\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(BaseModel):\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 1985-10-26T08:21:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, ConfigDict, Field, RootModel\n\n\nclass Pet(BaseModel):  # 1 2, 1 2, this is just a pet\n    model_config = ConfigDict(\n        arbitrary_types_allowed=True,\n        coerce_numbers_to_str=True,\n    )\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(RootModel[List[Pet]]):\n    root: List[Pet]\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Users(RootModel[List[User]]):\n    root: List[User]\n\n\nclass Id(RootModel[str]):\n    root: str\n\n\nclass Rules(RootModel[List[str]]):\n    root: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(RootModel[List[Api]]):\n    root: List[Api]\n\n\nclass Event(BaseModel):\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","üé® Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#formatters","level":2,"title":"<code>--formatters</code>","text":"<p>Specify code formatters to apply to generated output.</p> <p>The <code>--formatters</code> flag specifies which code formatters to apply to the generated Python code. Available formatters are: black, isort, ruff, yapf, autopep8, autoflake. Default is [black, isort]. Use this to customize formatting or disable formatters entirely.</p> <p>See also: CI/CD Integration, Code Formatting</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --formatters isort # (1)!\n</code></pre> <ol> <li> <code>--formatters</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Pet\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"tag\": {\n      \"type\": \"string\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  pet_simple.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    id: Optional[int] = None\n    name: Optional[str] = None\n    tag: Optional[str] = None\n</code></pre>","path":["CLI Reference","üé® Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#treat-dot-as-module","level":2,"title":"<code>--treat-dot-as-module</code>","text":"<p>Treat dots in schema names as module separators.</p> <p>The <code>--treat-dot-as-module</code> flag configures the code generation behavior.</p> <p>See also: Module Structure and Exports</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --treat-dot-as-module # (1)!\n</code></pre> <ol> <li> <code>--treat-dot-as-module</code> - the option documented here</li> </ol> Input Schema <pre><code># model.schema.json\n{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"User\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"age\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\"name\"]\n}\n</code></pre> Output <pre><code># __init__.py\n# generated by datamodel-codegen:\n#   filename:  treat_dot_as_module_single\n#   timestamp: 2019-07-26T00:00:00+00:00\n\n# model/__init__.py\n# generated by datamodel-codegen:\n#   filename:  treat_dot_as_module_single\n#   timestamp: 2019-07-26T00:00:00+00:00\n\n# model/schema.py\n# generated by datamodel-codegen:\n#   filename:  model.schema.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    name: str\n    age: Optional[int] = None\n</code></pre>","path":["CLI Reference","üé® Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#use-double-quotes","level":2,"title":"<code>--use-double-quotes</code>","text":"<p>Use double quotes for string literals in generated code.</p> <p>The --use-double-quotes option formats all string literals in the generated Python code with double quotes instead of the default single quotes. This helps maintain consistency with codebases that prefer double-quote formatting.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-double-quotes # (1)!\n</code></pre> <ol> <li> <code>--use-double-quotes</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$id\": \"https://example.com/schemas/MapState.json\",\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"MapState\",\n  \"allOf\": [\n    {\n      \"anyOf\": [\n        {\n          \"type\": \"object\",\n          \"properties\": {\n            \"latitude\": {\"type\": \"number\", \"minimum\": -90, \"maximum\": 90},\n            \"longitude\": {\"type\": \"number\", \"minimum\": -180, \"maximum\": 180},\n            \"zoom\": {\"type\": \"number\", \"minimum\": 0, \"maximum\": 25, \"default\": 0},\n            \"bearing\": {\"type\": \"number\"},\n            \"pitch\": {\"type\": \"number\", \"minimum\": 0, \"exclusiveMaximum\": 90},\n            \"dragRotate\": {\"type\": \"boolean\"},\n            \"mapSplitMode\": {\"type\": \"string\", \"const\": \"SINGLE_MAP\"},\n            \"isSplit\": {\"type\": \"boolean\", \"const\": false, \"default\": false}\n          },\n          \"required\": [\"latitude\", \"longitude\", \"pitch\", \"mapSplitMode\"]\n        },\n        {\n          \"type\": \"object\",\n          \"properties\": {\n            \"latitude\": {\"$ref\": \"#/allOf/0/anyOf/0/properties/latitude\"},\n            \"longitude\": {\"$ref\": \"#/allOf/0/anyOf/0/properties/longitude\"},\n            \"zoom\": {\"$ref\": \"#/allOf/0/anyOf/0/properties/zoom\"},\n            \"bearing\": {\"$ref\": \"#/allOf/0/anyOf/0/properties/bearing\"},\n            \"pitch\": {\"$ref\": \"#/allOf/0/anyOf/0/properties/pitch\"},\n            \"dragRotate\": {\"$ref\": \"#/allOf/0/anyOf/0/properties/dragRotate\"},\n            \"mapSplitMode\": {\"type\": \"string\", \"const\": \"SWIPE_COMPARE\"},\n            \"isSplit\": {\"type\": \"boolean\", \"const\": true, \"default\": true}\n          },\n          \"required\": [\"latitude\", \"longitude\", \"pitch\", \"mapSplitMode\"]\n        }\n      ]\n    },\n    {\n      \"anyOf\": [\n        {\n          \"type\": \"object\",\n          \"properties\": {\n            \"mapViewMode\": {\"type\": \"string\", \"const\": \"MODE_2D\"}\n          },\n          \"required\": [\"mapViewMode\"]\n        },\n        {\n          \"type\": \"object\",\n          \"properties\": {\n            \"mapViewMode\": {\"type\": \"string\", \"const\": \"MODE_3D\"}\n          },\n          \"required\": [\"mapViewMode\"]\n        }\n      ]\n    }\n  ]\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  all_of_any_of_base_class_ref.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional, Union\n\nfrom pydantic import BaseModel, Field, confloat\n\n\nclass MapState1(BaseModel):\n    map_view_mode: str = Field(\"MODE_2D\", alias=\"mapViewMode\", const=True)\n\n\nclass MapState2(BaseModel):\n    latitude: Latitude\n    longitude: Longitude\n    zoom: Optional[Zoom] = Field(default_factory=lambda: Zoom.parse_obj(0))\n    bearing: Optional[Bearing] = None\n    pitch: Pitch\n    drag_rotate: Optional[DragRotate] = Field(None, alias=\"dragRotate\")\n    map_split_mode: str = Field(\"SWIPE_COMPARE\", alias=\"mapSplitMode\", const=True)\n    is_split: bool = Field(True, alias=\"isSplit\", const=True)\n\n\nclass MapState3(BaseModel):\n    pass\n\n\nclass MapState4(MapState1, MapState3):\n    pass\n\n\nclass MapState5(MapState2, MapState3):\n    pass\n\n\nclass MapState6(MapState4):\n    pass\n\n\nclass MapState7(MapState5):\n    pass\n\n\nclass MapState(BaseModel):\n    __root__: Union[MapState4, MapState5, MapState6, MapState7] = Field(\n        ..., title=\"MapState\"\n    )\n\n\nclass Bearing(BaseModel):\n    __root__: float\n\n\nclass DragRotate(BaseModel):\n    __root__: bool\n\n\nclass Latitude(BaseModel):\n    __root__: confloat(ge=-90.0, le=90.0)\n\n\nclass Longitude(BaseModel):\n    __root__: confloat(ge=-180.0, le=180.0)\n\n\nclass Pitch(BaseModel):\n    __root__: confloat(ge=0.0, lt=90.0)\n\n\nclass Zoom(BaseModel):\n    __root__: confloat(ge=0.0, le=25.0)\n</code></pre>","path":["CLI Reference","üé® Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#use-exact-imports","level":2,"title":"<code>--use-exact-imports</code>","text":"<p>Import exact types instead of modules.</p> <p>The <code>--use-exact-imports</code> flag changes import style from module imports to exact type imports. For example, instead of <code>from . import foo</code> then <code>foo.Bar</code>, it generates <code>from .foo import Bar</code>. This can make the generated code more explicit and easier to read.</p> <p>Note: This option primarily affects modular output where imports between modules are generated. For single-file output, the difference is minimal.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-exact-imports # (1)!\n</code></pre> <ol> <li> <code>--use-exact-imports</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Pet\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"tag\": {\n      \"type\": \"string\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  pet_simple.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    id: Optional[int] = None\n    name: Optional[str] = None\n    tag: Optional[str] = None\n</code></pre>","path":["CLI Reference","üé® Template Customization"],"tags":[]},{"location":"cli-reference/template-customization/#wrap-string-literal","level":2,"title":"<code>--wrap-string-literal</code>","text":"<p>Wrap long string literals across multiple lines.</p> <p>The <code>--wrap-string-literal</code> flag breaks long string literals (like descriptions) across multiple lines for better readability, instead of having very long single-line strings in the generated code.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --wrap-string-literal # (1)!\n</code></pre> <ol> <li> <code>--wrap-string-literal</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"LongDescription\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"summary\": {\n      \"type\": \"string\",\n      \"description\": \"summary for object\"\n    },\n    \"description\": {\n      \"type\": \"string\",\n      \"description\": \"datamodel-code-generator. This code generator creates pydantic model from an openapi file and others.\"\n    },\n    \"multi_line\": {\n      \"description\": \"datamodel-code-generator\\nThis code generator creates pydantic model from an openapi file and others.\\n\\n\\nSupported source types\\nOpenAPI 3 (YAML/JSON, OpenAPI Data Type)\\nJSON Schema (JSON Schema Core/JSON Schema Validation)\\nJSON/YAML/CSV Data (it will be converted to JSON Schema)\\nPython dictionary (it will be converted to JSON Schema)\",\n      \"type\": \"string\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  long_description.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass LongDescription(BaseModel):\n    summary: Optional[str] = Field(None, description='summary for object')\n    description: Optional[str] = Field(\n        None,\n        description=(\n            'datamodel-code-generator. This code generator creates pydantic model from'\n            ' an openapi file and others.'\n        ),\n    )\n    multi_line: Optional[str] = Field(\n        None,\n        description=(\n            'datamodel-code-generator\\nThis code generator creates pydantic model from'\n            ' an openapi file and others.\\n\\n\\nSupported source types\\nOpenAPI 3'\n            ' (YAML/JSON, OpenAPI Data Type)\\nJSON Schema (JSON Schema Core/JSON Schema'\n            ' Validation)\\nJSON/YAML/CSV Data (it will be converted to JSON'\n            ' Schema)\\nPython dictionary (it will be converted to JSON Schema)'\n        ),\n    )\n</code></pre>","path":["CLI Reference","üé® Template Customization"],"tags":[]},{"location":"cli-reference/typing-customization/","level":1,"title":"üîß Typing Customization","text":"","path":["CLI Reference","üîß Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#options","level":2,"title":"üìã Options","text":"Option Description <code>--allof-merge-mode</code> Merge constraints from root model references in allOf schema... <code>--disable-future-imports</code> Prevent automatic addition of future imports in generate... <code>--enum-field-as-literal</code> Convert all enum fields to Literal types instead of Enum cla... <code>--no-use-specialized-enum</code> Disable specialized Enum classes for Python 3.11+ code gener... <code>--output-datetime-class</code> Specify datetime class type for date-time schema fields. <code>--strict-types</code> Enable strict type validation for specified Python types. <code>--type-mappings</code> Override default type mappings for schema formats. <code>--use-annotated</code> Test GraphQL annotated types with standard collections and u... <code>--use-decimal-for-multiple-of</code> Generate Decimal types for fields with multipleOf constraint... <code>--use-generic-container-types</code> Use typing.Dict/List instead of dict/list for container type... <code>--use-non-positive-negative-number-constrained-types</code> Use NonPositive/NonNegative types for number constraints. <code>--use-pendulum</code> Use pendulum types for date/time fields instead of datetime ... <code>--use-standard-collections</code> Use built-in dict/list instead of typing.Dict/List. <code>--use-type-alias</code> Use TypeAlias instead of root models for type definitions (e... <code>--use-union-operator</code> Test GraphQL annotated types with standard collections and u... <code>--use-unique-items-as-set</code> Generate set types for arrays with uniqueItems constraint.","path":["CLI Reference","üîß Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#allof-merge-mode","level":2,"title":"<code>--allof-merge-mode</code>","text":"<p>Merge constraints from root model references in allOf schemas.</p> <p>The <code>--allof-merge-mode constraints</code> merges only constraint properties (minLength, maximum, etc.) from parent schemas referenced in allOf. This ensures child schemas inherit validation constraints while keeping other properties separate.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --allof-merge-mode constraints # (1)!\n</code></pre> <ol> <li> <code>--allof-merge-mode</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"definitions\": {\n    \"StringDatatype\": {\n      \"description\": \"A base string type.\",\n      \"type\": \"string\",\n      \"pattern\": \"^\\\\S(.*\\\\S)?$\"\n    },\n    \"ConstrainedStringDatatype\": {\n      \"description\": \"A constrained string.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/StringDatatype\" },\n        { \"type\": \"string\", \"minLength\": 1, \"pattern\": \"^[A-Z].*\" }\n      ]\n    },\n    \"IntegerDatatype\": {\n      \"description\": \"A whole number.\",\n      \"type\": \"integer\"\n    },\n    \"NonNegativeIntegerDatatype\": {\n      \"description\": \"Non-negative integer.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/IntegerDatatype\" },\n        { \"minimum\": 0 }\n      ]\n    },\n    \"BoundedIntegerDatatype\": {\n      \"description\": \"Integer between 0 and 100.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/IntegerDatatype\" },\n        { \"minimum\": 0, \"maximum\": 100 }\n      ]\n    },\n    \"EmailDatatype\": {\n      \"description\": \"Email with format.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/StringDatatype\" },\n        { \"format\": \"email\" }\n      ]\n    },\n    \"FormattedStringDatatype\": {\n      \"description\": \"A string with email format.\",\n      \"type\": \"string\",\n      \"format\": \"email\"\n    },\n    \"ObjectBase\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"id\": { \"type\": \"integer\" }\n      }\n    },\n    \"ObjectWithAllOf\": {\n      \"description\": \"Object inheritance - not a root model.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/ObjectBase\" },\n        { \"type\": \"object\", \"properties\": { \"name\": { \"type\": \"string\" } } }\n      ]\n    },\n    \"MultiRefAllOf\": {\n      \"description\": \"Multiple refs - not handled by new code.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/StringDatatype\" },\n        { \"$ref\": \"#/definitions/IntegerDatatype\" }\n      ]\n    },\n    \"NoConstraintAllOf\": {\n      \"description\": \"No constraints added.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/StringDatatype\" }\n      ]\n    },\n    \"IncompatibleTypeAllOf\": {\n      \"description\": \"Incompatible types.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/StringDatatype\" },\n        { \"type\": \"boolean\" }\n      ]\n    },\n    \"ConstraintWithProperties\": {\n      \"description\": \"Constraint item has properties.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/StringDatatype\" },\n        { \"properties\": { \"extra\": { \"type\": \"string\" } } }\n      ]\n    },\n    \"ConstraintWithItems\": {\n      \"description\": \"Constraint item has items.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/StringDatatype\" },\n        { \"items\": { \"type\": \"string\" } }\n      ]\n    },\n    \"NumberIntegerCompatible\": {\n      \"description\": \"Number and integer are compatible.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/IntegerDatatype\" },\n        { \"type\": \"number\", \"minimum\": 0 }\n      ]\n    },\n    \"RefWithSchemaKeywords\": {\n      \"description\": \"Ref with additional schema keywords.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/StringDatatype\", \"minLength\": 5 },\n        { \"maxLength\": 100 }\n      ]\n    },\n    \"ArrayDatatype\": {\n      \"type\": \"array\",\n      \"items\": { \"type\": \"string\" }\n    },\n    \"RefToArrayAllOf\": {\n      \"description\": \"Ref to array - not a root model.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/ArrayDatatype\" },\n        { \"minItems\": 1 }\n      ]\n    },\n    \"ObjectNoPropsDatatype\": {\n      \"type\": \"object\"\n    },\n    \"RefToObjectNoPropsAllOf\": {\n      \"description\": \"Ref to object without properties - not a root model.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/ObjectNoPropsDatatype\" },\n        { \"minProperties\": 1 }\n      ]\n    },\n    \"PatternPropsDatatype\": {\n      \"patternProperties\": {\n        \"^S_\": { \"type\": \"string\" }\n      }\n    },\n    \"RefToPatternPropsAllOf\": {\n      \"description\": \"Ref to patternProperties - not a root model.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/PatternPropsDatatype\" },\n        { \"minProperties\": 1 }\n      ]\n    },\n    \"NestedAllOfDatatype\": {\n      \"allOf\": [\n        { \"type\": \"string\" },\n        { \"minLength\": 1 }\n      ]\n    },\n    \"RefToNestedAllOfAllOf\": {\n      \"description\": \"Ref to nested allOf - not a root model.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/NestedAllOfDatatype\" },\n        { \"maxLength\": 100 }\n      ]\n    },\n    \"ConstraintsOnlyDatatype\": {\n      \"description\": \"Constraints only, no type.\",\n      \"minLength\": 1,\n      \"pattern\": \"^[A-Z]\"\n    },\n    \"RefToConstraintsOnlyAllOf\": {\n      \"description\": \"Ref to constraints-only schema.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/ConstraintsOnlyDatatype\" },\n        { \"maxLength\": 100 }\n      ]\n    },\n    \"NoDescriptionAllOf\": {\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/StringDatatype\" },\n        { \"minLength\": 5 }\n      ]\n    },\n    \"EmptyConstraintItemAllOf\": {\n      \"description\": \"AllOf with empty constraint item.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/StringDatatype\" },\n        {},\n        { \"maxLength\": 50 }\n      ]\n    },\n    \"ConflictingFormatAllOf\": {\n      \"description\": \"Conflicting formats - falls back to existing behavior.\",\n      \"allOf\": [\n        { \"$ref\": \"#/definitions/FormattedStringDatatype\" },\n        { \"format\": \"date-time\" }\n      ]\n    }\n  },\n  \"type\": \"object\",\n  \"properties\": {\n    \"name\": { \"$ref\": \"#/definitions/ConstrainedStringDatatype\" },\n    \"count\": { \"$ref\": \"#/definitions/NonNegativeIntegerDatatype\" },\n    \"percentage\": { \"$ref\": \"#/definitions/BoundedIntegerDatatype\" },\n    \"email\": { \"$ref\": \"#/definitions/EmailDatatype\" },\n    \"obj\": { \"$ref\": \"#/definitions/ObjectWithAllOf\" },\n    \"multi\": { \"$ref\": \"#/definitions/MultiRefAllOf\" },\n    \"noconstraint\": { \"$ref\": \"#/definitions/NoConstraintAllOf\" },\n    \"incompatible\": { \"$ref\": \"#/definitions/IncompatibleTypeAllOf\" },\n    \"withprops\": { \"$ref\": \"#/definitions/ConstraintWithProperties\" },\n    \"withitems\": { \"$ref\": \"#/definitions/ConstraintWithItems\" },\n    \"numint\": { \"$ref\": \"#/definitions/NumberIntegerCompatible\" },\n    \"refwithkw\": { \"$ref\": \"#/definitions/RefWithSchemaKeywords\" },\n    \"refarr\": { \"$ref\": \"#/definitions/RefToArrayAllOf\" },\n    \"refobjnoprops\": { \"$ref\": \"#/definitions/RefToObjectNoPropsAllOf\" },\n    \"refpatternprops\": { \"$ref\": \"#/definitions/RefToPatternPropsAllOf\" },\n    \"refnestedallof\": { \"$ref\": \"#/definitions/RefToNestedAllOfAllOf\" },\n    \"refconstraintsonly\": { \"$ref\": \"#/definitions/RefToConstraintsOnlyAllOf\" },\n    \"nodescription\": { \"$ref\": \"#/definitions/NoDescriptionAllOf\" },\n    \"emptyconstraint\": { \"$ref\": \"#/definitions/EmptyConstraintItemAllOf\" },\n    \"conflictingformat\": { \"$ref\": \"#/definitions/ConflictingFormatAllOf\" }\n  }\n}\n</code></pre> Output With OptionWithout Option <pre><code># generated by datamodel-codegen:\n#   filename:  allof_root_model_constraints.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Any, Dict, List, Optional\n\nfrom pydantic import BaseModel, EmailStr, Field, conint, constr\n\n\nclass StringDatatype(BaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$') = Field(\n        ..., description='A base string type.'\n    )\n\n\nclass ConstrainedStringDatatype(BaseModel):\n    __root__: constr(regex=r'(?=^\\S(.*\\S)?$)(?=^[A-Z].*)', min_length=1) = Field(\n        ..., description='A constrained string.'\n    )\n\n\nclass IntegerDatatype(BaseModel):\n    __root__: int = Field(..., description='A whole number.')\n\n\nclass NonNegativeIntegerDatatype(BaseModel):\n    __root__: conint(ge=0) = Field(..., description='Non-negative integer.')\n\n\nclass BoundedIntegerDatatype(BaseModel):\n    __root__: conint(ge=0, le=100) = Field(\n        ..., description='Integer between 0 and 100.'\n    )\n\n\nclass EmailDatatype(BaseModel):\n    __root__: EmailStr = Field(..., description='Email with format.')\n\n\nclass FormattedStringDatatype(BaseModel):\n    __root__: EmailStr = Field(..., description='A string with email format.')\n\n\nclass ObjectBase(BaseModel):\n    id: Optional[int] = None\n\n\nclass ObjectWithAllOf(ObjectBase):\n    name: Optional[str] = None\n\n\nclass MultiRefAllOf(BaseModel):\n    pass\n\n\nclass NoConstraintAllOf(BaseModel):\n    pass\n\n\nclass IncompatibleTypeAllOf(BaseModel):\n    pass\n\n\nclass ConstraintWithProperties(BaseModel):\n    extra: Optional[str] = None\n\n\nclass ConstraintWithItems(BaseModel):\n    pass\n\n\nclass NumberIntegerCompatible(BaseModel):\n    __root__: conint(ge=0) = Field(\n        ..., description='Number and integer are compatible.'\n    )\n\n\nclass RefWithSchemaKeywords(BaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$', min_length=5, max_length=100) = Field(\n        ..., description='Ref with additional schema keywords.'\n    )\n\n\nclass ArrayDatatype(BaseModel):\n    __root__: List[str]\n\n\nclass RefToArrayAllOf(BaseModel):\n    pass\n\n\nclass ObjectNoPropsDatatype(BaseModel):\n    pass\n\n\nclass RefToObjectNoPropsAllOf(ObjectNoPropsDatatype):\n    pass\n\n\nclass PatternPropsDatatype(BaseModel):\n    __root__: Dict[constr(regex=r'^S_'), str]\n\n\nclass RefToPatternPropsAllOf(BaseModel):\n    pass\n\n\nclass NestedAllOfDatatype(BaseModel):\n    pass\n\n\nclass RefToNestedAllOfAllOf(NestedAllOfDatatype):\n    pass\n\n\nclass ConstraintsOnlyDatatype(BaseModel):\n    __root__: Any = Field(..., description='Constraints only, no type.')\n\n\nclass RefToConstraintsOnlyAllOf(BaseModel):\n    __root__: Any = Field(..., description='Ref to constraints-only schema.')\n\n\nclass NoDescriptionAllOf(BaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$', min_length=5) = Field(\n        ..., description='A base string type.'\n    )\n\n\nclass EmptyConstraintItemAllOf(BaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$', max_length=50) = Field(\n        ..., description='AllOf with empty constraint item.'\n    )\n\n\nclass ConflictingFormatAllOf(BaseModel):\n    pass\n\n\nclass Model(BaseModel):\n    name: Optional[ConstrainedStringDatatype] = None\n    count: Optional[NonNegativeIntegerDatatype] = None\n    percentage: Optional[BoundedIntegerDatatype] = None\n    email: Optional[EmailDatatype] = None\n    obj: Optional[ObjectWithAllOf] = None\n    multi: Optional[MultiRefAllOf] = None\n    noconstraint: Optional[NoConstraintAllOf] = None\n    incompatible: Optional[IncompatibleTypeAllOf] = None\n    withprops: Optional[ConstraintWithProperties] = None\n    withitems: Optional[ConstraintWithItems] = None\n    numint: Optional[NumberIntegerCompatible] = None\n    refwithkw: Optional[RefWithSchemaKeywords] = None\n    refarr: Optional[RefToArrayAllOf] = None\n    refobjnoprops: Optional[RefToObjectNoPropsAllOf] = None\n    refpatternprops: Optional[RefToPatternPropsAllOf] = None\n    refnestedallof: Optional[RefToNestedAllOfAllOf] = None\n    refconstraintsonly: Optional[RefToConstraintsOnlyAllOf] = None\n    nodescription: Optional[NoDescriptionAllOf] = None\n    emptyconstraint: Optional[EmptyConstraintItemAllOf] = None\n    conflictingformat: Optional[ConflictingFormatAllOf] = None\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  allof_root_model_constraints.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Any, Dict, List, Optional\n\nfrom pydantic import BaseModel, EmailStr, Field, conint, constr\n\n\nclass StringDatatype(BaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$') = Field(\n        ..., description='A base string type.'\n    )\n\n\nclass ConstrainedStringDatatype(BaseModel):\n    __root__: constr(regex=r'^[A-Z].*', min_length=1) = Field(\n        ..., description='A constrained string.'\n    )\n\n\nclass IntegerDatatype(BaseModel):\n    __root__: int = Field(..., description='A whole number.')\n\n\nclass NonNegativeIntegerDatatype(BaseModel):\n    __root__: conint(ge=0) = Field(..., description='Non-negative integer.')\n\n\nclass BoundedIntegerDatatype(BaseModel):\n    __root__: conint(ge=0, le=100) = Field(\n        ..., description='Integer between 0 and 100.'\n    )\n\n\nclass EmailDatatype(BaseModel):\n    __root__: EmailStr = Field(..., description='Email with format.')\n\n\nclass FormattedStringDatatype(BaseModel):\n    __root__: EmailStr = Field(..., description='A string with email format.')\n\n\nclass ObjectBase(BaseModel):\n    id: Optional[int] = None\n\n\nclass ObjectWithAllOf(ObjectBase):\n    name: Optional[str] = None\n\n\nclass MultiRefAllOf(BaseModel):\n    pass\n\n\nclass NoConstraintAllOf(BaseModel):\n    pass\n\n\nclass IncompatibleTypeAllOf(BaseModel):\n    pass\n\n\nclass ConstraintWithProperties(BaseModel):\n    extra: Optional[str] = None\n\n\nclass ConstraintWithItems(BaseModel):\n    pass\n\n\nclass NumberIntegerCompatible(BaseModel):\n    __root__: conint(ge=0) = Field(\n        ..., description='Number and integer are compatible.'\n    )\n\n\nclass RefWithSchemaKeywords(BaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$', min_length=5, max_length=100) = Field(\n        ..., description='Ref with additional schema keywords.'\n    )\n\n\nclass ArrayDatatype(BaseModel):\n    __root__: List[str]\n\n\nclass RefToArrayAllOf(BaseModel):\n    pass\n\n\nclass ObjectNoPropsDatatype(BaseModel):\n    pass\n\n\nclass RefToObjectNoPropsAllOf(ObjectNoPropsDatatype):\n    pass\n\n\nclass PatternPropsDatatype(BaseModel):\n    __root__: Dict[constr(regex=r'^S_'), str]\n\n\nclass RefToPatternPropsAllOf(BaseModel):\n    pass\n\n\nclass NestedAllOfDatatype(BaseModel):\n    pass\n\n\nclass RefToNestedAllOfAllOf(NestedAllOfDatatype):\n    pass\n\n\nclass ConstraintsOnlyDatatype(BaseModel):\n    __root__: Any = Field(..., description='Constraints only, no type.')\n\n\nclass RefToConstraintsOnlyAllOf(BaseModel):\n    __root__: Any = Field(..., description='Ref to constraints-only schema.')\n\n\nclass NoDescriptionAllOf(BaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$', min_length=5) = Field(\n        ..., description='A base string type.'\n    )\n\n\nclass EmptyConstraintItemAllOf(BaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$', max_length=50) = Field(\n        ..., description='AllOf with empty constraint item.'\n    )\n\n\nclass ConflictingFormatAllOf(BaseModel):\n    pass\n\n\nclass Model(BaseModel):\n    name: Optional[ConstrainedStringDatatype] = None\n    count: Optional[NonNegativeIntegerDatatype] = None\n    percentage: Optional[BoundedIntegerDatatype] = None\n    email: Optional[EmailDatatype] = None\n    obj: Optional[ObjectWithAllOf] = None\n    multi: Optional[MultiRefAllOf] = None\n    noconstraint: Optional[NoConstraintAllOf] = None\n    incompatible: Optional[IncompatibleTypeAllOf] = None\n    withprops: Optional[ConstraintWithProperties] = None\n    withitems: Optional[ConstraintWithItems] = None\n    numint: Optional[NumberIntegerCompatible] = None\n    refwithkw: Optional[RefWithSchemaKeywords] = None\n    refarr: Optional[RefToArrayAllOf] = None\n    refobjnoprops: Optional[RefToObjectNoPropsAllOf] = None\n    refpatternprops: Optional[RefToPatternPropsAllOf] = None\n    refnestedallof: Optional[RefToNestedAllOfAllOf] = None\n    refconstraintsonly: Optional[RefToConstraintsOnlyAllOf] = None\n    nodescription: Optional[NoDescriptionAllOf] = None\n    emptyconstraint: Optional[EmptyConstraintItemAllOf] = None\n    conflictingformat: Optional[ConflictingFormatAllOf] = None\n</code></pre>","path":["CLI Reference","üîß Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#disable-future-imports","level":2,"title":"<code>--disable-future-imports</code>","text":"<p>Prevent automatic addition of future imports in generated code.</p> <p>The --disable-future-imports option stops the generator from adding 'from future import annotations' to the output. This is useful when you need compatibility with tools or environments that don't support postponed evaluation of annotations (PEP 563).</p> <p>See also: Python Version Compatibility</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --disable-future-imports --target-python-version 3.10 # (1)!\n</code></pre> <ol> <li> <code>--disable-future-imports</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"DescriptionType\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"metadata\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/definitions/Metadata\"\n      }\n    }\n  },\n  \"definitions\": {\n    \"Metadata\": {\n      \"title\": \"Metadata\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"title\": {\n          \"type\": \"string\"\n        }\n      }\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  keep_model_order_field_references.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel\n\n\nclass Metadata(BaseModel):\n    title: Optional[str] = None\n\n\nclass DescriptionType(BaseModel):\n    metadata: Optional[List[Metadata]] = None\n</code></pre>","path":["CLI Reference","üîß Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#enum-field-as-literal","level":2,"title":"<code>--enum-field-as-literal</code>","text":"<p>Convert all enum fields to Literal types instead of Enum classes.</p> <p>The <code>--enum-field-as-literal all</code> flag converts all enum types to Literal type annotations. This is useful when you want string literal types instead of Enum classes for all enumerations.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --enum-field-as-literal all # (1)!\n</code></pre> <ol> <li> <code>--enum-field-as-literal</code> - the option documented here</li> </ol> Input Schema <pre><code>\"Employee shift status\"\nenum EmployeeShiftStatus {\n  \"not on shift\"\n  NOT_ON_SHIFT\n  \"on shift\"\n  ON_SHIFT\n}\n\nenum Color {\n  RED\n  GREEN\n  BLUE\n}\n\nenum EnumWithOneField {\n    FIELD\n}\n</code></pre> Output With OptionWithout Option <pre><code># generated by datamodel-codegen:\n#   filename:  enums.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Literal\n\nfrom pydantic import BaseModel\nfrom typing_extensions import TypeAlias\n\nBoolean: TypeAlias = bool\n\"\"\"\nThe `Boolean` scalar type represents `true` or `false`.\n\"\"\"\n\n\nString: TypeAlias = str\n\"\"\"\nThe `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\n\"\"\"\n\n\nclass Color(BaseModel):\n    __root__: Literal['BLUE', 'GREEN', 'RED']\n\n\nclass EmployeeShiftStatus(BaseModel):\n    \"\"\"\n    Employee shift status\n    \"\"\"\n\n    __root__: Literal['NOT_ON_SHIFT', 'ON_SHIFT']\n\n\nclass EnumWithOneField(BaseModel):\n    __root__: Literal['FIELD']\n</code></pre> <pre><code># generated by datamodel-codegen:\n#   filename:  enums.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\n\nfrom typing_extensions import TypeAlias\n\nBoolean: TypeAlias = bool\n\"\"\"\nThe `Boolean` scalar type represents `true` or `false`.\n\"\"\"\n\n\nString: TypeAlias = str\n\"\"\"\nThe `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\n\"\"\"\n\n\nclass Color(Enum):\n    BLUE = 'BLUE'\n    GREEN = 'GREEN'\n    RED = 'RED'\n\n\nclass EmployeeShiftStatus(Enum):\n    \"\"\"\n    Employee shift status\n    \"\"\"\n\n    NOT_ON_SHIFT = 'NOT_ON_SHIFT'\n    ON_SHIFT = 'ON_SHIFT'\n\n\nclass EnumWithOneField(Enum):\n    FIELD = 'FIELD'\n</code></pre>","path":["CLI Reference","üîß Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#no-use-specialized-enum","level":2,"title":"<code>--no-use-specialized-enum</code>","text":"<p>Disable specialized Enum classes for Python 3.11+ code generation.</p> <p>The <code>--no-use-specialized-enum</code> flag prevents the generator from using specialized Enum classes (StrEnum, IntEnum) when generating code for Python 3.11+, falling back to standard Enum classes instead.</p> <p>Related: <code>--no-use-specialized-enum</code>, <code>--target-python-version</code></p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --target-python-version 3.11 --no-use-specialized-enum # (1)!\n</code></pre> <ol> <li> <code>--no-use-specialized-enum</code> - the option documented here</li> </ol> Input Schema <pre><code>\"Employee shift status\"\nenum EmployeeShiftStatus {\n  \"not on shift\"\n  NOT_ON_SHIFT\n  \"on shift\"\n  ON_SHIFT\n}\n\nenum Color {\n  RED\n  GREEN\n  BLUE\n}\n\nenum EnumWithOneField {\n    FIELD\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  enums.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import TypeAlias\n\nBoolean: TypeAlias = bool\n\"\"\"\nThe `Boolean` scalar type represents `true` or `false`.\n\"\"\"\n\n\nString: TypeAlias = str\n\"\"\"\nThe `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\n\"\"\"\n\n\nclass Color(Enum):\n    BLUE = 'BLUE'\n    GREEN = 'GREEN'\n    RED = 'RED'\n\n\nclass EmployeeShiftStatus(Enum):\n    \"\"\"\n    Employee shift status\n    \"\"\"\n\n    NOT_ON_SHIFT = 'NOT_ON_SHIFT'\n    ON_SHIFT = 'ON_SHIFT'\n\n\nclass EnumWithOneField(Enum):\n    FIELD = 'FIELD'\n</code></pre>","path":["CLI Reference","üîß Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#output-datetime-class","level":2,"title":"<code>--output-datetime-class</code>","text":"<p>Specify datetime class type for date-time schema fields.</p> <p>The <code>--output-datetime-class</code> flag controls which datetime type to use for fields with date-time format. Options include 'AwareDatetime' for timezone-aware datetimes or 'datetime' for standard Python datetime objects.</p> <p>See also: Type Mappings and Custom Types</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --output-datetime-class AwareDatetime # (1)!\n</code></pre> <ol> <li> <code>--output-datetime-class</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ncomponents:\n  schemas:\n    InventoryItem:\n      required:\n#      - id\n#      - name\n      - releaseDate\n      type: object\n      properties:\n#        id:\n#          type: string\n#          format: uuid\n#          example: d290f1ee-6c54-4b01-90e6-d701748f0851\n#        name:\n#          type: string\n#          example: Widget Adapter\n        releaseDate:\n          type: string\n          format: date-time\n          example: 2016-08-29T09:12:33.001Z\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  datetime.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom pydantic import AwareDatetime, BaseModel, Field\n\n\nclass InventoryItem(BaseModel):\n    releaseDate: AwareDatetime = Field(..., examples=['2016-08-29T09:12:33.001Z'])\n</code></pre>","path":["CLI Reference","üîß Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#strict-types","level":2,"title":"<code>--strict-types</code>","text":"<p>Enable strict type validation for specified Python types.</p> <p>The --strict-types option enforces stricter type checking by preventing implicit type coercion for the specified types (str, bytes, int, float, bool). This generates StrictStr, StrictBytes, StrictInt, StrictFloat, and StrictBool types in Pydantic models, ensuring values match exactly without automatic conversion.</p> <p>See also: Type Mappings and Custom Types</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --strict-types str bytes int float bool # (1)!\n</code></pre> <ol> <li> <code>--strict-types</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"User\",\n  \"type\": \"object\",\n  \"properties\": {\n        \"name\": {\n          \"type\": \"string\",\n          \"example\": \"ken\"\n        },\n        \"age\": {\n          \"type\": \"integer\"\n        },\n        \"salary\": {\n          \"type\": \"integer\",\n          \"minimum\": 0\n        },\n        \"debt\" : {\n          \"type\": \"integer\",\n          \"maximum\": 0\n        },\n        \"loan\" : {\n          \"type\": \"number\",\n          \"maximum\": 0\n        },\n        \"tel\": {\n          \"type\": \"string\",\n          \"pattern\": \"^(\\\\([0-9]{3}\\\\))?[0-9]{3}-[0-9]{4}$\"\n        },\n        \"height\": {\n          \"type\": \"number\",\n          \"minimum\": 0\n        },\n        \"weight\": {\n          \"type\": \"number\",\n          \"minimum\": 0\n        },\n        \"score\": {\n          \"type\": \"number\",\n          \"minimum\": 1e-08\n        },\n        \"active\": {\n          \"type\": \"boolean\"\n        },\n        \"photo\": {\n          \"type\": \"string\",\n          \"format\": \"binary\",\n          \"minLength\": 100\n        }\n      }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  strict_types.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import (\n    BaseModel,\n    Field,\n    StrictBool,\n    StrictBytes,\n    StrictInt,\n    StrictStr,\n    confloat,\n    conint,\n    constr,\n)\n\n\nclass User(BaseModel):\n    name: Optional[StrictStr] = Field(None, example='ken')\n    age: Optional[StrictInt] = None\n    salary: Optional[conint(ge=0, strict=True)] = None\n    debt: Optional[conint(le=0, strict=True)] = None\n    loan: Optional[confloat(le=0.0, strict=True)] = None\n    tel: Optional[\n        constr(regex=r'^(\\([0-9]{3}\\))?[0-9]{3}-[0-9]{4}$', strict=True)\n    ] = None\n    height: Optional[confloat(ge=0.0, strict=True)] = None\n    weight: Optional[confloat(ge=0.0, strict=True)] = None\n    score: Optional[confloat(ge=1e-08, strict=True)] = None\n    active: Optional[StrictBool] = None\n    photo: Optional[StrictBytes] = None\n</code></pre>","path":["CLI Reference","üîß Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#type-mappings","level":2,"title":"<code>--type-mappings</code>","text":"<p>Override default type mappings for schema formats.</p> <p>The <code>--type-mappings</code> flag configures the code generation behavior.</p> <p>See also: Type Mappings and Custom Types</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --output-model-type pydantic_v2.BaseModel --type-mappings binary=string # (1)!\n</code></pre> <ol> <li> <code>--type-mappings</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"BlobModel\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"content\": {\n      \"type\": \"string\",\n      \"format\": \"binary\",\n      \"description\": \"Binary content that should be mapped to string\"\n    },\n    \"data\": {\n      \"type\": \"string\",\n      \"format\": \"byte\",\n      \"description\": \"Base64 encoded data\"\n    },\n    \"name\": {\n      \"type\": \"string\",\n      \"description\": \"Regular string field\"\n    }\n  },\n  \"required\": [\"content\", \"data\", \"name\"]\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  type_mappings.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom pydantic import Base64Str, BaseModel, Field\n\n\nclass BlobModel(BaseModel):\n    content: str = Field(\n        ..., description='Binary content that should be mapped to string'\n    )\n    data: Base64Str = Field(..., description='Base64 encoded data')\n    name: str = Field(..., description='Regular string field')\n</code></pre>","path":["CLI Reference","üîß Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#use-annotated","level":2,"title":"<code>--use-annotated</code>","text":"<p>Test GraphQL annotated types with standard collections and union operator.</p> <p>Related: <code>--use-standard-collections</code></p> <p>See also: Python Version Compatibility</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --output-model-type pydantic_v2.BaseModel --use-annotated --use-standard-collections --use-union-operator # (1)!\n</code></pre> <ol> <li> <code>--use-annotated</code> - the option documented here</li> </ol> Input Schema <pre><code>type A {\n    field: String!\n    optionalField: String\n    listField: [String!]!\n    listOptionalField: [String]!\n    optionalListField: [String!]\n    optionalListOptionalField: [String]\n    listListField:[[String!]!]!\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  annotated.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Annotated, Literal\n\nfrom pydantic import BaseModel, Field\nfrom typing_extensions import TypeAliasType\n\nBoolean = TypeAliasType(\"Boolean\", bool)\n\"\"\"\nThe `Boolean` scalar type represents `true` or `false`.\n\"\"\"\n\n\nString = TypeAliasType(\"String\", str)\n\"\"\"\nThe `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\n\"\"\"\n\n\nclass A(BaseModel):\n    field: String\n    listField: list[String]\n    listListField: list[list[String]]\n    listOptionalField: list[String | None]\n    optionalField: String | None = None\n    optionalListField: list[String] | None = None\n    optionalListOptionalField: list[String | None] | None = None\n    typename__: Annotated[Literal['A'] | None, Field(alias='__typename')] = 'A'\n</code></pre>","path":["CLI Reference","üîß Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#use-decimal-for-multiple-of","level":2,"title":"<code>--use-decimal-for-multiple-of</code>","text":"<p>Generate Decimal types for fields with multipleOf constraint.</p> <p>The <code>--use-decimal-for-multiple-of</code> flag generates <code>condecimal</code> or <code>Decimal</code> types for numeric fields that have a <code>multipleOf</code> constraint. This ensures precise decimal arithmetic when validating values against the constraint.</p> <p>See also: Type Mappings and Custom Types</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-decimal-for-multiple-of # (1)!\n</code></pre> <ol> <li> <code>--use-decimal-for-multiple-of</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"type\": \"object\",\n  \"properties\": {\n    \"price\": {\n      \"type\": \"number\",\n      \"multipleOf\": 0.01,\n      \"minimum\": 0,\n      \"maximum\": 99999.99\n    },\n    \"quantity\": {\n      \"type\": \"number\",\n      \"multipleOf\": 0.1\n    },\n    \"rate\": {\n      \"type\": \"number\",\n      \"multipleOf\": 0.001,\n      \"exclusiveMinimum\": 0,\n      \"exclusiveMaximum\": 1\n    },\n    \"simple_float\": {\n      \"type\": \"number\",\n      \"minimum\": 0,\n      \"maximum\": 100\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  use_decimal_for_multiple_of.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, condecimal, confloat\n\n\nclass Model(BaseModel):\n    price: Optional[condecimal(ge=0, le=99999.99, multiple_of=0.01)] = None\n    quantity: Optional[condecimal(multiple_of=0.1)] = None\n    rate: Optional[condecimal(multiple_of=0.001, lt=1.0, gt=0.0)] = None\n    simple_float: Optional[confloat(ge=0.0, le=100.0)] = None\n</code></pre>","path":["CLI Reference","üîß Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#use-generic-container-types","level":2,"title":"<code>--use-generic-container-types</code>","text":"<p>Use typing.Dict/List instead of dict/list for container types.</p> <p>The <code>--use-generic-container-types</code> flag generates typing module generic containers (Dict, List, etc.) instead of built-in types. This is useful for Python 3.8 compatibility or when explicit typing imports are preferred.</p> <p>Related: <code>--use-standard-collections</code></p> <p>See also: Python Version Compatibility</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-generic-container-types # (1)!\n</code></pre> <ol> <li> <code>--use-generic-container-types</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"$id\": \"test.json\",\n  \"description\": \"test\",\n  \"type\": \"object\",\n  \"required\": [\n    \"test_id\",\n    \"test_ip\",\n    \"result\",\n    \"nested_object_result\",\n    \"nested_enum_result\"\n  ],\n  \"properties\": {\n    \"test_id\": {\n      \"type\": \"string\",\n      \"description\": \"test ID\"\n    },\n    \"test_ip\": {\n      \"type\": \"string\",\n      \"description\": \"test IP\"\n    },\n    \"result\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"type\": \"integer\"\n      }\n    },\n    \"nested_object_result\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"status\":{\n            \"type\": \"integer\"\n          }\n        },\n        \"required\": [\"status\"]\n      }\n    },\n    \"nested_enum_result\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"enum\": [\"red\", \"green\"]\n      }\n    },\n    \"all_of_result\" :{\n      \"type\" : \"object\",\n      \"additionalProperties\" :\n      {\n        \"allOf\" : [\n          { \"$ref\" : \"#/definitions/User\" },\n          { \"type\" : \"object\",\n            \"properties\": {\n              \"description\": {\"type\" : \"string\" }\n            }\n          }\n        ]\n      }\n    },\n    \"one_of_result\" :{\n      \"type\" : \"object\",\n      \"additionalProperties\" :\n      {\n        \"oneOf\" : [\n          { \"$ref\" : \"#/definitions/User\" },\n          { \"type\" : \"object\",\n            \"properties\": {\n              \"description\": {\"type\" : \"string\" }\n            }\n          }\n        ]\n      }\n    },\n    \"any_of_result\" :{\n      \"type\" : \"object\",\n      \"additionalProperties\" :\n      {\n        \"anyOf\" : [\n          { \"$ref\" : \"#/definitions/User\" },\n          { \"type\" : \"object\",\n            \"properties\": {\n              \"description\": {\"type\" : \"string\" }\n            }\n          }\n        ]\n      }\n    },\n    \"all_of_with_unknown_object\" :{\n      \"type\" : \"object\",\n      \"additionalProperties\" :\n      {\n        \"allOf\" : [\n          { \"$ref\" : \"#/definitions/User\" },\n          { \"description\": \"TODO\" }\n        ]\n      }\n    },\n    \"objectRef\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"$ref\": \"#/definitions/User\"\n      }\n    },\n    \"deepNestedObjectRef\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"type\": \"object\",\n        \"additionalProperties\": {\n          \"type\": \"object\",\n          \"additionalProperties\": {\n             \"$ref\": \"#/definitions/User\"\n          }\n        }\n      }\n    }\n  },\n  \"definitions\": {\n    \"User\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"type\": \"string\"\n        }\n      }\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  root_model_with_additional_properties.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Mapping, Optional, Union\n\nfrom pydantic import BaseModel, Field\n\n\nclass NestedObjectResult(BaseModel):\n    status: int\n\n\nclass NestedEnumResult(Enum):\n    red = 'red'\n    green = 'green'\n\n\nclass OneOfResult(BaseModel):\n    description: Optional[str] = None\n\n\nclass AnyOfResult(BaseModel):\n    description: Optional[str] = None\n\n\nclass User(BaseModel):\n    name: Optional[str] = None\n\n\nclass AllOfResult(User):\n    description: Optional[str] = None\n\n\nclass Model(BaseModel):\n    test_id: str = Field(..., description='test ID')\n    test_ip: str = Field(..., description='test IP')\n    result: Mapping[str, int]\n    nested_object_result: Mapping[str, NestedObjectResult]\n    nested_enum_result: Mapping[str, NestedEnumResult]\n    all_of_result: Optional[Mapping[str, AllOfResult]] = None\n    one_of_result: Optional[Mapping[str, Union[User, OneOfResult]]] = None\n    any_of_result: Optional[Mapping[str, Union[User, AnyOfResult]]] = None\n    all_of_with_unknown_object: Optional[Mapping[str, User]] = None\n    objectRef: Optional[Mapping[str, User]] = None\n    deepNestedObjectRef: Optional[Mapping[str, Mapping[str, Mapping[str, User]]]] = None\n</code></pre>","path":["CLI Reference","üîß Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#use-non-positive-negative-number-constrained-types","level":2,"title":"<code>--use-non-positive-negative-number-constrained-types</code>","text":"<p>Use NonPositive/NonNegative types for number constraints.</p> <p>The <code>--use-non-positive-negative-number-constrained-types</code> flag generates Pydantic's NonPositiveInt, NonNegativeInt, NonPositiveFloat, and NonNegativeFloat types for fields with minimum: 0 or maximum: 0 constraints, instead of using conint/confloat with ge/le parameters.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-non-positive-negative-number-constrained-types # (1)!\n</code></pre> <ol> <li> <code>--use-non-positive-negative-number-constrained-types</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"NumberConstraints\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"non_negative_count\": {\n      \"type\": \"integer\",\n      \"minimum\": 0,\n      \"description\": \"A count that cannot be negative\"\n    },\n    \"non_positive_balance\": {\n      \"type\": \"integer\",\n      \"maximum\": 0,\n      \"description\": \"A balance that cannot be positive\"\n    },\n    \"non_negative_amount\": {\n      \"type\": \"number\",\n      \"minimum\": 0,\n      \"description\": \"An amount that cannot be negative\"\n    },\n    \"non_positive_score\": {\n      \"type\": \"number\",\n      \"maximum\": 0,\n      \"description\": \"A score that cannot be positive\"\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  use_non_positive_negative.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import (\n    BaseModel,\n    Field,\n    NonNegativeFloat,\n    NonNegativeInt,\n    NonPositiveFloat,\n    NonPositiveInt,\n)\n\n\nclass NumberConstraints(BaseModel):\n    non_negative_count: Optional[NonNegativeInt] = Field(\n        None, description='A count that cannot be negative'\n    )\n    non_positive_balance: Optional[NonPositiveInt] = Field(\n        None, description='A balance that cannot be positive'\n    )\n    non_negative_amount: Optional[NonNegativeFloat] = Field(\n        None, description='An amount that cannot be negative'\n    )\n    non_positive_score: Optional[NonPositiveFloat] = Field(\n        None, description='A score that cannot be positive'\n    )\n</code></pre>","path":["CLI Reference","üîß Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#use-pendulum","level":2,"title":"<code>--use-pendulum</code>","text":"<p>Use pendulum types for date/time fields instead of datetime module.</p> <p>The <code>--use-pendulum</code> flag generates pendulum library types (DateTime, Date, Time, Duration) instead of standard datetime types. This is useful when working with the pendulum library for enhanced timezone and date handling.</p> <p>See also: Type Mappings and Custom Types</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-pendulum # (1)!\n</code></pre> <ol> <li> <code>--use-pendulum</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Event\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"created_at\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"event_date\": {\n      \"type\": \"string\",\n      \"format\": \"date\"\n    },\n    \"duration\": {\n      \"type\": \"string\",\n      \"format\": \"duration\"\n    }\n  },\n  \"required\": [\"name\", \"created_at\"]\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  use_pendulum.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pendulum import Date, DateTime, Duration\nfrom pydantic import BaseModel\n\n\nclass Event(BaseModel):\n    name: str\n    created_at: DateTime\n    event_date: Optional[Date] = None\n    duration: Optional[Duration] = None\n</code></pre>","path":["CLI Reference","üîß Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#use-standard-collections","level":2,"title":"<code>--use-standard-collections</code>","text":"<p>Use built-in dict/list instead of typing.Dict/List.</p> <p>The <code>--use-standard-collections</code> flag generates built-in container types (dict, list) instead of typing module equivalents. This produces cleaner code for Python 3.9+ where built-in types support subscripting.</p> <p>Related: <code>--use-generic-container-types</code></p> <p>See also: Python Version Compatibility</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-standard-collections # (1)!\n</code></pre> <ol> <li> <code>--use-standard-collections</code> - the option documented here</li> </ol> Input Schema <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"$id\": \"test.json\",\n  \"description\": \"test\",\n  \"type\": \"object\",\n  \"required\": [\n    \"test_id\",\n    \"test_ip\",\n    \"result\",\n    \"nested_object_result\",\n    \"nested_enum_result\"\n  ],\n  \"properties\": {\n    \"test_id\": {\n      \"type\": \"string\",\n      \"description\": \"test ID\"\n    },\n    \"test_ip\": {\n      \"type\": \"string\",\n      \"description\": \"test IP\"\n    },\n    \"result\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"type\": \"integer\"\n      }\n    },\n    \"nested_object_result\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"status\":{\n            \"type\": \"integer\"\n          }\n        },\n        \"required\": [\"status\"]\n      }\n    },\n    \"nested_enum_result\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"enum\": [\"red\", \"green\"]\n      }\n    },\n    \"all_of_result\" :{\n      \"type\" : \"object\",\n      \"additionalProperties\" :\n      {\n        \"allOf\" : [\n          { \"$ref\" : \"#/definitions/User\" },\n          { \"type\" : \"object\",\n            \"properties\": {\n              \"description\": {\"type\" : \"string\" }\n            }\n          }\n        ]\n      }\n    },\n    \"one_of_result\" :{\n      \"type\" : \"object\",\n      \"additionalProperties\" :\n      {\n        \"oneOf\" : [\n          { \"$ref\" : \"#/definitions/User\" },\n          { \"type\" : \"object\",\n            \"properties\": {\n              \"description\": {\"type\" : \"string\" }\n            }\n          }\n        ]\n      }\n    },\n    \"any_of_result\" :{\n      \"type\" : \"object\",\n      \"additionalProperties\" :\n      {\n        \"anyOf\" : [\n          { \"$ref\" : \"#/definitions/User\" },\n          { \"type\" : \"object\",\n            \"properties\": {\n              \"description\": {\"type\" : \"string\" }\n            }\n          }\n        ]\n      }\n    },\n    \"all_of_with_unknown_object\" :{\n      \"type\" : \"object\",\n      \"additionalProperties\" :\n      {\n        \"allOf\" : [\n          { \"$ref\" : \"#/definitions/User\" },\n          { \"description\": \"TODO\" }\n        ]\n      }\n    },\n    \"objectRef\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"$ref\": \"#/definitions/User\"\n      }\n    },\n    \"deepNestedObjectRef\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"type\": \"object\",\n        \"additionalProperties\": {\n          \"type\": \"object\",\n          \"additionalProperties\": {\n             \"$ref\": \"#/definitions/User\"\n          }\n        }\n      }\n    }\n  },\n  \"definitions\": {\n    \"User\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"type\": \"string\"\n        }\n      }\n    }\n  }\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  root_model_with_additional_properties.json\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Optional, Union\n\nfrom pydantic import BaseModel, Field\n\n\nclass NestedObjectResult(BaseModel):\n    status: int\n\n\nclass NestedEnumResult(Enum):\n    red = 'red'\n    green = 'green'\n\n\nclass OneOfResult(BaseModel):\n    description: Optional[str] = None\n\n\nclass AnyOfResult(BaseModel):\n    description: Optional[str] = None\n\n\nclass User(BaseModel):\n    name: Optional[str] = None\n\n\nclass AllOfResult(User):\n    description: Optional[str] = None\n\n\nclass Model(BaseModel):\n    test_id: str = Field(..., description='test ID')\n    test_ip: str = Field(..., description='test IP')\n    result: dict[str, int]\n    nested_object_result: dict[str, NestedObjectResult]\n    nested_enum_result: dict[str, NestedEnumResult]\n    all_of_result: Optional[dict[str, AllOfResult]] = None\n    one_of_result: Optional[dict[str, Union[User, OneOfResult]]] = None\n    any_of_result: Optional[dict[str, Union[User, AnyOfResult]]] = None\n    all_of_with_unknown_object: Optional[dict[str, User]] = None\n    objectRef: Optional[dict[str, User]] = None\n    deepNestedObjectRef: Optional[dict[str, dict[str, dict[str, User]]]] = None\n</code></pre>","path":["CLI Reference","üîß Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#use-type-alias","level":2,"title":"<code>--use-type-alias</code>","text":"<p>Use TypeAlias instead of root models for type definitions (experimental).</p> <p>The <code>--use-type-alias</code> flag generates TypeAlias declarations instead of root model classes for certain type definitions. For Python 3.9-3.11, it generates TypeAliasType, and for Python 3.12+, it uses the 'type' statement syntax. This feature is experimental.</p> <p>Related: <code>--target-python-version</code></p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-type-alias # (1)!\n</code></pre> <ol> <li> <code>--use-type-alias</code> - the option documented here</li> </ol> Input Schema <pre><code>scalar SimpleString\n\ntype Person {\n  name: String!\n  age: Int!\n}\n\ntype Pet {\n  name: String!\n  type: String!\n}\n\nunion UnionType = Person | Pet\n\ntype ModelWithTypeAliasField {\n  simple_field: SimpleString\n  union_field: UnionType\n  string_field: String\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  type_alias.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Literal, Optional, Union\n\nfrom pydantic import BaseModel, Field\nfrom typing_extensions import TypeAlias\n\nBoolean: TypeAlias = bool\n\"\"\"\nThe `Boolean` scalar type represents `true` or `false`.\n\"\"\"\n\n\nInt: TypeAlias = int\n\"\"\"\nThe `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\n\"\"\"\n\n\nSimpleString: TypeAlias = str\n\n\nString: TypeAlias = str\n\"\"\"\nThe `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\n\"\"\"\n\n\nclass Person(BaseModel):\n    age: Int\n    name: String\n    typename__: Optional[Literal['Person']] = Field('Person', alias='__typename')\n\n\nclass Pet(BaseModel):\n    name: String\n    type: String\n    typename__: Optional[Literal['Pet']] = Field('Pet', alias='__typename')\n\n\nUnionType: TypeAlias = Union[\n    'Person',\n    'Pet',\n]\n\n\nclass ModelWithTypeAliasField(BaseModel):\n    simple_field: Optional[SimpleString] = None\n    string_field: Optional[String] = None\n    union_field: Optional[UnionType] = None\n    typename__: Optional[Literal['ModelWithTypeAliasField']] = Field(\n        'ModelWithTypeAliasField', alias='__typename'\n    )\n</code></pre>","path":["CLI Reference","üîß Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#use-union-operator","level":2,"title":"<code>--use-union-operator</code>","text":"<p>Test GraphQL annotated types with standard collections and union operator.</p> <p>Related: <code>--use-standard-collections</code></p> <p>See also: Python Version Compatibility</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --output-model-type pydantic_v2.BaseModel --use-annotated --use-standard-collections --use-union-operator # (1)!\n</code></pre> <ol> <li> <code>--use-union-operator</code> - the option documented here</li> </ol> Input Schema <pre><code>type A {\n    field: String!\n    optionalField: String\n    listField: [String!]!\n    listOptionalField: [String]!\n    optionalListField: [String!]\n    optionalListOptionalField: [String]\n    listListField:[[String!]!]!\n}\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  annotated.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Annotated, Literal\n\nfrom pydantic import BaseModel, Field\nfrom typing_extensions import TypeAliasType\n\nBoolean = TypeAliasType(\"Boolean\", bool)\n\"\"\"\nThe `Boolean` scalar type represents `true` or `false`.\n\"\"\"\n\n\nString = TypeAliasType(\"String\", str)\n\"\"\"\nThe `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\n\"\"\"\n\n\nclass A(BaseModel):\n    field: String\n    listField: list[String]\n    listListField: list[list[String]]\n    listOptionalField: list[String | None]\n    optionalField: String | None = None\n    optionalListField: list[String] | None = None\n    optionalListOptionalField: list[String | None] | None = None\n    typename__: Annotated[Literal['A'] | None, Field(alias='__typename')] = 'A'\n</code></pre>","path":["CLI Reference","üîß Typing Customization"],"tags":[]},{"location":"cli-reference/typing-customization/#use-unique-items-as-set","level":2,"title":"<code>--use-unique-items-as-set</code>","text":"<p>Generate set types for arrays with uniqueItems constraint.</p> <p>The <code>--use-unique-items-as-set</code> flag generates Python set types instead of list types for JSON Schema arrays that have the uniqueItems constraint set to true, enforcing uniqueness at the type level.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --use-unique-items-as-set --field-constraints # (1)!\n</code></pre> <ol> <li> <code>--use-unique-items-as-set</code> - the option documented here</li> </ol> Input Schema <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n            minimum: 0\n            maximum: 100\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n          minimum: 0\n          maximum: 9223372036854775807\n        name:\n          type: string\n          maxLength: 256\n        tag:\n          type: string\n          maxLength: 64\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n      maxItems: 10\n      minItems: 1\n      uniqueItems: true\n    UID:\n      type: integer\n      minimum: 0\n    Users:\n      type: array\n      items:\n        required:\n          - id\n          - name\n          - uid\n        properties:\n          id:\n            type: integer\n            format: int64\n            minimum: 0\n          name:\n            type: string\n            maxLength: 256\n          tag:\n            type: string\n            maxLength: 64\n          uid:\n            $ref: '#/components/schemas/UID'\n          phones:\n            type: array\n            items:\n              type: string\n              minLength: 3\n            maxItems: 10\n          fax:\n            type: array\n            items:\n              type: string\n              minLength: 3\n          height:\n            type:\n              - integer\n              - number\n            minimum: 1\n            maximum: 300\n          weight:\n            type:\n              - number\n              - integer\n            minimum: 1.0\n            maximum: 1000.0\n          age:\n            type: integer\n            minimum: 0.0\n            maximum: 200.0\n            exclusiveMinimum: true\n          rating:\n            type: number\n            minimum: 0\n            exclusiveMinimum: True\n            maximum: 5\n\n    Id:\n      type: string\n    Rules:\n      type: array\n      items:\n        type: string\n    Error:\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            minLength: 1\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n    Event:\n      type: object\n      properties:\n        name:\n          type: string\n    Result:\n        type: object\n        properties:\n          event:\n            $ref: '#/components/schemas/Event'\n</code></pre> Output <pre><code># generated by datamodel-codegen:\n#   filename:  api_constrained.yaml\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional, Set, Union\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int = Field(..., ge=0, le=9223372036854775807)\n    name: str = Field(..., max_length=256)\n    tag: Optional[str] = Field(None, max_length=64)\n\n\nclass Pets(BaseModel):\n    __root__: Set[Pet] = Field(..., max_items=10, min_items=1, unique_items=True)\n\n\nclass UID(BaseModel):\n    __root__: int = Field(..., ge=0)\n\n\nclass Phone(BaseModel):\n    __root__: str = Field(..., min_length=3)\n\n\nclass FaxItem(BaseModel):\n    __root__: str = Field(..., min_length=3)\n\n\nclass User(BaseModel):\n    id: int = Field(..., ge=0)\n    name: str = Field(..., max_length=256)\n    tag: Optional[str] = Field(None, max_length=64)\n    uid: UID\n    phones: Optional[List[Phone]] = Field(None, max_items=10)\n    fax: Optional[List[FaxItem]] = None\n    height: Optional[Union[int, float]] = Field(None, ge=1.0, le=300.0)\n    weight: Optional[Union[float, int]] = Field(None, ge=1.0, le=1000.0)\n    age: Optional[int] = Field(None, gt=0, le=200)\n    rating: Optional[float] = Field(None, gt=0.0, le=5.0)\n\n\nclass Users(BaseModel):\n    __root__: List[User]\n\n\nclass Id(BaseModel):\n    __root__: str\n\n\nclass Rules(BaseModel):\n    __root__: List[str]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n\n\nclass Event(BaseModel):\n    name: Optional[str] = None\n\n\nclass Result(BaseModel):\n    event: Optional[Event] = None\n</code></pre>","path":["CLI Reference","üîß Typing Customization"],"tags":[]},{"location":"cli-reference/utility-options/","level":1,"title":"üìù Utility Options","text":"","path":["CLI Reference","üìù Utility Options"],"tags":[]},{"location":"cli-reference/utility-options/#options","level":2,"title":"üìã Options","text":"Option Description <code>--debug</code> Show debug messages during code generation <code>--help</code> Show help message and exit <code>--no-color</code> Disable colorized output <code>--profile</code> Use a named profile from pyproject.toml <code>--version</code> Show program version and exit","path":["CLI Reference","üìù Utility Options"],"tags":[]},{"location":"cli-reference/utility-options/#debug","level":2,"title":"<code>--debug</code>","text":"<p>Show debug messages during code generation.</p> <p>Enables verbose debug output to help troubleshoot issues with schema parsing or code generation. Requires the <code>debug</code> extra to be installed.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --debug # (1)!\n</code></pre> <ol> <li> <code>--debug</code> - the option documented here</li> </ol> <p>Requires extra dependency</p> <p>The debug feature requires the <code>debug</code> extra:</p> <pre><code>pip install 'datamodel-code-generator[debug]'\n</code></pre>","path":["CLI Reference","üìù Utility Options"],"tags":[]},{"location":"cli-reference/utility-options/#help","level":2,"title":"<code>--help</code>","text":"<p>Show help message and exit.</p> <p>Displays all available command-line options with their descriptions and default values.</p> <p>Aliases: <code>-h</code></p> <p>Usage</p> <pre><code>datamodel-codegen --help # (1)!\n</code></pre> <ol> <li> <code>--help</code> - the option documented here</li> </ol> Output <pre><code>usage: datamodel-codegen [-h] [--input INPUT] [--url URL] ...\n\nGenerate Python data models from schema files.\n\noptions:\n  -h, --help            show this help message and exit\n  --input INPUT         Input file path (default: stdin)\n  ...\n</code></pre>","path":["CLI Reference","üìù Utility Options"],"tags":[]},{"location":"cli-reference/utility-options/#no-color","level":2,"title":"<code>--no-color</code>","text":"<p>Disable colorized output.</p> <p>By default, datamodel-codegen uses colored output for better readability. Use this option to disable colors, which is useful for CI/CD pipelines or when redirecting output to files.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --no-color # (1)!\n</code></pre> <ol> <li> <code>--no-color</code> - the option documented here</li> </ol> <p>Environment variable</p> <p>You can also disable colors by setting the <code>NO_COLOR</code> environment variable:</p> <pre><code>NO_COLOR=1 datamodel-codegen --input schema.json\n</code></pre>","path":["CLI Reference","üìù Utility Options"],"tags":[]},{"location":"cli-reference/utility-options/#profile","level":2,"title":"<code>--profile</code>","text":"<p>Use a named profile from pyproject.toml configuration.</p> <p>Profiles allow you to define multiple named configurations in your pyproject.toml file. Each profile can override the default settings with its own set of options.</p> <p>Related: pyproject.toml Configuration</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --profile strict # (1)!\n</code></pre> <ol> <li> <code>--profile</code> - the option documented here</li> </ol> Configuration (pyproject.toml) <pre><code>[tool.datamodel-codegen]\n# Default configuration\noutput-model-type = \"pydantic_v2.BaseModel\"\n\n[tool.datamodel-codegen.profiles.strict]\n# Strict profile with additional options\nstrict-types = [\"str\", \"int\", \"float\", \"bool\"]\nstrict-nullable = true\n\n[tool.datamodel-codegen.profiles.legacy]\n# Legacy profile for Pydantic v1\noutput-model-type = \"pydantic.BaseModel\"\n</code></pre> <p>Use profiles:</p> <pre><code># Use the strict profile\ndatamodel-codegen --input schema.json --profile strict\n\n# Use the legacy profile\ndatamodel-codegen --input schema.json --profile legacy\n</code></pre>","path":["CLI Reference","üìù Utility Options"],"tags":[]},{"location":"cli-reference/utility-options/#version","level":2,"title":"<code>--version</code>","text":"<p>Show program version and exit.</p> <p>Displays the installed version of datamodel-code-generator.</p> <p>Usage</p> <pre><code>datamodel-codegen --version # (1)!\n</code></pre> <ol> <li> <code>--version</code> - the option documented here</li> </ol> Output <pre><code>datamodel-codegen version: 0.x.x\n</code></pre>","path":["CLI Reference","üìù Utility Options"],"tags":[]},{"location":"cli-reference/manual/debug/","level":1,"title":"Debug","text":"","path":["Debug"],"tags":[]},{"location":"cli-reference/manual/debug/#debug","level":2,"title":"<code>--debug</code>","text":"<p>Show debug messages during code generation.</p> <p>Enables verbose debug output to help troubleshoot issues with schema parsing or code generation. Requires the <code>debug</code> extra to be installed.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --debug # (1)!\n</code></pre> <ol> <li> <code>--debug</code> - the option documented here</li> </ol> <p>Requires extra dependency</p> <p>The debug feature requires the <code>debug</code> extra:</p> <pre><code>pip install 'datamodel-code-generator[debug]'\n</code></pre>","path":["Debug"],"tags":[]},{"location":"cli-reference/manual/help/","level":1,"title":"Help","text":"","path":["Help"],"tags":[]},{"location":"cli-reference/manual/help/#help","level":2,"title":"<code>--help</code>","text":"<p>Show help message and exit.</p> <p>Displays all available command-line options with their descriptions and default values.</p> <p>Aliases: <code>-h</code></p> <p>Usage</p> <pre><code>datamodel-codegen --help # (1)!\n</code></pre> <ol> <li> <code>--help</code> - the option documented here</li> </ol> Output <pre><code>usage: datamodel-codegen [-h] [--input INPUT] [--url URL] ...\n\nGenerate Python data models from schema files.\n\noptions:\n  -h, --help            show this help message and exit\n  --input INPUT         Input file path (default: stdin)\n  ...\n</code></pre>","path":["Help"],"tags":[]},{"location":"cli-reference/manual/no-color/","level":1,"title":"No color","text":"","path":["No color"],"tags":[]},{"location":"cli-reference/manual/no-color/#no-color","level":2,"title":"<code>--no-color</code>","text":"<p>Disable colorized output.</p> <p>By default, datamodel-codegen uses colored output for better readability. Use this option to disable colors, which is useful for CI/CD pipelines or when redirecting output to files.</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --no-color # (1)!\n</code></pre> <ol> <li> <code>--no-color</code> - the option documented here</li> </ol> <p>Environment variable</p> <p>You can also disable colors by setting the <code>NO_COLOR</code> environment variable:</p> <pre><code>NO_COLOR=1 datamodel-codegen --input schema.json\n</code></pre>","path":["No color"],"tags":[]},{"location":"cli-reference/manual/profile/","level":1,"title":"Profile","text":"","path":["Profile"],"tags":[]},{"location":"cli-reference/manual/profile/#profile","level":2,"title":"<code>--profile</code>","text":"<p>Use a named profile from pyproject.toml configuration.</p> <p>Profiles allow you to define multiple named configurations in your pyproject.toml file. Each profile can override the default settings with its own set of options.</p> <p>Related: pyproject.toml Configuration</p> <p>Usage</p> <pre><code>datamodel-codegen --input schema.json --profile strict # (1)!\n</code></pre> <ol> <li> <code>--profile</code> - the option documented here</li> </ol> Configuration (pyproject.toml) <pre><code>[tool.datamodel-codegen]\n# Default configuration\noutput-model-type = \"pydantic_v2.BaseModel\"\n\n[tool.datamodel-codegen.profiles.strict]\n# Strict profile with additional options\nstrict-types = [\"str\", \"int\", \"float\", \"bool\"]\nstrict-nullable = true\n\n[tool.datamodel-codegen.profiles.legacy]\n# Legacy profile for Pydantic v1\noutput-model-type = \"pydantic.BaseModel\"\n</code></pre> <p>Use profiles:</p> <pre><code># Use the strict profile\ndatamodel-codegen --input schema.json --profile strict\n\n# Use the legacy profile\ndatamodel-codegen --input schema.json --profile legacy\n</code></pre>","path":["Profile"],"tags":[]},{"location":"cli-reference/manual/version/","level":1,"title":"Version","text":"","path":["Version"],"tags":[]},{"location":"cli-reference/manual/version/#version","level":2,"title":"<code>--version</code>","text":"<p>Show program version and exit.</p> <p>Displays the installed version of datamodel-code-generator.</p> <p>Usage</p> <pre><code>datamodel-codegen --version # (1)!\n</code></pre> <ol> <li> <code>--version</code> - the option documented here</li> </ol> Output <pre><code>datamodel-codegen version: 0.x.x\n</code></pre>","path":["Version"],"tags":[]}]}