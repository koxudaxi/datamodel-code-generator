{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"datamodel-code-generator","text":"<p>This code generator creates pydantic v1 and v2 model, dataclasses.dataclass, typing.TypedDict and msgspec.Struct from an openapi file and others.</p> <p> </p>"},{"location":"#sponsors","title":"Sponsors","text":""},{"location":"#quick-installation","title":"Quick Installation","text":"<p>To install <code>datamodel-code-generator</code>: <pre><code>$ pip install datamodel-code-generator\n</code></pre></p>"},{"location":"#simple-usage","title":"Simple Usage","text":"<p>You can generate models from a local file. <pre><code>$ datamodel-codegen --input api.yaml --output model.py\n</code></pre></p> api.yaml <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Error:\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n</code></pre> model.py <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2020-06-02T05:28:24+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n</code></pre>"},{"location":"#projects-that-use-datamodel-code-generator","title":"Projects that use datamodel-code-generator","text":"<p>These OSS projects use datamodel-code-generator to generate many models.  See the following linked projects for real world examples and inspiration.</p> <ul> <li>airbytehq/airbyte<ul> <li>code-generator/Dockerfile</li> </ul> </li> <li>apache/iceberg<ul> <li>Generate Python code <code>make generate</code></li> </ul> </li> <li>argoproj-labs/hera<ul> <li><code>Makefile</code></li> </ul> </li> <li>awslabs/aws-lambda-powertools-python<ul> <li>Recommended for advanced-use-cases in the official documentation</li> </ul> </li> <li>DataDog/integrations-core<ul> <li>Config models</li> </ul> </li> <li>hashintel/hash<ul> <li><code>codegen.sh</code></li> </ul> </li> <li>IBM/compliance-trestle<ul> <li>Building the models from the OSCAL schemas.</li> </ul> </li> <li>Netflix/consoleme<ul> <li>How do I generate models from the Swagger specification?</li> </ul> </li> <li>Nike-Inc/brickflow<ul> <li>Code generate tools<code>./tools/gen-bundle.sh</code></li> </ul> </li> <li>open-metadata/OpenMetadata<ul> <li>Makefile</li> </ul> </li> <li>PostHog/posthog<ul> <li>Generate models via <code>npm run</code> </li> </ul> </li> <li>SeldonIO/MLServer<ul> <li>generate-types.sh</li> </ul> </li> </ul>"},{"location":"#supported-input-types","title":"Supported input types","text":"<ul> <li>OpenAPI 3 (YAML/JSON, OpenAPI Data Type);</li> <li>JSON Schema (JSON Schema Core/JSON Schema Validation);</li> <li>JSON/YAML/CSV Data (it will be converted to JSON Schema);</li> <li>Python dictionary (it will be converted to JSON Schema);</li> <li>GraphQL schema (GraphQL Schemas and Types);</li> </ul>"},{"location":"#supported-output-types","title":"Supported output types","text":"<ul> <li>pydantic.BaseModel;</li> <li>pydantic_v2.BaseModel;</li> <li>dataclasses.dataclass;</li> <li>typing.TypedDict;</li> <li>msgspec.Struct;</li> <li>Custom type from your jinja2 template;</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>To install <code>datamodel-code-generator</code>: <pre><code>$ pip install datamodel-code-generator\n</code></pre></p>"},{"location":"#http-extra-option","title":"<code>http</code> extra option","text":"<p>If you want to resolve <code>$ref</code> for remote files then you should specify <code>http</code> extra option. <pre><code>$ pip install 'datamodel-code-generator[http]'\n</code></pre></p>"},{"location":"#graphql-extra-option","title":"<code>graphql</code> extra option","text":"<p>If you want to generate data model from a GraphQL schema then you should specify <code>graphql</code> extra option. <pre><code>$ pip install 'datamodel-code-generator[graphql]'\n</code></pre></p>"},{"location":"#docker-image","title":"Docker Image","text":"<p>The docker image is in Docker Hub <pre><code>$ docker pull koxudaxi/datamodel-code-generator\n</code></pre></p>"},{"location":"#advanced-uses","title":"Advanced Uses","text":"<p>You can generate models from a URL. <pre><code>$ datamodel-codegen --url https://&lt;INPUT FILE URL&gt; --output model.py\n</code></pre> This method needs the http extra option</p>"},{"location":"#all-command-options","title":"All Command Options","text":"<p>The <code>datamodel-codegen</code> command: <pre><code>usage:\n  datamodel-codegen [options]\n\nGenerate Python data models from schema definitions or structured data\n\nOptions:\n  --http-headers HTTP_HEADER [HTTP_HEADER ...]\n                        Set headers in HTTP requests to the remote host.\n                        (example: \"Authorization: Basic dXNlcjpwYXNz\")\n  --http-ignore-tls     Disable verification of the remote host's TLS\n                        certificate\n  --input INPUT         Input file/directory (default: stdin)\n  --input-file-type {auto,openapi,graphql,jsonschema,json,yaml,dict,csv}\n                        Input file type (default: auto)\n  --output OUTPUT       Output file (default: stdout)\n  --output-model-type {pydantic.BaseModel,pydantic_v2.BaseModel,dataclasses.dataclass,typing.TypedDict,msgspec.Struct}\n                        Output model type (default: pydantic.BaseModel)\n  --url URL             Input file URL. `--input` is ignored when `--url` is\n                        used\n\nTyping customization:\n  --base-class BASE_CLASS\n                        Base Class (default: pydantic.BaseModel)\n  --enum-field-as-literal {all,one}\n                        Parse enum field as literal. all: all enum field type\n                        are Literal. one: field type is Literal when an enum\n                        has only one possible value\n  --field-constraints   Use field constraints and not con* annotations\n  --set-default-enum-member\n                        Set enum members as default values for enum field\n  --strict-types {str,bytes,int,float,bool} [{str,bytes,int,float,bool} ...]\n                        Use strict types\n  --use-annotated       Use typing.Annotated for Field(). Also, `--field-\n                        constraints` option will be enabled.\n  --use-generic-container-types\n                        Use generic container types for type hinting\n                        (typing.Sequence, typing.Mapping). If `--use-standard-\n                        collections` option is set, then import from\n                        collections.abc instead of typing\n  --use-non-positive-negative-number-constrained-types\n                        Use the Non{Positive,Negative}{FloatInt} types instead\n                        of the corresponding con* constrained types.\n  --use-one-literal-as-default\n                        Use one literal as default value for one literal field\n  --use-standard-collections\n                        Use standard collections for type hinting (list, dict)\n  --use-subclass-enum   Define Enum class as subclass with field type when\n                        enum has type (int, float, bytes, str)\n  --use-union-operator  Use | operator for Union type (PEP 604).\n  --use-unique-items-as-set\n                        define field type as `set` when the field attribute\n                        has `uniqueItems`\n\nField customization:\n  --capitalise-enum-members, --capitalize-enum-members\n                        Capitalize field names on enum\n  --empty-enum-field-name EMPTY_ENUM_FIELD_NAME\n                        Set field name when enum value is empty (default: `_`)\n  --field-extra-keys FIELD_EXTRA_KEYS [FIELD_EXTRA_KEYS ...]\n                        Add extra keys to field parameters\n  --field-extra-keys-without-x-prefix FIELD_EXTRA_KEYS_WITHOUT_X_PREFIX [FIELD_EXTRA_KEYS_WITHOUT_X_PREFIX ...]\n                        Add extra keys with `x-` prefix to field parameters.\n                        The extra keys are stripped of the `x-` prefix.\n  --field-include-all-keys\n                        Add all keys to field parameters\n  --force-optional      Force optional for required fields\n  --original-field-name-delimiter ORIGINAL_FIELD_NAME_DELIMITER\n                        Set delimiter to convert to snake case. This option\n                        only can be used with --snake-case-field (default: `_`\n                        )\n  --remove-special-field-name-prefix\n                        Remove field name prefix when first character can't be\n                        used as Python field name\n  --snake-case-field    Change camel-case field name to snake-case\n  --special-field-name-prefix SPECIAL_FIELD_NAME_PREFIX\n                        Set field name prefix when first character can't be\n                        used as Python field name (default: `field`)\n  --strip-default-none  Strip default None on fields\n  --use-default         Use default value even if a field is required\n  --use-default-kwarg   Use `default=` instead of a positional argument for\n                        Fields that have default values.\n  --use-field-description\n                        Use schema description to populate field docstring\n\nModel customization:\n  --allow-extra-fields  Allow to pass extra fields, if this flag is not\n                        passed, extra fields are forbidden.\n  --allow-population-by-field-name\n                        Allow population by field name\n  --class-name CLASS_NAME\n                        Set class name of root model\n  --collapse-root-models\n                        Models generated with a root-type field will be\n                        mergedinto the models using that root-type model\n  --disable-appending-item-suffix\n                        Disable appending `Item` suffix to model name in an\n                        array\n  --disable-timestamp   Disable timestamp on file headers\n  --enable-faux-immutability\n                        Enable faux immutability\n  --enable-version-header\n                        Enable package version on file headers\n  --keep-model-order    Keep generated models' order\n  --reuse-model         Re-use models on the field when a module has the model\n                        with the same content\n  --target-python-version {3.6,3.7,3.8,3.9,3.10,3.11}\n                        target python version (default: 3.7)\n  --use-schema-description\n                        Use schema description to populate class docstring\n  --use-title-as-name   use titles as class names of models\n\nTemplate customization:\n  --aliases ALIASES     Alias mapping file\n  --custom-file-header CUSTOM_FILE_HEADER\n                        Custom file header\n  --custom-file-header-path CUSTOM_FILE_HEADER_PATH\n                        Custom file header file path\n  --custom-template-dir CUSTOM_TEMPLATE_DIR\n                        Custom template directory\n  --encoding ENCODING   The encoding of input and output (default: UTF-8)\n  --extra-template-data EXTRA_TEMPLATE_DATA\n                        Extra template data\n  --use-double-quotes   Model generated with double quotes. Single quotes or\n                        your black config skip_string_normalization value will\n                        be used without this option.\n  --wrap-string-literal\n                        Wrap string literal by using black `experimental-\n                        string-processing` option (require black 20.8b0 or\n                        later)\n  --additional-imports  Custom imports for output (delimited list input).\n                        For example \"datetime.date,datetime.datetime\"\n  --custom-formatters   List of modules with custom formatter (delimited list input).\n  --custom-formatters-kwargs A file with kwargs for custom formatters.\n\nOpenAPI-only options:\n  --openapi-scopes {schemas,paths,tags,parameters} [{schemas,paths,tags,parameters} ...]\n                        Scopes of OpenAPI model generation (default: schemas)\n  --strict-nullable     Treat default field as a non-nullable field (Only\n                        OpenAPI)\n  --use-operation-id-as-name\n                        use operation id of OpenAPI as class names of models\n  --validation          Deprecated: Enable validation (Only OpenAPI). this\n                        option is deprecated. it will be removed in future\n                        releases\n\nGeneral options:\n  --debug               show debug message (require \"debug\". `$ pip install 'datamodel-code-generator[debug]'`)\n  --disable-warnings    disable warnings\n  --no-color            disable colorized output\n  --version             show version\n  -h, --help            show this help message and exit\n</code></pre></p> <p>Click here to see supported input formats</p>"},{"location":"#related-projects","title":"Related projects","text":""},{"location":"#fastapi-code-generator","title":"fastapi-code-generator","text":"<p>This code generator creates FastAPI app from an openapi file.</p> <p>https://github.com/koxudaxi/fastapi-code-generator</p>"},{"location":"#pydantic-pycharm-plugin","title":"pydantic-pycharm-plugin","text":"<p>A JetBrains PyCharm plugin for <code>pydantic</code>.</p> <p>https://github.com/koxudaxi/pydantic-pycharm-plugin</p>"},{"location":"#pypi","title":"PyPi","text":"<p>https://pypi.org/project/datamodel-code-generator</p>"},{"location":"#license","title":"License","text":"<p>datamodel-code-generator is released under the MIT License. http://www.opensource.org/licenses/mit-license</p>"},{"location":"custom-formatters/","title":"Custom Code Formatters","text":"<p>New features of the <code>datamodel-code-generator</code> it is custom code formatters.</p>"},{"location":"custom-formatters/#usage","title":"Usage","text":"<p>To use the <code>--custom-formatters</code> option, you'll need to pass the module with your formatter. For example</p> <p>your_module.py <pre><code>from datamodel_code_generator.format import CustomCodeFormatter\n\nclass CodeFormatter(CustomCodeFormatter):\n    def apply(self, code: str) -&gt; str:\n        # processed code\n        return ...       \n</code></pre></p> <p>and run the following command</p> <pre><code>$ datamodel-codegen --input {your_input_file} --output {your_output_file} --custom-formatters \"{path_to_your_module}.your_module\"\n</code></pre>"},{"location":"custom_template/","title":"Custom Templates","text":"<p>One of the powerful features of the <code>datamodel-code-generator</code> is the ability to use custom templates with the <code>--custom-template-dir</code> option. This option allows you to provide a directory containing Jinja2 templates for customizing the generated code. In this document, we'll explore how to use this option and provide an example to help you understand its usage.</p>"},{"location":"custom_template/#usage","title":"Usage","text":"<p>To use the <code>--custom-template-dir</code> option, you'll need to pass the directory path containing your custom templates as an argument. The command will look like this:</p> <p><pre><code>$ datamodel-codegen --input {your_input_file} --output {your_output_file} --custom-template-dir {your_custom_template_directory}\n</code></pre> Replace {your_input_file}, {your_output_file}, and {your_custom_template_directory} with the appropriate paths.</p>"},{"location":"custom_template/#example","title":"Example","text":"<p>Let's say you want to generate a custom Python data model from a JSON Schema file called person.json. You want the generated data model to include a custom comment at the top of the file. To achieve this, you can create a custom template using Jinja2.</p> <p>First, create a directory called <code>custom_templates</code> in your project directory. Inside this folder, create another folder called pydantic. Now, inside the <code>pydantic</code> folder, create a new file called <code>BaseModel.jinja2</code> with the following content:</p> <p>custom_templates/pydantic/BaseModel.jinja2 <pre><code># This is a custom comment generated with custom_template!!\n\nclass {{ class_name }}({{ base_class }}):\n{%- for field in fields %}\n    {{ field.name }}: {{ field.type_hint }}\n{%- endfor -%}\n</code></pre></p> <p>This custom template includes the custom comment at the top and replicates the default rendering behavior of the BaseModel.jinja2 template from the Datamodel Code Generator.</p> <p>Now, you can use the --custom-template-dir option to generate the data model with your custom template: <pre><code>$ datamodel-codegen --input person.json --output person.py --custom-template-dir custom_templates\n</code></pre></p> <p>The generated <code>person.py</code> file will now include your custom comment at the top:</p> <p>person.py <pre><code># generated by datamodel-codegen:\n#   filename:  person.json\n#   timestamp: 2023-04-09T05:36:24+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n# This is a custom comment generated with custom_template!!\n\n\nclass Model(BaseModel):\n    name: Optional[str]\n    age: Optional[int]\n</code></pre></p> <p>In this example, we kept it simple, but you can create more complex custom templates by copying the default templates Use the default templates as a reference for understanding the structure and available variables, and customize the code generation process according to your specific requirements.</p>"},{"location":"development-contributing/","title":"Development","text":"<p>Install the package in editable mode:</p> <pre><code>$ git clone git@github.com:koxudaxi/datamodel-code-generator.git\n$ pip install -e datamodel-code-generator\n</code></pre>"},{"location":"development-contributing/#contribute","title":"Contribute","text":"<p>We are waiting for your contributions to <code>datamodel-code-generator</code>.</p>"},{"location":"development-contributing/#how-to-contribute","title":"How to contribute","text":"<pre><code>## 1. Clone your fork repository\n$ git clone git@github.com:&lt;your username&gt;/datamodel-code-generator.git\n$ cd datamodel-code-generator\n\n## 2. Install [poetry](https://github.com/python-poetry/poetry)\n$ curl -sSL https://install.python-poetry.org | python3 - \n\n## 3. Install dependencies\n$ poetry install\n\n## 4. Create new branch and rewrite code.\n$ git checkout -b new-branch\n\n## 5. Run unittest (you should pass all test and coverage should be 100%)\n$ poetry run ./scripts/test.sh\n\n## 6. Format code\n$ poetry run ./scripts/format.sh\n\n## 7. Check lint (mypy)\n$ poetry run ./scripts/lint.sh\n\n## 8. Commit and Push...\n</code></pre>"},{"location":"field-constraints/","title":"Field Constraints","text":"<p>An option <code>--field-constraints</code> converts all con* annotations to Field constraint options.</p> <p>Mypy may show error for <code>con*</code> annotations on fields. The option resolves the problem.</p>"},{"location":"field-constraints/#example","title":"Example","text":"<p>Convert simple JSON Schema <code>model.json</code> to pydantic model <code>model.py</code></p> <p>Input JSON Schema</p> <p><code>model.json</code> <pre><code>{\n  \"type\":  \"object\",\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\",\n      \"maxLength\": 64\n    }\n  },\n  \"required\": [\"name\"]\n}\n</code></pre></p>"},{"location":"field-constraints/#without-field-constraints-option","title":"Without <code>--field-constraints</code> option","text":"<pre><code>$ datamodel-codegen --input a.json --input-file-type jsonschema &gt; model.py \n</code></pre> <p>Generated Model</p> <p><code>model.py</code> <pre><code># generated by datamodel-codegen:\n#   filename:  model.json\n#   timestamp: 2020-07-20T15:37:56+00:00\n\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel, constr\n\n\nclass  Model(BaseModel):\n  name: constr(max_length=64)\n</code></pre></p> <p>Run mypy... <pre><code>$ mypy model.py \nmodel.py:3: error: Invalid type comment or annotation\nmodel.py:3: note: Suggestion: use constr[...] instead of constr(...)\nFound 1 error in 1 file (checked 1 source file)\n</code></pre> mypy show errors...</p>"},{"location":"field-constraints/#with-field-constraints-option","title":"With <code>--field-constraints</code> option","text":"<pre><code>$ datamodel-codegen --input model.json --input-file-type jsonschema --field-constraints &gt; model.py \n</code></pre> <p>Generated Model</p> <p><code>model.py</code> <pre><code># generated by datamodel-codegen:\n#   filename:  model.json\n#   timestamp: 2020-07-20T15:47:21+00:00\n\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    name: str = Field(..., max_length=64)\n</code></pre></p> <p>Run mypy... <pre><code>$ mypy model.py \nSuccess: no issues found in 1 source file\n</code></pre></p>"},{"location":"field-constraints/#related-issues","title":"Related issues","text":"<p>https://github.com/samuelcolvin/pydantic/issues/156</p>"},{"location":"formatting/","title":"Formatting","text":"<p>Code generated by <code>datamodel-codegen</code> will be passed through <code>isort</code> and <code>black</code> to produce consistent, well-formatted results. Settings for these tools can be specified in <code>pyproject.toml</code> (located in the output directory, or in some parent of the output directory). Also for black you can disable  skip-string-normalization with using datamodel-codegen option <code>--use-double-quotes</code>,  it will override your black config skip-string-normalization value. Using --use-double-quotes may be useful if you can't use black config. </p>"},{"location":"formatting/#example","title":"Example","text":"<p>pyproject.toml <pre><code>[tool.black]\nskip-string-normalization = true\nline-length = 100\n\n[tool.isort]\nmulti_line_output = 3\ninclude_trailing_comma = true\nforce_grid_wrap = 0\nuse_parentheses = true\nline_length = 100\nknown_first_party = \"kelvin\"\n</code></pre></p> <p>See the Black Project for more information.</p>"},{"location":"graphql/","title":"Generate from GraphQL","text":"<p>The code generator can create pydantic models from GraphQL schema definitions.</p>"},{"location":"graphql/#simple-example","title":"Simple example","text":"<pre><code>$ datamodel-codegen --input schema.graphql --input-file-type graphql --output model.py\n</code></pre> <p>Let's consider a simple GraphQL schema (more details in https://graphql.org/learn/schema/).</p> <p>schema.graphql <pre><code>type Book {\n  id: ID!  \n  title: String\n  author: Author\n}\n\ntype Author {\n  id: ID!  \n  name: String\n  books: [Book]\n}\n\ninput BooksInput {\n    ids: [ID!]!\n}\n\ninput AuthorBooksInput {\n    id: ID!\n}\n\ntype Query {\n  getBooks(input: BooksInput): [Book]\n  getAuthorBooks(input: AuthorBooksInput): [Book]\n}\n</code></pre></p> <p>model.py <pre><code># generated by datamodel-codegen:\n#   filename:  schema.graphql\n#   timestamp: 2023-11-20T17:04:42+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional, TypeAlias\n\nfrom pydantic import BaseModel, Field\nfrom typing_extensions import Literal\n\n# The `Boolean` scalar type represents `true` or `false`.\nBoolean: TypeAlias = bool\n\n\n# The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `\"4\"`) or integer (such as `4`) input value will be accepted as an ID.\nID: TypeAlias = str\n\n\n# The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\nString: TypeAlias = str\n\n\nclass Author(BaseModel):\n    books: Optional[List[Optional[Book]]] = Field(default_factory=list)\n    id: ID\n    name: Optional[String] = None\n    typename__: Optional[Literal['Author']] = Field('Author', alias='__typename')\n\n\nclass Book(BaseModel):\n    author: Optional[Author] = None\n    id: ID\n    title: Optional[String] = None\n    typename__: Optional[Literal['Book']] = Field('Book', alias='__typename')\n\n\nclass AuthorBooksInput(BaseModel):\n    id: ID\n    typename__: Optional[Literal['AuthorBooksInput']] = Field(\n        'AuthorBooksInput', alias='__typename'\n    )\n\n\nclass BooksInput(BaseModel):\n    ids: List[ID]\n    typename__: Optional[Literal['BooksInput']] = Field(\n        'BooksInput', alias='__typename'\n    )\n</code></pre></p>"},{"location":"graphql/#response-deserialization","title":"Response deserialization","text":"<p>For the following response of <code>getAuthorBooks</code> GraphQL query  </p> <p>response.json <pre><code>{\n  \"getAuthorBooks\": [\n    {\n      \"author\": {\n        \"id\": \"51341cdscwef14r13\",\n        \"name\": \"J. K. Rowling\"\n      },\n      \"id\": \"1321dfvrt211wdw\",\n      \"title\": \"Harry Potter and the Prisoner of Azkaban\"\n    },\n    {\n      \"author\": {\n        \"id\": \"51341cdscwef14r13\",\n        \"name\": \"J. K. Rowling\"\n      },\n      \"id\": \"dvsmu12e19xmqacqw9\",\n      \"title\": \"Fantastic Beasts: The Crimes of Grindelwald\"\n    }\n  ]\n}\n</code></pre></p> <p>main.py <pre><code>from model import Book\n\nresponse = {...}\n\nbooks = [\n    Book.parse_obj(book_raw) for book_raw in response[\"getAuthorBooks\"]\n]\nprint(books)\n# [Book(author=Author(books=[], id='51341cdscwef14r13', name='J. K. Rowling', typename__='Author'), id='1321dfvrt211wdw', title='Harry Potter and the Prisoner of Azkaban', typename__='Book'), Book(author=Author(books=[], id='51341cdscwef14r13', name='J. K. Rowling', typename__='Author'), id='dvsmu12e19xmqacqw9', title='Fantastic Beasts: The Crimes of Grindelwald', typename__='Book')]\n</code></pre></p>"},{"location":"graphql/#custom-scalar-types","title":"Custom scalar types","text":"<pre><code>$ datamodel-codegen --input schema.graphql --input-file-type graphql --output model.py --extra-template-data data.json\n</code></pre> <p>schema.graphql <pre><code>scalar Long\n\ntype A {\n  id: ID!\n  duration: Long!\n}\n</code></pre></p> <p>data.json <pre><code>{\n  \"Long\": {\n    \"py_type\": \"int\"\n  }\n}\n</code></pre></p> <p>model.py <pre><code># generated by datamodel-codegen:\n#   filename:  custom-scalar-types.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional, TypeAlias\n\nfrom pydantic import BaseModel, Field\nfrom typing_extensions import Literal\n\n# The `Boolean` scalar type represents `true` or `false`.\nBoolean: TypeAlias = bool\n\n\n# The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `\"4\"`) or integer (such as `4`) input value will be accepted as an ID.\nID: TypeAlias = str\n\n\nLong: TypeAlias = int\n\n\n# The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\nString: TypeAlias = str\n\n\nclass A(BaseModel):\n    duration: Long\n    id: ID\n    typename__: Optional[Literal['A']] = Field('A', alias='__typename')\n</code></pre></p>"},{"location":"jsondata/","title":"Generate from JSON Data","text":"<p>This code generator can create pydantic models from JSON Data. Under the hood, the generator uses GenSON to create JSON Schema from your input. The generated schema is then processed the in the same manner as JSON Schema input data.</p>"},{"location":"jsondata/#example","title":"Example","text":"<pre><code>$ datamodel-codegen  --input pets.json --input-file-type json --output model.py\n</code></pre> <p>pets.json <pre><code>{\n  \"pets\": [\n    {\n      \"name\": \"dog\",\n      \"age\": 2\n    },\n    {\n      \"name\": \"cat\",\n      \"age\": 1\n    },\n    {\n      \"name\": \"snake\",\n      \"age\": 3,\n      \"nickname\": \"python\"\n    }\n  ],\n  \"status\": 200\n}\n</code></pre></p> <p>model.py <pre><code># generated by datamodel-codegen:\n#   filename:  pets.json\n#   timestamp: 2020-04-27T16:08:21+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    name: str\n    age: int\n    nickname: Optional[str] = None\n\n\nclass Model(BaseModel):\n    pets: List[Pet]\n    status: int\n</code></pre></p>"},{"location":"jsonschema/","title":"Generate from JSON Schema","text":"<p>The code generator can create pydantic models from JSON Schema. See more information about supported JSON Schema data types and features here.</p>"},{"location":"jsonschema/#example","title":"Example","text":"<pre><code>$ datamodel-codegen  --input person.json --input-file-type jsonschema --output model.py\n</code></pre> <p>person.json <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Person\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"firstName\": {\n      \"type\": \"string\",\n      \"description\": \"The person's first name.\"\n    },\n    \"lastName\": {\n      \"type\": \"string\",\n      \"description\": \"The person's last name.\"\n    },\n    \"age\": {\n      \"description\": \"Age in years which must be equal to or greater than zero.\",\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"friends\": {\n      \"type\": \"array\"\n    },\n    \"comment\": {\n      \"type\": \"null\"\n    }\n  }\n}\n</code></pre></p> <p>model.py <pre><code># generated by datamodel-codegen:\n#   filename:  person.json\n#   timestamp: 2020-04-27T16:12:27+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Any, List, Optional\n\nfrom pydantic import BaseModel, Field, conint\n\n\nclass Person(BaseModel):\n    firstName: Optional[str] = Field(None, description=\"The person's first name.\")\n    lastName: Optional[str] = Field(None, description=\"The person's last name.\")\n    age: Optional[conint(ge=0)] = Field(\n        None, description='Age in years which must be equal to or greater than zero.'\n    )\n    friends: Optional[List] = None\n    comment: Optional[Any] = None\n</code></pre></p>"},{"location":"openapi/","title":"Generate from OpenAPI","text":"<p>The code generator can create pydantic models from OpenAPI schema definitions, particularly using the data from the <code>schema</code> field.</p>"},{"location":"openapi/#example","title":"Example","text":"<pre><code>$ datamodel-codegen --input api.yaml --input-file-type openapi --output model.py\n</code></pre> api.yaml <pre>\n<code>\n<pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Error:\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n</code></pre>\n</code>\n</pre> <p>model.py <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2020-06-02T05:28:24+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n</code></pre></p>"},{"location":"pyproject_toml/","title":"pyproject.toml","text":"<p>datamodel-code-generator has a lot of command-line options.</p> <p>The options are supported on <code>pyproject.toml</code>.</p> <p>Example <code>pyproject.toml</code>: <pre><code>[tool.datamodel-codegen]\nfield-constraints = true\nsnake-case-field = true\nstrip-default-none = false\ntarget-python-version = \"3.7\"\n</code></pre></p>"},{"location":"supported-data-types/","title":"Supported Input Formats","text":"<p>This code generator supports the following input formats:</p> <ul> <li>OpenAPI 3 (YAML/JSON, OpenAPI Data Type);</li> <li>JSON Schema (JSON Schema Core /JSON Schema Validation);</li> <li>JSON/YAML Data (it will be converted to JSON Schema);</li> <li>Python dictionary (it will be converted to JSON Schema);</li> <li>GraphQL schema (GraphQL Schemas and Types);</li> </ul>"},{"location":"supported-data-types/#implemented-data-types-and-features","title":"Implemented data types and features","text":"<p>Below are the data types and features recognized by datamodel-code-generator for OpenAPI 3 and JSON Schema.</p>"},{"location":"supported-data-types/#data-types","title":"Data Types","text":"<ul> <li>string (supported keywords: pattern/minLength/maxLength)</li> <li>number (supported keywords: maximum/exclusiveMaximum/minimum/exclusiveMinimum/multipleOf)</li> <li>integer (supported keywords: maximum/exclusiveMaximum/minimum/exclusiveMinimum/multipleOf)</li> <li>boolean</li> <li>array</li> <li>object</li> </ul>"},{"location":"supported-data-types/#string-formats","title":"String Formats","text":"<ul> <li>date</li> <li>datetime</li> <li>time</li> <li>password</li> <li>email</li> <li>idn-email</li> <li>uuid (uuid1/uuid2/uuid3/uuid4/uuid5)</li> <li>ipv4</li> <li>ipv6</li> <li>hostname</li> <li>decimal</li> </ul>"},{"location":"supported-data-types/#other-schema","title":"Other schema","text":"<ul> <li>enum (as enum.Enum or typing.Literal)</li> <li>allOf (as Multiple inheritance)</li> <li>anyOf (as typing.Union)</li> <li>oneOf (as typing.Union)</li> <li>$ref (http extra is required when resolving $ref for remote files.)</li> <li>$id (for JSONSchema)</li> </ul>"},{"location":"using_as_module/","title":"Using datamode-code-generator as a Module","text":"<p>datamodel-code-generator is a CLI tool, but it can also be used as a module.</p> <p>You can call this code-generator in your python code.</p>"},{"location":"using_as_module/#how-to-use-it-as-module","title":"How to use it as module","text":"<p>You can generate models with <code>datamodel_code_generator.generate</code> using parameters that match the arguments provided to the CLI tool. The generated files can be written to and read from the <code>Path</code> object supplied to output.</p> <p>In the below example, we use a file in a <code>TemporaryDirectory</code> to store our output.</p>"},{"location":"using_as_module/#installation","title":"Installation","text":"<pre><code>pip install 'datamodel-code-generator[http]'\n</code></pre>"},{"location":"using_as_module/#example","title":"Example","text":"<pre><code>from pathlib import Path\nfrom tempfile import TemporaryDirectory\nfrom datamodel_code_generator import InputFileType, generate\nfrom datamodel_code_generator import DataModelType\n\njson_schema: str = \"\"\"{\n    \"type\": \"object\",\n    \"properties\": {\n        \"number\": {\"type\": \"number\"},\n        \"street_name\": {\"type\": \"string\"},\n        \"street_type\": {\"type\": \"string\",\n                        \"enum\": [\"Street\", \"Avenue\", \"Boulevard\"]\n                        }\n    }\n}\"\"\"\n\nwith TemporaryDirectory() as temporary_directory_name:\n    temporary_directory = Path(temporary_directory_name)\n    output = Path(temporary_directory / 'model.py')\n    generate(\n        json_schema,\n        input_file_type=InputFileType.JsonSchema,\n        input_filename=\"example.json\",\n        output=output,\n        # set up the output model types\n        output_model_type=DataModelType.PydanticV2BaseModel,\n    )\n    model: str = output.read_text()\nprint(model)\n</code></pre> <p>The result of <code>print(model)</code>: <pre><code># generated by datamodel-codegen:\n#   filename:  example.json\n#   timestamp: 2020-12-21T08:01:06+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass StreetType(Enum):\n    Street = 'Street'\n    Avenue = 'Avenue'\n    Boulevard = 'Boulevard'\n\n\nclass Model(BaseModel):\n    number: Optional[float] = None\n    street_name: Optional[str] = None\n    street_type: Optional[StreetType] = None\n</code></pre></p> <p>Also, you can call parser directly</p> <pre><code>from datamodel_code_generator import DataModelType, PythonVersion\nfrom datamodel_code_generator.model import get_data_model_types\nfrom datamodel_code_generator.parser.jsonschema import JsonSchemaParser\n\njson_schema: str = \"\"\"{\n    \"type\": \"object\",\n    \"properties\": {\n        \"number\": {\"type\": \"number\"},\n        \"street_name\": {\"type\": \"string\"},\n        \"street_type\": {\"type\": \"string\",\n                        \"enum\": [\"Street\", \"Avenue\", \"Boulevard\"]\n                        }\n    }\n}\"\"\"\n\n\ndata_model_types = get_data_model_types(\n    DataModelType.PydanticV2BaseModel,\n    target_python_version=PythonVersion.PY_311\n)\nparser = JsonSchemaParser(\n   json_schema,\n   data_model_type=data_model_types.data_model,\n   data_model_root_type=data_model_types.root_model,\n   data_model_field_type=data_model_types.field_model,\n   data_type_manager_type=data_model_types.data_type_manager,\n   dump_resolve_reference_action=data_model_types.dump_resolve_reference_action,\n                       )\nresult = parser.parse()\nprint(result)\n ```\n\nThe result of `print(model)`:\n```python\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass StreetType(Enum):\n    Street = 'Street'\n    Avenue = 'Avenue'\n    Boulevard = 'Boulevard'\n\n\nclass Model(BaseModel):\n    number: Optional[float] = None\n    street_name: Optional[str] = None\n    street_type: Optional[StreetType] = None\n</code></pre>"},{"location":"using_as_module/#why-doesnt-datamodel_code_generatorgenerate-return-a-string","title":"Why doesn't <code>datamodel_code_generator.generate</code> return a string?","text":"<p>The above example schema only generates a single python module, but a single schema may generate multiple modules. There is no way to represent these modules as a single string, so the <code>generate</code> method returns <code>None</code>.</p> <p>Note that the output parameter can take any <code>Path</code> object, which includes both file and directory paths. If a file name is provided and multiple modules are generated, <code>generate</code> will raise a <code>datamodel_code_gen.Error</code> exception.</p> <p>If multiple modules are generated, you will need to walk through the supplied output directory to find all of them.</p>"},{"location":"what_is_the_difference_between_v1_and_v2/","title":"What is the difference between pydantic v1 and v2 output model?","text":""},{"location":"what_is_the_difference_between_v1_and_v2/#summary","title":"Summary","text":"<p>datamodel-code-generator supports Pydantic v1 and v2 as output model type.</p> <p>Pydantic v2 is a major release with many breaking changes. See the migration guide for more information: https://docs.pydantic.dev/2.0/migration/</p>"},{"location":"what_is_the_difference_between_v1_and_v2/#whats-changes-in-v2-output","title":"What's changes in v2 output?","text":""},{"location":"what_is_the_difference_between_v1_and_v2/#__root__-field-aka-custom-root-types","title":"<code>__root__</code> field (a.k.a Custom Root Types)","text":"<p><code>__root__</code> field (a.k.a Custom Root Types) is removed in pydantic v2. The model is changed to RootModel</p>"},{"location":"what_is_the_difference_between_v1_and_v2/#pydanticfield","title":"pydantic.Field","text":"<p>https://docs.pydantic.dev/2.0/migration/#changes-to-pydanticfield</p> <ul> <li>const -&gt; removed</li> <li>min_items (use min_length instead)</li> <li>max_items (use max_length instead)</li> <li>unique_items -&gt; removed and the list type will be replaced by <code>typing.Set</code>. this feature is discussed in https://github.com/pydantic/pydantic-core/issues/296</li> <li>allow_mutation (use frozen instead)</li> <li>regex (use pattern instead)</li> </ul>"},{"location":"what_is_the_difference_between_v1_and_v2/#model-config","title":"Model Config","text":"<ul> <li><code>pydantic.Config</code> -&gt; <code>pydantic.ConfigDict</code> </li> <li>allow_mutation \u2014&gt; frozen (inverse value for getting same behavior).</li> <li>allow_population_by_field_name \u2192 populate_by_name</li> </ul>"}]}