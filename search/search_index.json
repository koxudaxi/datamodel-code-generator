{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"datamodel-code-generator","text":"<p>This code generator creates pydantic v1 and v2 model, dataclasses.dataclass, typing.TypedDict and msgspec.Struct from an openapi file and others.</p> <p> </p>"},{"location":"#quick-installation","title":"Quick Installation","text":"<p>To install <code>datamodel-code-generator</code>: <pre><code>$ pip install datamodel-code-generator\n</code></pre></p>"},{"location":"#simple-usage","title":"Simple Usage","text":"<p>You can generate models from a local file. <pre><code>$ datamodel-codegen --input api.yaml --output model.py\n</code></pre></p> api.yaml <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Error:\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n</code></pre> model.py <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2020-06-02T05:28:24+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n</code></pre>"},{"location":"#supported-input-types","title":"Supported input types","text":"<ul> <li>OpenAPI 3 (YAML/JSON, OpenAPI Data Type);</li> <li>JSON Schema (JSON Schema Core/JSON Schema Validation);</li> <li>JSON/YAML/CSV Data (it will be converted to JSON Schema);</li> <li>Python dictionary (it will be converted to JSON Schema);</li> <li>GraphQL schema (GraphQL Schemas and Types);</li> </ul>"},{"location":"#supported-output-types","title":"Supported output types","text":"<ul> <li>pydantic.BaseModel;</li> <li>pydantic_v2.BaseModel;</li> <li>dataclasses.dataclass;</li> <li>typing.TypedDict;</li> <li>msgspec.Struct;</li> <li>Custom type from your jinja2 template;</li> </ul>"},{"location":"#sponsors","title":"Sponsors","text":"<p>Astral</p>"},{"location":"#projects-that-use-datamodel-code-generator","title":"Projects that use datamodel-code-generator","text":"<p>These OSS projects use datamodel-code-generator to generate many models.  See the following linked projects for real world examples and inspiration.</p> <ul> <li>airbytehq/airbyte<ul> <li>code-generator/Dockerfile</li> </ul> </li> <li>apache/iceberg<ul> <li>Generate Python code <code>make generate</code></li> </ul> </li> <li>argoproj-labs/hera<ul> <li><code>Makefile</code></li> </ul> </li> <li>awslabs/aws-lambda-powertools-python<ul> <li>Recommended for advanced-use-cases in the official documentation</li> </ul> </li> <li>DataDog/integrations-core<ul> <li>Config models</li> </ul> </li> <li>hashintel/hash<ul> <li><code>codegen.sh</code></li> </ul> </li> <li>IBM/compliance-trestle<ul> <li>Building the models from the OSCAL schemas.</li> </ul> </li> <li>Netflix/consoleme<ul> <li>How do I generate models from the Swagger specification?</li> </ul> </li> <li>Nike-Inc/brickflow<ul> <li>Code generate tools<code>./tools/gen-bundle.sh</code></li> </ul> </li> <li>open-metadata/OpenMetadata<ul> <li>Makefile</li> </ul> </li> <li>PostHog/posthog<ul> <li>Generate models via <code>npm run</code> </li> </ul> </li> <li>SeldonIO/MLServer<ul> <li>generate-types.sh</li> </ul> </li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>To install <code>datamodel-code-generator</code>: <pre><code>$ pip install datamodel-code-generator\n</code></pre></p>"},{"location":"#http-extra-option","title":"<code>http</code> extra option","text":"<p>If you want to resolve <code>$ref</code> for remote files then you should specify <code>http</code> extra option. <pre><code>$ pip install 'datamodel-code-generator[http]'\n</code></pre></p>"},{"location":"#graphql-extra-option","title":"<code>graphql</code> extra option","text":"<p>If you want to generate data model from a GraphQL schema then you should specify <code>graphql</code> extra option. <pre><code>$ pip install 'datamodel-code-generator[graphql]'\n</code></pre></p>"},{"location":"#docker-image","title":"Docker Image","text":"<p>The docker image is in Docker Hub <pre><code>$ docker pull koxudaxi/datamodel-code-generator\n</code></pre></p>"},{"location":"#advanced-uses","title":"Advanced Uses","text":"<p>You can generate models from a URL. <pre><code>$ datamodel-codegen --url https://&lt;INPUT FILE URL&gt; --output model.py\n</code></pre> This method needs the http extra option</p>"},{"location":"#all-command-options","title":"All Command Options","text":"<p>The <code>datamodel-codegen</code> command:</p> <pre><code>usage: \n  datamodel-codegen [options]\n\nGenerate Python data models from schema definitions or structured data\n\nOptions:\n  --additional-imports ADDITIONAL_IMPORTS\n                        Custom imports for output (delimited list input). For example\n                        \"datetime.date,datetime.datetime\"\n  --custom-formatters CUSTOM_FORMATTERS\n                        List of modules with custom formatter (delimited list input).\n  --formatters {black,isort,ruff-check,ruff-format} [{black,isort,ruff-check,ruff-format} ...]\n                        Formatters for output (default: [black, isort])\n  --http-headers HTTP_HEADER [HTTP_HEADER ...]\n                        Set headers in HTTP requests to the remote host. (example:\n                        \"Authorization: Basic dXNlcjpwYXNz\")\n  --http-ignore-tls     Disable verification of the remote host''s TLS certificate\n  --http-query-parameters HTTP_QUERY_PARAMETERS [HTTP_QUERY_PARAMETERS ...]\n                        Set query parameters in HTTP requests to the remote host. (example:\n                        \"ref=branch\")\n  --input INPUT         Input file/directory (default: stdin)\n  --input-file-type {auto,openapi,jsonschema,json,yaml,dict,csv,graphql}\n                        Input file type (default: auto)\n  --output OUTPUT       Output file (default: stdout)\n  --output-model-type {pydantic.BaseModel,pydantic_v2.BaseModel,dataclasses.dataclass,typing.TypedDict,msgspec.Struct}\n                        Output model type (default: pydantic.BaseModel)\n  --url URL             Input file URL. `--input` is ignored when `--url` is used\n\nTyping customization:\n  --base-class BASE_CLASS\n                        Base Class (default: pydantic.BaseModel)\n  --disable-future-imports\n                        Disable __future__ imports\n  --enum-field-as-literal {all,one}\n                        Parse enum field as literal. all: all enum field type are Literal.\n                        one: field type is Literal when an enum has only one possible value\n  --field-constraints   Use field constraints and not con* annotations\n  --set-default-enum-member\n                        Set enum members as default values for enum field\n  --strict-types {str,bytes,int,float,bool} [{str,bytes,int,float,bool} ...]\n                        Use strict types\n  --type-mappings TYPE_MAPPINGS [TYPE_MAPPINGS ...]\n                        Override default type mappings. Format: \"type+format=target\" (e.g.,\n                        \"string+binary=string\" to map binary format to string type) or\n                        \"format=target\" (e.g., \"binary=string\"). Can be specified multiple\n                        times.\n  --use-annotated       Use typing.Annotated for Field(). Also, `--field-constraints` option\n                        will be enabled.\n  --use-enum-values-in-discriminator\n                        Use enum member literals in discriminator fields instead of string\n                        literals\n  --use-generic-container-types\n                        Use generic container types for type hinting (typing.Sequence,\n                        typing.Mapping). If `--use-standard-collections` option is set, then\n                        import from collections.abc instead of typing\n  --use-non-positive-negative-number-constrained-types\n                        Use the Non{Positive,Negative}{FloatInt} types instead of the\n                        corresponding con* constrained types.\n  --use-one-literal-as-default\n                        Use one literal as default value for one literal field\n  --use-serialize-as-any\n                        Use pydantic.SerializeAsAny for fields with types that have subtypes\n                        (Pydantic v2 only)\n  --use-specialized-enum, --no-use-specialized-enum\n                        Don''t use specialized Enum class (StrEnum, IntEnum) even if the\n                        target Python version supports it\n  --use-standard-collections\n                        Use standard collections for type hinting (list, dict)\n  --use-subclass-enum   Define generic Enum class as subclass with field type when enum has\n                        type (int, float, bytes, str)\n  --use-type-alias      Use TypeAlias instead of root models (experimental)\n  --use-union-operator  Use | operator for Union type (PEP 604).\n  --use-unique-items-as-set\n                        define field type as `set` when the field attribute has\n                        `uniqueItems`\n\nField customization:\n  --capitalise-enum-members, --capitalize-enum-members\n                        Capitalize field names on enum\n  --empty-enum-field-name EMPTY_ENUM_FIELD_NAME\n                        Set field name when enum value is empty (default: `_`)\n  --field-extra-keys FIELD_EXTRA_KEYS [FIELD_EXTRA_KEYS ...]\n                        Add extra keys to field parameters\n  --field-extra-keys-without-x-prefix FIELD_EXTRA_KEYS_WITHOUT_X_PREFIX [FIELD_EXTRA_KEYS_WITHOUT_X_PREFIX ...]\n                        Add extra keys with `x-` prefix to field parameters. The extra keys\n                        are stripped of the `x-` prefix.\n  --field-include-all-keys\n                        Add all keys to field parameters\n  --force-optional      Force optional for required fields\n  --no-alias            Do not add a field alias. E.g., if --snake-case-field is used along\n                        with a base class, which has an alias_generator\n  --original-field-name-delimiter ORIGINAL_FIELD_NAME_DELIMITER\n                        Set delimiter to convert to snake case. This option only can be used\n                        with --snake-case-field (default: `_` )\n  --remove-special-field-name-prefix\n                        Remove field name prefix if it has a special meaning e.g.\n                        underscores\n  --snake-case-field    Change camel-case field name to snake-case\n  --special-field-name-prefix SPECIAL_FIELD_NAME_PREFIX\n                        Set field name prefix when first character can''t be used as Python\n                        field name (default: `field`)\n  --strip-default-none  Strip default None on fields\n  --union-mode {smart,left_to_right}\n                        Union mode for only pydantic v2 field\n  --use-attribute-docstrings\n                        Set use_attribute_docstrings=True in Pydantic v2 ConfigDict\n  --use-default         Use default value even if a field is required\n  --use-default-kwarg   Use `default=` instead of a positional argument for Fields that have\n                        default values.\n  --use-field-description\n                        Use schema description to populate field docstring\n  --use-frozen-field    Use Field(frozen=True) for readOnly fields (Pydantic v2) or\n                        Field(allow_mutation=False) (Pydantic v1)\n  --use-inline-field-description\n                        Use schema description to populate field docstring as inline\n                        docstring\n\nModel customization:\n  --all-exports-collision-strategy {error,minimal-prefix,full-prefix}\n                        Strategy for name collisions when using --all-exports-\n                        scope=recursive. ''error'': raise an error (default). ''minimal-\n                        prefix'': add module prefix only to colliding names. ''full-prefix'':\n                        add full module path prefix to colliding names.\n  --all-exports-scope {children,recursive}\n                        Generate __all__ in __init__.py with re-exports. ''children'': export\n                        from direct child modules only. ''recursive'': export from all\n                        descendant modules.\n  --allow-extra-fields  Deprecated: Allow passing extra fields. This flag is deprecated. Use\n                        `--extra-fields=allow` instead.\n  --allow-population-by-field-name\n                        Allow population by field name\n  --class-name CLASS_NAME\n                        Set class name of root model\n  --collapse-root-models\n                        Models generated with a root-type field will be merged into the\n                        models using that root-type model\n  --dataclass-arguments DATACLASS_ARGUMENTS\n                        Custom dataclass arguments as a JSON dictionary, e.g. ''{\"frozen\":\n                        true, \"kw_only\": true}''. Overrides --frozen-dataclasses and similar\n                        flags.\n  --disable-appending-item-suffix\n                        Disable appending `Item` suffix to model name in an array\n  --disable-timestamp   Disable timestamp on file headers\n  --enable-faux-immutability\n                        Enable faux immutability\n  --enable-version-header\n                        Enable package version on file headers\n  --extra-fields {allow,ignore,forbid}\n                        Set the generated models to allow, forbid, or ignore extra fields.\n  --frozen-dataclasses  Generate frozen dataclasses (dataclass(frozen=True)). Only applies\n                        to dataclass output.\n  --keep-model-order    Keep generated models'' order\n  --keyword-only        Defined models as keyword only (for example\n                        dataclass(kw_only=True)).\n  --output-datetime-class {datetime,AwareDatetime,NaiveDatetime}\n                        Choose Datetime class between AwareDatetime, NaiveDatetime or\n                        datetime. Each output model has its default mapping (for example\n                        pydantic: datetime, dataclass: str, ...)\n  --parent-scoped-naming\n                        Set name of models defined inline from the parent model\n  --reuse-model         Reuse models on the field when a module has the model with the same\n                        content\n  --reuse-scope {module,tree}\n                        Scope for model reuse deduplication: module (per-file, default) or\n                        tree (cross-file with shared module). Only effective when --reuse-\n                        model is set.\n  --shared-module-name SHARED_MODULE_NAME\n                        Name of the shared module for --reuse-scope=tree (default:\n                        \"shared\"). Use this option if your schema has a file named \"shared\".\n  --skip-root-model     Skip generating the model for the root schema element\n  --target-python-version {3.9,3.10,3.11,3.12,3.13,3.14}\n                        target python version\n  --treat-dot-as-module\n                        treat dotted module names as modules\n  --use-exact-imports   import exact types instead of modules, for example: \"from .foo\n                        import Bar\" instead of \"from . import foo\" with \"foo.Bar\"\n  --use-pendulum        use pendulum instead of datetime\n  --use-schema-description\n                        Use schema description to populate class docstring\n  --use-title-as-name   use titles as class names of models\n\nTemplate customization:\n  --aliases ALIASES     Alias mapping file (JSON) for renaming fields. Supports hierarchical\n                        formats: Flat: {''field'': ''alias''} applies to all occurrences.\n                        Scoped: {''ClassName.field'': ''alias''} applies to specific class.\n                        Priority: scoped &gt; flat. Example: {''User.name'': ''user_name'',\n                        ''Address.name'': ''addr_name'', ''id'': ''id_''}\n  --custom-file-header CUSTOM_FILE_HEADER\n                        Custom file header\n  --custom-file-header-path CUSTOM_FILE_HEADER_PATH\n                        Custom file header file path\n  --custom-formatters-kwargs CUSTOM_FORMATTERS_KWARGS\n                        A file with kwargs for custom formatters.\n  --custom-template-dir CUSTOM_TEMPLATE_DIR\n                        Custom template directory\n  --encoding ENCODING   The encoding of input and output (default: utf-8)\n  --extra-template-data EXTRA_TEMPLATE_DATA\n                        Extra template data for output models. Input is supposed to be a\n                        json/yaml file. For OpenAPI and Jsonschema the keys are the spec\n                        path of the object, or the name of the object if you want to apply\n                        the template data to multiple objects with the same name. If you are\n                        using another input file type (e.g. GraphQL), the key is the name of\n                        the object. The value is a dictionary of the template data to add.\n  --use-double-quotes   Model generated with double quotes. Single quotes or your black\n                        config skip_string_normalization value will be used without this\n                        option.\n  --wrap-string-literal\n                        Wrap string literal by using black `experimental-string-processing`\n                        option (require black 20.8b0 or later)\n\nOpenAPI-only options:\n  --include-path-parameters\n                        Include path parameters in generated parameter models in addition to\n                        query parameters (Only OpenAPI)\n  --openapi-scopes {schemas,paths,tags,parameters,webhooks} [{schemas,paths,tags,parameters,webhooks} ...]\n                        Scopes of OpenAPI model generation (default: schemas)\n  --read-only-write-only-model-type {request-response,all}\n                        Model generation for readOnly/writeOnly fields: ''request-response'' =\n                        Request/Response models only (no base model), ''all'' = Base + Request\n                        + Response models.\n  --strict-nullable     Treat default field as a non-nullable field (Only OpenAPI)\n  --use-operation-id-as-name\n                        use operation id of OpenAPI as class names of models\n  --validation          Deprecated: Enable validation (Only OpenAPI). this option is\n                        deprecated. it will be removed in future releases\n\nGeneral options:\n  --check               Verify generated files are up-to-date without modifying them. Exits\n                        with code 1 if differences found, 0 if up-to-date. Useful for CI to\n                        ensure generated code is committed.\n  --debug               show debug message (require \"debug\". `$ pip install ''datamodel-code-\n                        generator[debug]''`)\n  --disable-warnings    disable warnings\n  --generate-cli-command\n                        Generate CLI command from pyproject.toml configuration and exit\n  --generate-pyproject-config\n                        Generate pyproject.toml configuration from the provided CLI\n                        arguments and exit\n  --ignore-pyproject    Ignore pyproject.toml configuration\n  --no-color            disable colorized output\n  --profile PROFILE     Use a named profile from pyproject.toml [tool.datamodel-\n                        codegen.profiles.&lt;name&gt;]\n  --version             show version\n  -h, --help            show this help message and exit\n</code></pre> <p>Click here to see supported input formats</p>"},{"location":"#related-projects","title":"Related projects","text":""},{"location":"#fastapi-code-generator","title":"fastapi-code-generator","text":"<p>This code generator creates FastAPI app from an openapi file.</p> <p>https://github.com/koxudaxi/fastapi-code-generator</p>"},{"location":"#pydantic-pycharm-plugin","title":"pydantic-pycharm-plugin","text":"<p>A JetBrains PyCharm plugin for <code>pydantic</code>.</p> <p>https://github.com/koxudaxi/pydantic-pycharm-plugin</p>"},{"location":"#pypi","title":"PyPi","text":"<p>https://pypi.org/project/datamodel-code-generator</p>"},{"location":"#license","title":"License","text":"<p>datamodel-code-generator is released under the MIT License. http://www.opensource.org/licenses/mit-license</p>"},{"location":"aliases/","title":"Field Aliases","text":"<p>The <code>--aliases</code> option allows you to rename fields in the generated models. This is useful when you want to use different Python field names than those defined in the schema while preserving the original names as serialization aliases.</p>"},{"location":"aliases/#basic-usage","title":"Basic Usage","text":"<pre><code>datamodel-codegen --input schema.json --output model.py --aliases aliases.json\n</code></pre>"},{"location":"aliases/#alias-file-format","title":"Alias File Format","text":"<p>The alias file is a JSON file that maps original field names to their Python aliases.</p>"},{"location":"aliases/#flat-format-traditional","title":"Flat Format (Traditional)","text":"<p>The simplest format applies aliases to all fields with the matching name, regardless of which class they belong to:</p> <pre><code>{\n  \"id\": \"id_\",\n  \"type\": \"type_\",\n  \"class\": \"class_\"\n}\n</code></pre> <p>This will rename all fields named <code>id</code> to <code>id_</code>, all fields named <code>type</code> to <code>type_</code>, etc.</p>"},{"location":"aliases/#scoped-format-class-specific","title":"Scoped Format (Class-Specific)","text":"<p>When you have the same field name in multiple classes but want different aliases for each, use the scoped format with <code>ClassName.field</code>:</p> <pre><code>{\n  \"User.name\": \"user_name\",\n  \"Address.name\": \"address_name\",\n  \"name\": \"default_name\"\n}\n</code></pre> <p>Priority: Scoped aliases take priority over flat aliases. In the example above: - <code>User.name</code> will be renamed to <code>user_name</code> - <code>Address.name</code> will be renamed to <code>address_name</code> - Any other class with a <code>name</code> field will use <code>default_name</code></p>"},{"location":"aliases/#example","title":"Example","text":""},{"location":"aliases/#input-schema","title":"Input Schema","text":"<pre><code>{\n  \"type\": \"object\",\n  \"title\": \"Root\",\n  \"properties\": {\n    \"name\": {\"type\": \"string\"},\n    \"user\": {\n      \"type\": \"object\",\n      \"title\": \"User\",\n      \"properties\": {\n        \"name\": {\"type\": \"string\"},\n        \"id\": {\"type\": \"integer\"}\n      }\n    },\n    \"address\": {\n      \"type\": \"object\",\n      \"title\": \"Address\",\n      \"properties\": {\n        \"name\": {\"type\": \"string\"},\n        \"city\": {\"type\": \"string\"}\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"aliases/#alias-file","title":"Alias File","text":"<pre><code>{\n  \"Root.name\": \"root_name\",\n  \"User.name\": \"user_name\",\n  \"Address.name\": \"address_name\"\n}\n</code></pre>"},{"location":"aliases/#generated-output","title":"Generated Output","text":"<pre><code>from pydantic import BaseModel, Field\n\nclass User(BaseModel):\n    user_name: str | None = Field(None, alias='name')\n    id: int | None = None\n\nclass Address(BaseModel):\n    address_name: str | None = Field(None, alias='name')\n    city: str | None = None\n\nclass Root(BaseModel):\n    root_name: str | None = Field(None, alias='name')\n    user: User | None = None\n    address: Address | None = None\n</code></pre>"},{"location":"aliases/#notes","title":"Notes","text":"<ul> <li>The <code>ClassName</code> in scoped format must match the generated Python class name (after title conversion)</li> <li>When using <code>--use-title-as-name</code>, the class name is derived from the <code>title</code> property in the schema</li> <li>Aliases are applied during code generation, so the original field names are preserved as Pydantic <code>alias</code> values for proper serialization/deserialization</li> </ul>"},{"location":"custom-formatters/","title":"Custom Code Formatters","text":"<p>New features of the <code>datamodel-code-generator</code> it is custom code formatters.</p>"},{"location":"custom-formatters/#usage","title":"Usage","text":"<p>To use the <code>--custom-formatters</code> option, you'll need to pass the module with your formatter. For example</p> <p>your_module.py <pre><code>from datamodel_code_generator.format import CustomCodeFormatter\n\nclass CodeFormatter(CustomCodeFormatter):\n    def apply(self, code: str) -&gt; str:\n        # processed code\n        return ...       \n</code></pre></p> <p>and run the following command</p> <pre><code>$ datamodel-codegen --input {your_input_file} --output {your_output_file} --custom-formatters \"{path_to_your_module}.your_module\"\n</code></pre>"},{"location":"custom_template/","title":"Custom Templates","text":"<p>One of the powerful features of the <code>datamodel-code-generator</code> is the ability to use custom templates with the <code>--custom-template-dir</code> option. This option allows you to provide a directory containing Jinja2 templates for customizing the generated code. In this document, we'll explore how to use this option and provide an example to help you understand its usage.</p>"},{"location":"custom_template/#usage","title":"Usage","text":"<p>To use the <code>--custom-template-dir</code> option, you'll need to pass the directory path containing your custom templates as an argument. The command will look like this:</p> <p><pre><code>$ datamodel-codegen --input {your_input_file} --output {your_output_file} --custom-template-dir {your_custom_template_directory}\n</code></pre> Replace {your_input_file}, {your_output_file}, and {your_custom_template_directory} with the appropriate paths.</p>"},{"location":"custom_template/#example","title":"Example","text":"<p>Let's say you want to generate a custom Python data model from a JSON Schema file called person.json. You want the generated data model to include a custom comment at the top of the file. To achieve this, you can create a custom template using Jinja2.</p> <p>First, create a directory called <code>custom_templates</code> in your project directory. Inside this folder, create another folder called pydantic. Now, inside the <code>pydantic</code> folder, create a new file called <code>BaseModel.jinja2</code> with the following content:</p> <p>custom_templates/pydantic/BaseModel.jinja2 <pre><code># This is a custom comment generated with custom_template!!\n\nclass {{ class_name }}({{ base_class }}):\n{%- for field in fields %}\n    {{ field.name }}: {{ field.type_hint }}\n{%- endfor -%}\n</code></pre></p> <p>This custom template includes the custom comment at the top and replicates the default rendering behavior of the BaseModel.jinja2 template from the Datamodel Code Generator.</p> <p>Now, you can use the --custom-template-dir option to generate the data model with your custom template: <pre><code>$ datamodel-codegen --input person.json --output person.py --custom-template-dir custom_templates\n</code></pre></p> <p>The generated <code>person.py</code> file will now include your custom comment at the top:</p> <p>person.py <pre><code># generated by datamodel-codegen:\n#   filename:  person.json\n#   timestamp: 2023-04-09T05:36:24+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n# This is a custom comment generated with custom_template!!\n\n\nclass Model(BaseModel):\n    name: Optional[str]\n    age: Optional[int]\n</code></pre></p> <p>In this example, we kept it simple, but you can create more complex custom templates by copying the default templates Use the default templates as a reference for understanding the structure and available variables, and customize the code generation process according to your specific requirements.</p>"},{"location":"development-contributing/","title":"Development","text":"<p>Install the package in editable mode:</p> <pre><code>$ git clone git@github.com:koxudaxi/datamodel-code-generator.git\n$ pip install -e datamodel-code-generator\n</code></pre>"},{"location":"development-contributing/#contribute","title":"Contribute","text":"<p>We are waiting for your contributions to <code>datamodel-code-generator</code>.</p>"},{"location":"development-contributing/#how-to-contribute","title":"How to contribute","text":"<pre><code>## 1. Clone your fork repository\n$ git clone git@github.com:&lt;your username&gt;/datamodel-code-generator.git\n$ cd datamodel-code-generator\n\n## 2. Install [uv](https://docs.astral.sh/uv/getting-started/installation/)\n$ curl -LsSf https://astral.sh/uv/install.sh | sh\n\n## 3. Install tox with uv\n$ uv tool install --python-preference only-managed --python 3.13 tox --with tox-uv\n\n## 3. Create developer environment\n$ tox run -e dev\n\n.tox/dev is a Python environment you can use for development purposes\n\n## 4. Create new branch and rewrite code.\n$ git checkout -b new-branch\n\n## 5. Run unittest under Python 3.13 (you should pass all test and coverage should be 100%)\n$ tox run -e 3.13\n\n## 7. Format and lint code (will print errors that cannot be automatically fixed)\n$ tox run -e fix\n\n## 8. Commit and Push...\n</code></pre>"},{"location":"field-constraints/","title":"Field Constraints","text":"<p>An option <code>--field-constraints</code> converts all con* annotations to Field constraint options.</p> <p>Mypy may show error for <code>con*</code> annotations on fields. The option resolves the problem.</p>"},{"location":"field-constraints/#example","title":"Example","text":"<p>Convert simple JSON Schema <code>model.json</code> to pydantic model <code>model.py</code></p> <p>Input JSON Schema</p> <p><code>model.json</code> <pre><code>{\n  \"type\":  \"object\",\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\",\n      \"maxLength\": 64\n    }\n  },\n  \"required\": [\"name\"]\n}\n</code></pre></p>"},{"location":"field-constraints/#without-field-constraints-option","title":"Without <code>--field-constraints</code> option","text":"<pre><code>$ datamodel-codegen --input a.json --input-file-type jsonschema &gt; model.py \n</code></pre> <p>Generated Model</p> <p><code>model.py</code> <pre><code># generated by datamodel-codegen:\n#   filename:  model.json\n#   timestamp: 2020-07-20T15:37:56+00:00\n\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel, constr\n\n\nclass  Model(BaseModel):\n  name: constr(max_length=64)\n</code></pre></p> <p>Run mypy... <pre><code>$ mypy model.py \nmodel.py:3: error: Invalid type comment or annotation\nmodel.py:3: note: Suggestion: use constr[...] instead of constr(...)\nFound 1 error in 1 file (checked 1 source file)\n</code></pre> mypy show errors...</p>"},{"location":"field-constraints/#with-field-constraints-option","title":"With <code>--field-constraints</code> option","text":"<pre><code>$ datamodel-codegen --input model.json --input-file-type jsonschema --field-constraints &gt; model.py \n</code></pre> <p>Generated Model</p> <p><code>model.py</code> <pre><code># generated by datamodel-codegen:\n#   filename:  model.json\n#   timestamp: 2020-07-20T15:47:21+00:00\n\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    name: str = Field(..., max_length=64)\n</code></pre></p> <p>Run mypy... <pre><code>$ mypy model.py \nSuccess: no issues found in 1 source file\n</code></pre></p>"},{"location":"field-constraints/#related-issues","title":"Related issues","text":"<p>https://github.com/samuelcolvin/pydantic/issues/156</p>"},{"location":"formatting/","title":"Formatting","text":"<p>Code generated by <code>datamodel-codegen</code> will be passed through <code>isort</code> and <code>black</code> to produce consistent, well-formatted results. Settings for these tools can be specified in <code>pyproject.toml</code> (located in the output directory, or in some parent of the output directory). Also for black you can disable  skip-string-normalization with using datamodel-codegen option <code>--use-double-quotes</code>,  it will override your black config skip-string-normalization value. Using --use-double-quotes may be useful if you can't use black config. </p>"},{"location":"formatting/#example","title":"Example","text":"<p>pyproject.toml <pre><code>[tool.black]\nskip-string-normalization = true\nline-length = 100\n\n[tool.isort]\nmulti_line_output = 3\ninclude_trailing_comma = true\nforce_grid_wrap = 0\nuse_parentheses = true\nline_length = 100\nknown_first_party = \"kelvin\"\n</code></pre></p> <p>See the Black Project for more information.</p>"},{"location":"graphql/","title":"Generate from GraphQL","text":"<p>The code generator can create pydantic models from GraphQL schema definitions.</p>"},{"location":"graphql/#simple-example","title":"Simple example","text":"<pre><code>$ datamodel-codegen --input schema.graphql --input-file-type graphql --output model.py\n</code></pre> <p>Let's consider a simple GraphQL schema (more details in https://graphql.org/learn/schema/).</p> <p>schema.graphql <pre><code>type Book {\n  id: ID!  \n  title: String\n  author: Author\n}\n\ntype Author {\n  id: ID!  \n  name: String\n  books: [Book]\n}\n\ninput BooksInput {\n    ids: [ID!]!\n}\n\ninput AuthorBooksInput {\n    id: ID!\n}\n\ntype Query {\n  getBooks(input: BooksInput): [Book]\n  getAuthorBooks(input: AuthorBooksInput): [Book]\n}\n</code></pre></p> <p>model.py <pre><code># generated by datamodel-codegen:\n#   filename:  schema.graphql\n#   timestamp: 2023-11-20T17:04:42+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional, TypeAlias\n\nfrom pydantic import BaseModel, Field\nfrom typing_extensions import Literal\n\n# The `Boolean` scalar type represents `true` or `false`.\nBoolean: TypeAlias = bool\n\n\n# The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `\"4\"`) or integer (such as `4`) input value will be accepted as an ID.\nID: TypeAlias = str\n\n\n# The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\nString: TypeAlias = str\n\n\nclass Author(BaseModel):\n    books: Optional[List[Optional[Book]]] = Field(default_factory=list)\n    id: ID\n    name: Optional[String] = None\n    typename__: Optional[Literal['Author']] = Field('Author', alias='__typename')\n\n\nclass Book(BaseModel):\n    author: Optional[Author] = None\n    id: ID\n    title: Optional[String] = None\n    typename__: Optional[Literal['Book']] = Field('Book', alias='__typename')\n\n\nclass AuthorBooksInput(BaseModel):\n    id: ID\n    typename__: Optional[Literal['AuthorBooksInput']] = Field(\n        'AuthorBooksInput', alias='__typename'\n    )\n\n\nclass BooksInput(BaseModel):\n    ids: List[ID]\n    typename__: Optional[Literal['BooksInput']] = Field(\n        'BooksInput', alias='__typename'\n    )\n</code></pre></p>"},{"location":"graphql/#response-deserialization","title":"Response deserialization","text":"<p>For the following response of <code>getAuthorBooks</code> GraphQL query  </p> <p>response.json <pre><code>{\n  \"getAuthorBooks\": [\n    {\n      \"author\": {\n        \"id\": \"51341cdscwef14r13\",\n        \"name\": \"J. K. Rowling\"\n      },\n      \"id\": \"1321dfvrt211wdw\",\n      \"title\": \"Harry Potter and the Prisoner of Azkaban\"\n    },\n    {\n      \"author\": {\n        \"id\": \"51341cdscwef14r13\",\n        \"name\": \"J. K. Rowling\"\n      },\n      \"id\": \"dvsmu12e19xmqacqw9\",\n      \"title\": \"Fantastic Beasts: The Crimes of Grindelwald\"\n    }\n  ]\n}\n</code></pre></p> <p>main.py <pre><code>from model import Book\n\nresponse = {...}\n\nbooks = [\n    Book.parse_obj(book_raw) for book_raw in response[\"getAuthorBooks\"]\n]\nprint(books)\n# [Book(author=Author(books=[], id='51341cdscwef14r13', name='J. K. Rowling', typename__='Author'), id='1321dfvrt211wdw', title='Harry Potter and the Prisoner of Azkaban', typename__='Book'), Book(author=Author(books=[], id='51341cdscwef14r13', name='J. K. Rowling', typename__='Author'), id='dvsmu12e19xmqacqw9', title='Fantastic Beasts: The Crimes of Grindelwald', typename__='Book')]\n</code></pre></p>"},{"location":"graphql/#custom-scalar-types","title":"Custom scalar types","text":"<pre><code>$ datamodel-codegen --input schema.graphql --input-file-type graphql --output model.py --extra-template-data data.json\n</code></pre> <p>schema.graphql <pre><code>scalar Long\n\ntype A {\n  id: ID!\n  duration: Long!\n}\n</code></pre></p> <p>data.json <pre><code>{\n  \"Long\": {\n    \"py_type\": \"int\"\n  }\n}\n</code></pre></p> <p>model.py <pre><code># generated by datamodel-codegen:\n#   filename:  custom-scalar-types.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional, TypeAlias\n\nfrom pydantic import BaseModel, Field\nfrom typing_extensions import Literal\n\n# The `Boolean` scalar type represents `true` or `false`.\nBoolean: TypeAlias = bool\n\n\n# The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `\"4\"`) or integer (such as `4`) input value will be accepted as an ID.\nID: TypeAlias = str\n\n\nLong: TypeAlias = int\n\n\n# The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\nString: TypeAlias = str\n\n\nclass A(BaseModel):\n    duration: Long\n    id: ID\n    typename__: Optional[Literal['A']] = Field('A', alias='__typename')\n</code></pre></p>"},{"location":"jsondata/","title":"Generate from JSON Data","text":"<p>This code generator can create pydantic models from JSON Data. Under the hood, the generator uses GenSON to create JSON Schema from your input. The generated schema is then processed the in the same manner as JSON Schema input data.</p>"},{"location":"jsondata/#example","title":"Example","text":"<pre><code>$ datamodel-codegen  --input pets.json --input-file-type json --output model.py\n</code></pre> <p>pets.json <pre><code>{\n  \"pets\": [\n    {\n      \"name\": \"dog\",\n      \"age\": 2\n    },\n    {\n      \"name\": \"cat\",\n      \"age\": 1\n    },\n    {\n      \"name\": \"snake\",\n      \"age\": 3,\n      \"nickname\": \"python\"\n    }\n  ],\n  \"status\": 200\n}\n</code></pre></p> <p>model.py <pre><code># generated by datamodel-codegen:\n#   filename:  pets.json\n#   timestamp: 2020-04-27T16:08:21+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    name: str\n    age: int\n    nickname: Optional[str] = None\n\n\nclass Model(BaseModel):\n    pets: List[Pet]\n    status: int\n</code></pre></p>"},{"location":"jsonschema/","title":"Generate from JSON Schema","text":"<p>The code generator can create pydantic models from JSON Schema. See more information about supported JSON Schema data types and features here.</p>"},{"location":"jsonschema/#example","title":"Example","text":"<pre><code>$ datamodel-codegen  --input person.json --input-file-type jsonschema --output model.py\n</code></pre> <p>person.json <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Person\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"firstName\": {\n      \"type\": \"string\",\n      \"description\": \"The person's first name.\"\n    },\n    \"lastName\": {\n      \"type\": \"string\",\n      \"description\": \"The person's last name.\"\n    },\n    \"age\": {\n      \"description\": \"Age in years which must be equal to or greater than zero.\",\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"friends\": {\n      \"type\": \"array\"\n    },\n    \"comment\": {\n      \"type\": \"null\"\n    }\n  }\n}\n</code></pre></p> <p>model.py <pre><code># generated by datamodel-codegen:\n#   filename:  person.json\n#   timestamp: 2020-04-27T16:12:27+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Any, List, Optional\n\nfrom pydantic import BaseModel, Field, conint\n\n\nclass Person(BaseModel):\n    firstName: Optional[str] = Field(None, description=\"The person's first name.\")\n    lastName: Optional[str] = Field(None, description=\"The person's last name.\")\n    age: Optional[conint(ge=0)] = Field(\n        None, description='Age in years which must be equal to or greater than zero.'\n    )\n    friends: Optional[List] = None\n    comment: Optional[Any] = None\n</code></pre></p>"},{"location":"openapi/","title":"Generate from OpenAPI","text":"<p>The code generator can create pydantic models from OpenAPI schema definitions, particularly using the data from the <code>schema</code> field.</p>"},{"location":"openapi/#example","title":"Example","text":"<pre><code>$ datamodel-codegen --input api.yaml --input-file-type openapi --output model.py\n</code></pre> api.yaml <pre>\n<code>\n<pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Error:\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n</code></pre>\n</code>\n</pre> <p>model.py <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2020-06-02T05:28:24+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n</code></pre></p>"},{"location":"openapi/#readonly-writeonly-properties","title":"readOnly / writeOnly Properties","text":"<p>OpenAPI 3.x supports <code>readOnly</code> and <code>writeOnly</code> property annotations:</p> <ul> <li>readOnly: Property is only returned in responses (e.g., <code>id</code>, <code>created_at</code>)</li> <li>writeOnly: Property is only sent in requests (e.g., <code>password</code>)</li> </ul>"},{"location":"openapi/#option-read-only-write-only-model-type","title":"Option: <code>--read-only-write-only-model-type</code>","text":"<p>This option generates separate Request/Response models based on these annotations.</p> Value Description (not set) Default. No special handling (backward compatible) <code>request-response</code> Generate only Request/Response models (no base model) <code>all</code> Generate base model + Request + Response models"},{"location":"openapi/#example-schema","title":"Example Schema","text":"<pre><code>openapi: \"3.0.0\"\ninfo:\n  title: User API\n  version: \"1.0\"\npaths: {}\ncomponents:\n  schemas:\n    User:\n      type: object\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          readOnly: true      # Server-generated, not in requests\n        name:\n          type: string\n        password:\n          type: string\n          writeOnly: true     # Client-only, not in responses\n        created_at:\n          type: string\n          format: date-time\n          readOnly: true\n</code></pre>"},{"location":"openapi/#generated-output","title":"Generated Output","text":"<pre><code>$ datamodel-codegen --input user.yaml --input-file-type openapi \\\n    --output-model-type pydantic_v2.BaseModel \\\n    --read-only-write-only-model-type all\n</code></pre> <pre><code>from pydantic import BaseModel\nfrom typing import Optional\nfrom datetime import datetime\n\n# Request model: excludes readOnly fields (id, created_at)\nclass UserRequest(BaseModel):\n    name: str\n    password: Optional[str] = None\n\n# Response model: excludes writeOnly fields (password)\nclass UserResponse(BaseModel):\n    id: int\n    name: str\n    created_at: Optional[datetime] = None\n\n# Base model: contains all fields\nclass User(BaseModel):\n    id: int\n    name: str\n    password: Optional[str] = None\n    created_at: Optional[datetime] = None\n</code></pre>"},{"location":"openapi/#usage-patterns","title":"Usage Patterns","text":"Use Case Recommended Option Generated Models API client validation <code>request-response</code> <code>UserRequest</code>, <code>UserResponse</code> Database ORM mapping (not set) <code>User</code> Both client &amp; ORM <code>all</code> <code>User</code>, <code>UserRequest</code>, <code>UserResponse</code>"},{"location":"openapi/#behavior-with-allof-inheritance","title":"Behavior with allOf Inheritance","text":"<p>When using <code>allOf</code> with <code>$ref</code>, fields from all referenced schemas are flattened into Request/Response models:</p> <pre><code>components:\n  schemas:\n    Timestamps:\n      type: object\n      properties:\n        created_at:\n          type: string\n          format: date-time\n          readOnly: true\n\n    User:\n      allOf:\n        - $ref: \"#/components/schemas/Timestamps\"\n        - type: object\n          properties:\n            name:\n              type: string\n</code></pre> <p>Generated <code>UserRequest</code> will exclude <code>created_at</code> (readOnly from Timestamps).</p>"},{"location":"openapi/#collision-handling","title":"Collision Handling","text":"<p>If a schema named <code>UserRequest</code> or <code>UserResponse</code> already exists, the generated model will be named <code>UserRequestModel</code> or <code>UserResponseModel</code> to avoid conflicts.</p>"},{"location":"openapi/#supported-output-formats","title":"Supported Output Formats","text":"<p>This option works with all output formats:</p> <ul> <li><code>pydantic.BaseModel</code> / <code>pydantic_v2.BaseModel</code></li> <li><code>dataclasses.dataclass</code></li> <li><code>typing.TypedDict</code></li> <li><code>msgspec.Struct</code></li> </ul>"},{"location":"openapi/#supported-ref-types","title":"Supported $ref Types","text":"<p>readOnly/writeOnly resolution works with local and file reference types:</p> Reference Type Example Support Local <code>#/components/schemas/User</code> \u2705 File <code>./common.yaml#/User</code> \u2705"},{"location":"pyproject_toml/","title":"pyproject.toml Configuration","text":"<p>datamodel-code-generator can be configured using <code>pyproject.toml</code>. The tool automatically searches for <code>pyproject.toml</code> in the current directory and parent directories (stopping at the git repository root).</p>"},{"location":"pyproject_toml/#basic-usage","title":"Basic Usage","text":"<pre><code>[tool.datamodel-codegen]\ninput = \"schema.yaml\"\noutput = \"models.py\"\ntarget-python-version = \"3.11\"\nsnake-case-field = true\nfield-constraints = true\n</code></pre> <p>All CLI options can be used in <code>pyproject.toml</code> by converting them to kebab-case (e.g., <code>--snake-case-field</code> becomes <code>snake-case-field</code>).</p>"},{"location":"pyproject_toml/#named-profiles","title":"Named Profiles","text":"<p>You can define multiple named profiles for different use cases within a single project:</p> <pre><code>[tool.datamodel-codegen]\ntarget-python-version = \"3.9\"\nsnake-case-field = true\n\n[tool.datamodel-codegen.profiles.api]\ninput = \"schemas/api.yaml\"\noutput = \"src/models/api.py\"\ntarget-python-version = \"3.11\"\n\n[tool.datamodel-codegen.profiles.database]\ninput = \"schemas/db.json\"\noutput = \"src/models/db.py\"\ninput-file-type = \"jsonschema\"\n</code></pre> <p>Base settings in <code>[tool.datamodel-codegen]</code> are used when no profile is specified, and also serve as defaults for profiles.</p> <p>Use a profile with the <code>--profile</code> option:</p> <pre><code>datamodel-codegen --profile api\ndatamodel-codegen --profile database\n</code></pre>"},{"location":"pyproject_toml/#configuration-priority","title":"Configuration Priority","text":"<p>Settings are applied in the following priority order (highest to lowest):</p> <ol> <li>CLI arguments - Always take precedence</li> <li>Profile settings - From <code>[tool.datamodel-codegen.profiles.&lt;name&gt;]</code></li> <li>Base settings - From <code>[tool.datamodel-codegen]</code></li> <li>Default values - Built-in defaults</li> </ol>"},{"location":"pyproject_toml/#merge-rules","title":"Merge Rules","text":"<p>When using profiles, settings are merged using shallow merge:</p> <ul> <li>Profile values completely replace base values (no deep merging)</li> <li>Settings not specified in the profile are inherited from the base configuration</li> <li>Lists and dictionaries are replaced entirely, not merged</li> </ul>"},{"location":"pyproject_toml/#example","title":"Example","text":"<pre><code>[tool.datamodel-codegen]\nstrict-types = [\"str\", \"int\"]\nhttp-headers = [\"Authorization: Bearer token\"]\n\n[tool.datamodel-codegen.profiles.api]\nstrict-types = [\"bytes\"]\n</code></pre> <p>When using <code>--profile api</code>:</p> <ul> <li><code>strict-types</code> becomes <code>[\"bytes\"]</code> (completely replaces base, not merged)</li> <li><code>http-headers</code> is inherited from base as <code>[\"Authorization: Bearer token\"]</code></li> </ul>"},{"location":"pyproject_toml/#ignoring-pyprojecttoml","title":"Ignoring pyproject.toml","text":"<p>To ignore all <code>pyproject.toml</code> configuration and use only CLI arguments:</p> <pre><code>datamodel-codegen --ignore-pyproject --input schema.yaml --output models.py\n</code></pre>"},{"location":"pyproject_toml/#generating-configuration","title":"Generating Configuration","text":"<p>Generate a <code>pyproject.toml</code> configuration section from CLI arguments:</p> <pre><code>datamodel-codegen --input schema.yaml --output models.py --snake-case-field --generate-pyproject-config\n</code></pre> <p>Output:</p> <pre><code>[tool.datamodel-codegen]\ninput = \"schema.yaml\"\noutput = \"models.py\"\nsnake-case-field = true\n</code></pre> <p>Generate CLI command from existing <code>pyproject.toml</code>:</p> <pre><code>datamodel-codegen --generate-cli-command\n</code></pre> <p>With a specific profile:</p> <pre><code>datamodel-codegen --profile api --generate-cli-command\n</code></pre>"},{"location":"root-model-and-type-alias/","title":"Root Models and Type Aliases","text":"<p>When a schema defines a simple type (not an object with properties), <code>datamodel-code-generator</code> creates a root model. If you don't want to introduce a new level of attribute access (<code>.root</code>) or want to use generated types as plain Python types in non-Pydantic code, you can use the <code>--use-type-alias</code> flag to generate type aliases instead of root models.</p>"},{"location":"root-model-and-type-alias/#warning-notes-and-limitations","title":":warning: Notes and limitations","text":"<p>This functionality experimental! Here are a few known issues: - RootModel and type aliases do not fully support field-specific metadata (default, alias, etc). See https://docs.pydantic.dev/latest/concepts/types/#named-type-aliases for details. - Type aliases do not support some RootModel features (e.g. <code>model_config</code>) - A RootModel or type alias is also generated for the main schema, allowing you to define a single type alias from a schema file (e.g. <code>model.json</code> containing <code>{\"title\": \"MyString\", \"type\": \"string\"}</code>) - Type aliases cannot be combined with <code>Annotated</code> for Pydantic v1</p>"},{"location":"root-model-and-type-alias/#type-alias-behavior-by-output-type-and-python-version","title":"Type Alias Behavior by Output Type and Python Version","text":"<p>The type of type alias generated depends on the output model type and target Python version:</p> Output Type Python 3.12+ Python 3.10-3.11 Python 3.9 Pydantic v2 <code>type</code> statement <code>TypeAliasType</code> (typing_extensions) <code>TypeAliasType</code> (typing_extensions) Pydantic v1 <code>TypeAlias</code> <code>TypeAlias</code> <code>TypeAlias</code> (typing_extensions) TypedDict <code>type</code> statement <code>TypeAlias</code> <code>TypeAlias</code> (typing_extensions) dataclasses <code>type</code> statement <code>TypeAlias</code> <code>TypeAlias</code> (typing_extensions) msgspec <code>type</code> statement <code>TypeAlias</code> <code>TypeAlias</code> (typing_extensions) <p>Why the difference?</p> <ul> <li>Pydantic v2 requires <code>TypeAliasType</code> because it cannot properly handle <code>TypeAlias</code> annotations</li> <li>Other output types (TypedDict, dataclasses, msgspec) use <code>TypeAlias</code> for better compatibility with libraries that may not expect <code>TypeAliasType</code> objects</li> <li>Python 3.12+ uses the native <code>type</code> statement for all output types</li> </ul>"},{"location":"root-model-and-type-alias/#example","title":"Example","text":"<p>Input JSON Schema</p> <p><code>model.json</code> <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"definitions\": {\n    \"UserId\": {\n      \"type\": \"string\"\n    },\n    \"Status\": {\n      \"anyOf\": [\n        {\"type\": \"string\"},\n        {\"type\": \"integer\"}\n      ]\n    },\n    \"User\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"id\": {\"$ref\": \"#/definitions/UserId\"},\n        \"status\": {\"$ref\": \"#/definitions/Status\"}\n      }\n    }\n  }\n}\n</code></pre></p>"},{"location":"root-model-and-type-alias/#pydantic-v1","title":"Pydantic v1","text":""},{"location":"root-model-and-type-alias/#generating-rootmodel","title":"Generating RootModel","text":"<pre><code>$ datamodel-codegen --input model.json --input-file-type jsonschema --output model.py\n</code></pre> <p>Generated Model</p> <p><code>model.py</code> <pre><code># generated by datamodel-codegen:\n#   filename:  model.json\n\nfrom __future__ import annotations\n\nfrom typing import Any, Optional, Union\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    __root__: Any\n\n\nclass UserId(BaseModel):\n    __root__: str\n\n\nclass Status(BaseModel):\n    __root__: Union[str, int]\n\n\nclass User(BaseModel):\n    id: Optional[UserId] = None\n    status: Optional[Status] = None\n</code></pre></p>"},{"location":"root-model-and-type-alias/#generating-typealias-annotation","title":"Generating TypeAlias annotation","text":"<pre><code>$ datamodel-codegen --input model.json --input-file-type jsonschema --use-type-alias --output model.py\n</code></pre> <p>Generated Model (Python 3.10+)</p> <p><code>model.py</code> <pre><code># generated by datamodel-codegen:\n#   filename:  model.json\n\nfrom __future__ import annotations\n\nfrom typing import Any, Optional, TypeAlias, Union\n\nfrom pydantic import BaseModel\n\nModel: TypeAlias = Any\n\n\nUserId: TypeAlias = str\n\n\nStatus: TypeAlias = Union[str, int]\n\n\nclass User(BaseModel):\n    id: Optional[UserId] = None\n    status: Optional[Status] = None\n</code></pre></p> <p>Generated Model (Python 3.9)</p> <p><code>model.py</code> <pre><code># generated by datamodel-codegen:\n#   filename:  model.json\n\nfrom __future__ import annotations\n\nfrom typing import Any, Optional, Union\n\nfrom pydantic import BaseModel\nfrom typing_extensions import TypeAlias\n\nModel: TypeAlias = Any\n\n\nUserId: TypeAlias = str\n\n\nStatus: TypeAlias = Union[str, int]\n\n\nclass User(BaseModel):\n    id: Optional[UserId] = None\n    status: Optional[Status] = None\n</code></pre></p>"},{"location":"root-model-and-type-alias/#pydantic-v2","title":"Pydantic v2","text":""},{"location":"root-model-and-type-alias/#generating-rootmodel_1","title":"Generating RootModel","text":"<pre><code>$ datamodel-codegen --input model.json --input-file-type jsonschema --output-model-type pydantic_v2.BaseModel --output model.py\n</code></pre> <p>Generated Model</p> <p><code>model.py</code> <pre><code># generated by datamodel-codegen:\n#   filename:  model.json\n\nfrom __future__ import annotations\n\nfrom typing import Any, Optional, Union\n\nfrom pydantic import BaseModel, RootModel\n\n\nclass Model(RootModel[Any]):\n    root: Any\n\n\nclass UserId(RootModel[str]):\n    root: str\n\n\nclass Status(RootModel[Union[str, int]]):\n    root: Union[str, int]\n\n\nclass User(BaseModel):\n    id: Optional[UserId] = None\n    status: Optional[Status] = None\n</code></pre></p>"},{"location":"root-model-and-type-alias/#generating-typealiastype-python-39-311","title":"Generating TypeAliasType (Python 3.9-3.11)","text":"<pre><code>$ datamodel-codegen --input model.json --input-file-type jsonschema --output-model-type pydantic_v2.BaseModel --use-type-alias --output model.py\n</code></pre> <p>Generated Model</p> <p><code>model.py</code> <pre><code># generated by datamodel-codegen:\n#   filename:  model.json\n\nfrom __future__ import annotations\n\nfrom typing import Any, Optional, Union\n\nfrom pydantic import BaseModel\nfrom typing_extensions import TypeAliasType\n\nModel = TypeAliasType(\"Model\", Any)\n\n\nUserId = TypeAliasType(\"UserId\", str)\n\n\nStatus = TypeAliasType(\"Status\", Union[str, int])\n\n\nclass User(BaseModel):\n    id: Optional[UserId] = None\n    status: Optional[Status] = None\n</code></pre></p>"},{"location":"root-model-and-type-alias/#generating-type-statement-python-312","title":"Generating type statement (Python 3.12+)","text":"<pre><code>$ datamodel-codegen --input model.json --input-file-type jsonschema --output-model-type pydantic_v2.BaseModel --use-type-alias --target-python-version 3.12 --output model.py\n</code></pre> <p>Generated Model</p> <p><code>model.py</code> <pre><code># generated by datamodel-codegen:\n#   filename:  model.json\n\nfrom __future__ import annotations\n\nfrom typing import Any, Optional, Union\n\nfrom pydantic import BaseModel\n\ntype Model = Any\n\n\ntype UserId = str\n\n\ntype Status = Union[str, int]\n\n\nclass User(BaseModel):\n    id: Optional[UserId] = None\n    status: Optional[Status] = None\n</code></pre></p>"},{"location":"supported-data-types/","title":"Supported Input Formats","text":"<p>This code generator supports the following input formats:</p> <ul> <li>OpenAPI 3 (YAML/JSON, OpenAPI Data Type);</li> <li>JSON Schema (JSON Schema Core /JSON Schema Validation);</li> <li>JSON/YAML Data (it will be converted to JSON Schema);</li> <li>Python dictionary (it will be converted to JSON Schema);</li> <li>GraphQL schema (GraphQL Schemas and Types);</li> </ul>"},{"location":"supported-data-types/#implemented-data-types-and-features","title":"Implemented data types and features","text":"<p>Below are the data types and features recognized by datamodel-code-generator for OpenAPI 3 and JSON Schema.</p>"},{"location":"supported-data-types/#data-types","title":"Data Types","text":"<ul> <li>string (supported keywords: pattern/minLength/maxLength)</li> <li>number (supported keywords: maximum/exclusiveMaximum/minimum/exclusiveMinimum/multipleOf)</li> <li>integer (supported keywords: maximum/exclusiveMaximum/minimum/exclusiveMinimum/multipleOf)</li> <li>boolean</li> <li>array</li> <li>object</li> </ul>"},{"location":"supported-data-types/#string-formats","title":"String Formats","text":"<ul> <li>date</li> <li>datetime</li> <li>time</li> <li>password</li> <li>email</li> <li>idn-email</li> <li>path</li> <li>uuid (uuid1/uuid2/uuid3/uuid4/uuid5)</li> <li>ipv4</li> <li>ipv6</li> <li>hostname</li> <li>decimal</li> <li>uri</li> </ul>"},{"location":"supported-data-types/#other-schema","title":"Other schema","text":"<ul> <li>enum (as enum.Enum or typing.Literal)</li> <li>allOf (as Multiple inheritance)</li> <li>anyOf (as typing.Union)</li> <li>oneOf (as typing.Union)</li> <li>$ref (http extra is required when resolving $ref for remote files.)</li> <li>$id (for JSONSchema)</li> </ul>"},{"location":"using_as_module/","title":"Using datamode-code-generator as a Module","text":"<p>datamodel-code-generator is a CLI tool, but it can also be used as a module.</p> <p>You can call this code-generator in your python code.</p>"},{"location":"using_as_module/#how-to-use-it-as-module","title":"How to use it as module","text":"<p>You can generate models with <code>datamodel_code_generator.generate</code> using parameters that match the arguments provided to the CLI tool. The generated files can be written to and read from the <code>Path</code> object supplied to output.</p> <p>In the below example, we use a file in a <code>TemporaryDirectory</code> to store our output.</p>"},{"location":"using_as_module/#installation","title":"Installation","text":"<pre><code>pip install 'datamodel-code-generator[http]'\n</code></pre>"},{"location":"using_as_module/#example","title":"Example","text":"<pre><code>from pathlib import Path\nfrom tempfile import TemporaryDirectory\nfrom datamodel_code_generator import InputFileType, generate\nfrom datamodel_code_generator import DataModelType\n\njson_schema: str = \"\"\"{\n    \"type\": \"object\",\n    \"properties\": {\n        \"number\": {\"type\": \"number\"},\n        \"street_name\": {\"type\": \"string\"},\n        \"street_type\": {\"type\": \"string\",\n                        \"enum\": [\"Street\", \"Avenue\", \"Boulevard\"]\n                        }\n    }\n}\"\"\"\n\nwith TemporaryDirectory() as temporary_directory_name:\n    temporary_directory = Path(temporary_directory_name)\n    output = Path(temporary_directory / 'model.py')\n    generate(\n        json_schema,\n        input_file_type=InputFileType.JsonSchema,\n        input_filename=\"example.json\",\n        output=output,\n        # set up the output model types\n        output_model_type=DataModelType.PydanticV2BaseModel,\n    )\n    model: str = output.read_text()\nprint(model)\n</code></pre> <p>The result of <code>print(model)</code>: <pre><code># generated by datamodel-codegen:\n#   filename:  example.json\n#   timestamp: 2020-12-21T08:01:06+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass StreetType(Enum):\n    Street = 'Street'\n    Avenue = 'Avenue'\n    Boulevard = 'Boulevard'\n\n\nclass Model(BaseModel):\n    number: Optional[float] = None\n    street_name: Optional[str] = None\n    street_type: Optional[StreetType] = None\n</code></pre></p> <p>Also, you can call parser directly</p> <pre><code>from datamodel_code_generator import DataModelType, PythonVersion\nfrom datamodel_code_generator.model import get_data_model_types\nfrom datamodel_code_generator.parser.jsonschema import JsonSchemaParser\n\njson_schema: str = \"\"\"{\n    \"type\": \"object\",\n    \"properties\": {\n        \"number\": {\"type\": \"number\"},\n        \"street_name\": {\"type\": \"string\"},\n        \"street_type\": {\"type\": \"string\",\n                        \"enum\": [\"Street\", \"Avenue\", \"Boulevard\"]\n                        }\n    }\n}\"\"\"\n\n\ndata_model_types = get_data_model_types(\n    DataModelType.PydanticV2BaseModel,\n    target_python_version=PythonVersion.PY_311\n)\nparser = JsonSchemaParser(\n   json_schema,\n   data_model_type=data_model_types.data_model,\n   data_model_root_type=data_model_types.root_model,\n   data_model_field_type=data_model_types.field_model,\n   data_type_manager_type=data_model_types.data_type_manager,\n   dump_resolve_reference_action=data_model_types.dump_resolve_reference_action,\n                       )\nresult = parser.parse()\nprint(result)\n ```\n\nThe result of `print(model)`:\n```python\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass StreetType(Enum):\n    Street = 'Street'\n    Avenue = 'Avenue'\n    Boulevard = 'Boulevard'\n\n\nclass Model(BaseModel):\n    number: Optional[float] = None\n    street_name: Optional[str] = None\n    street_type: Optional[StreetType] = None\n</code></pre>"},{"location":"using_as_module/#why-doesnt-datamodel_code_generatorgenerate-return-a-string","title":"Why doesn't <code>datamodel_code_generator.generate</code> return a string?","text":"<p>The above example schema only generates a single python module, but a single schema may generate multiple modules. There is no way to represent these modules as a single string, so the <code>generate</code> method returns <code>None</code>.</p> <p>Note that the output parameter can take any <code>Path</code> object, which includes both file and directory paths. If a file name is provided and multiple modules are generated, <code>generate</code> will raise a <code>datamodel_code_gen.Error</code> exception.</p> <p>If multiple modules are generated, you will need to walk through the supplied output directory to find all of them.</p>"},{"location":"what_is_the_difference_between_v1_and_v2/","title":"What is the difference between pydantic v1 and v2 output model?","text":""},{"location":"what_is_the_difference_between_v1_and_v2/#summary","title":"Summary","text":"<p>datamodel-code-generator supports Pydantic v1 and v2 as output model type.</p> <p>Pydantic v2 is a major release with many breaking changes. See the migration guide for more information: https://docs.pydantic.dev/2.0/migration/</p>"},{"location":"what_is_the_difference_between_v1_and_v2/#whats-changes-in-v2-output","title":"What's changes in v2 output?","text":""},{"location":"what_is_the_difference_between_v1_and_v2/#__root__-field-aka-custom-root-types","title":"<code>__root__</code> field (a.k.a Custom Root Types)","text":"<p><code>__root__</code> field (a.k.a Custom Root Types) is removed in pydantic v2. The model is changed to RootModel</p>"},{"location":"what_is_the_difference_between_v1_and_v2/#pydanticfield","title":"pydantic.Field","text":"<p>https://docs.pydantic.dev/2.0/migration/#changes-to-pydanticfield</p> <ul> <li>const -&gt; removed</li> <li>min_items (use min_length instead)</li> <li>max_items (use max_length instead)</li> <li>unique_items -&gt; removed and the list type will be replaced by <code>typing.Set</code>. this feature is discussed in https://github.com/pydantic/pydantic-core/issues/296</li> <li>allow_mutation (use frozen instead)</li> <li>regex (use pattern instead)</li> </ul>"},{"location":"what_is_the_difference_between_v1_and_v2/#model-config","title":"Model Config","text":"<ul> <li><code>pydantic.Config</code> -&gt; <code>pydantic.ConfigDict</code> </li> <li>allow_mutation \u2014&gt; frozen (inverse value for getting same behavior).</li> <li>allow_population_by_field_name \u2192 populate_by_name</li> </ul>"}]}