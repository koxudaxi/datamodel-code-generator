{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"datamodel-code-generator","text":"<p>This code generator creates pydantic v1 and v2 model, dataclasses.dataclass, typing.TypedDict and msgspec.Struct from an openapi file and others.</p> <p> </p>"},{"location":"#quick-installation","title":"Quick Installation","text":"<p>To install <code>datamodel-code-generator</code>: <pre><code>$ pip install datamodel-code-generator\n</code></pre></p>"},{"location":"#simple-usage","title":"Simple Usage","text":"<p>You can generate models from a local file. <pre><code>$ datamodel-codegen --input api.yaml --output model.py\n</code></pre></p> api.yaml <pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Error:\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n</code></pre> model.py <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2020-06-02T05:28:24+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n</code></pre>"},{"location":"#supported-input-types","title":"Supported input types","text":"<ul> <li>OpenAPI 3 (YAML/JSON, OpenAPI Data Type);</li> <li>JSON Schema (JSON Schema Core/JSON Schema Validation);</li> <li>JSON/YAML/CSV Data (it will be converted to JSON Schema);</li> <li>Python dictionary (it will be converted to JSON Schema);</li> <li>GraphQL schema (GraphQL Schemas and Types);</li> </ul>"},{"location":"#supported-output-types","title":"Supported output types","text":"<ul> <li>pydantic.BaseModel;</li> <li>pydantic_v2.BaseModel;</li> <li>dataclasses.dataclass;</li> <li>typing.TypedDict;</li> <li>msgspec.Struct;</li> <li>Custom type from your jinja2 template;</li> </ul>"},{"location":"#sponsors","title":"Sponsors","text":"<p>JetBrains</p> <p>Astral</p>"},{"location":"#projects-that-use-datamodel-code-generator","title":"Projects that use datamodel-code-generator","text":"<p>These OSS projects use datamodel-code-generator to generate many models.  See the following linked projects for real world examples and inspiration.</p> <ul> <li>airbytehq/airbyte<ul> <li>code-generator/Dockerfile</li> </ul> </li> <li>apache/iceberg<ul> <li>Generate Python code <code>make generate</code></li> </ul> </li> <li>argoproj-labs/hera<ul> <li><code>Makefile</code></li> </ul> </li> <li>awslabs/aws-lambda-powertools-python<ul> <li>Recommended for advanced-use-cases in the official documentation</li> </ul> </li> <li>DataDog/integrations-core<ul> <li>Config models</li> </ul> </li> <li>hashintel/hash<ul> <li><code>codegen.sh</code></li> </ul> </li> <li>IBM/compliance-trestle<ul> <li>Building the models from the OSCAL schemas.</li> </ul> </li> <li>Netflix/consoleme<ul> <li>How do I generate models from the Swagger specification?</li> </ul> </li> <li>Nike-Inc/brickflow<ul> <li>Code generate tools<code>./tools/gen-bundle.sh</code></li> </ul> </li> <li>open-metadata/OpenMetadata<ul> <li>Makefile</li> </ul> </li> <li>PostHog/posthog<ul> <li>Generate models via <code>npm run</code> </li> </ul> </li> <li>SeldonIO/MLServer<ul> <li>generate-types.sh</li> </ul> </li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>To install <code>datamodel-code-generator</code>: <pre><code>$ pip install datamodel-code-generator\n</code></pre></p>"},{"location":"#http-extra-option","title":"<code>http</code> extra option","text":"<p>If you want to resolve <code>$ref</code> for remote files then you should specify <code>http</code> extra option. <pre><code>$ pip install 'datamodel-code-generator[http]'\n</code></pre></p>"},{"location":"#graphql-extra-option","title":"<code>graphql</code> extra option","text":"<p>If you want to generate data model from a GraphQL schema then you should specify <code>graphql</code> extra option. <pre><code>$ pip install 'datamodel-code-generator[graphql]'\n</code></pre></p>"},{"location":"#docker-image","title":"Docker Image","text":"<p>The docker image is in Docker Hub <pre><code>$ docker pull koxudaxi/datamodel-code-generator\n</code></pre></p>"},{"location":"#advanced-uses","title":"Advanced Uses","text":"<p>You can generate models from a URL. <pre><code>$ datamodel-codegen --url https://&lt;INPUT FILE URL&gt; --output model.py\n</code></pre> This method needs the http extra option</p>"},{"location":"#all-command-options","title":"All Command Options","text":"<p>The <code>datamodel-codegen</code> command:</p> <pre><code>usage: \n  datamodel-codegen [options]\n\nGenerate Python data models from schema definitions or structured data\n\nOptions:\n  --additional-imports ADDITIONAL_IMPORTS\n                        Custom imports for output (delimited list input). For example\n                        \"datetime.date,datetime.datetime\"\n  --custom-formatters CUSTOM_FORMATTERS\n                        List of modules with custom formatter (delimited list input).\n  --formatters {black,isort,ruff-check,ruff-format} [{black,isort,ruff-check,ruff-format} ...]\n                        Formatters for output (default: [black, isort])\n  --http-headers HTTP_HEADER [HTTP_HEADER ...]\n                        Set headers in HTTP requests to the remote host. (example:\n                        \"Authorization: Basic dXNlcjpwYXNz\")\n  --http-ignore-tls     Disable verification of the remote host''s TLS certificate\n  --http-query-parameters HTTP_QUERY_PARAMETERS [HTTP_QUERY_PARAMETERS ...]\n                        Set query parameters in HTTP requests to the remote host. (example:\n                        \"ref=branch\")\n  --input INPUT         Input file/directory (default: stdin)\n  --input-file-type {auto,openapi,jsonschema,json,yaml,dict,csv,graphql}\n                        Input file type (default: auto)\n  --output OUTPUT       Output file (default: stdout)\n  --output-model-type {pydantic.BaseModel,pydantic_v2.BaseModel,dataclasses.dataclass,typing.TypedDict,msgspec.Struct}\n                        Output model type (default: pydantic.BaseModel)\n  --url URL             Input file URL. `--input` is ignored when `--url` is used\n\nTyping customization:\n  --base-class BASE_CLASS\n                        Base Class (default: pydantic.BaseModel)\n  --disable-future-imports\n                        Disable __future__ imports\n  --enum-field-as-literal {all,one}\n                        Parse enum field as literal. all: all enum field type are Literal.\n                        one: field type is Literal when an enum has only one possible value\n  --field-constraints   Use field constraints and not con* annotations\n  --set-default-enum-member\n                        Set enum members as default values for enum field\n  --strict-types {str,bytes,int,float,bool} [{str,bytes,int,float,bool} ...]\n                        Use strict types\n  --use-annotated       Use typing.Annotated for Field(). Also, `--field-constraints` option\n                        will be enabled.\n  --use-generic-container-types\n                        Use generic container types for type hinting (typing.Sequence,\n                        typing.Mapping). If `--use-standard-collections` option is set, then\n                        import from collections.abc instead of typing\n  --use-non-positive-negative-number-constrained-types\n                        Use the Non{Positive,Negative}{FloatInt} types instead of the\n                        corresponding con* constrained types.\n  --use-one-literal-as-default\n                        Use one literal as default value for one literal field\n  --use-standard-collections\n                        Use standard collections for type hinting (list, dict)\n  --use-subclass-enum   Define Enum class as subclass with field type when enum has type\n                        (int, float, bytes, str)\n  --use-union-operator  Use | operator for Union type (PEP 604).\n  --use-unique-items-as-set\n                        define field type as `set` when the field attribute has\n                        `uniqueItems`\n\nField customization:\n  --capitalise-enum-members, --capitalize-enum-members\n                        Capitalize field names on enum\n  --empty-enum-field-name EMPTY_ENUM_FIELD_NAME\n                        Set field name when enum value is empty (default: `_`)\n  --field-extra-keys FIELD_EXTRA_KEYS [FIELD_EXTRA_KEYS ...]\n                        Add extra keys to field parameters\n  --field-extra-keys-without-x-prefix FIELD_EXTRA_KEYS_WITHOUT_X_PREFIX [FIELD_EXTRA_KEYS_WITHOUT_X_PREFIX ...]\n                        Add extra keys with `x-` prefix to field parameters. The extra keys\n                        are stripped of the `x-` prefix.\n  --field-include-all-keys\n                        Add all keys to field parameters\n  --force-optional      Force optional for required fields\n  --no-alias            Do not add a field alias. E.g., if --snake-case-field is used along\n                        with a base class, which has an alias_generator\n  --original-field-name-delimiter ORIGINAL_FIELD_NAME_DELIMITER\n                        Set delimiter to convert to snake case. This option only can be used\n                        with --snake-case-field (default: `_` )\n  --remove-special-field-name-prefix\n                        Remove field name prefix if it has a special meaning e.g.\n                        underscores\n  --snake-case-field    Change camel-case field name to snake-case\n  --special-field-name-prefix SPECIAL_FIELD_NAME_PREFIX\n                        Set field name prefix when first character can''t be used as Python\n                        field name (default: `field`)\n  --strip-default-none  Strip default None on fields\n  --union-mode {smart,left_to_right}\n                        Union mode for only pydantic v2 field\n  --use-default         Use default value even if a field is required\n  --use-default-kwarg   Use `default=` instead of a positional argument for Fields that have\n                        default values.\n  --use-field-description\n                        Use schema description to populate field docstring\n\nModel customization:\n  --allow-extra-fields  Deprecated: Allow passing extra fields. This flag is deprecated. Use\n                        `--extra-fields=allow` instead.\n  --allow-population-by-field-name\n                        Allow population by field name\n  --class-name CLASS_NAME\n                        Set class name of root model\n  --collapse-root-models\n                        Models generated with a root-type field will be merged into the\n                        models using that root-type model\n  --disable-appending-item-suffix\n                        Disable appending `Item` suffix to model name in an array\n  --disable-timestamp   Disable timestamp on file headers\n  --enable-faux-immutability\n                        Enable faux immutability\n  --enable-version-header\n                        Enable package version on file headers\n  --extra-fields {allow,ignore,forbid}\n                        Set the generated models to allow, forbid, or ignore extra fields.\n  --frozen-dataclasses  Generate frozen dataclasses (dataclass(frozen=True)). Only applies\n                        to dataclass output.\n  --keep-model-order    Keep generated models'' order\n  --keyword-only        Defined models as keyword only (for example\n                        dataclass(kw_only=True)).\n  --output-datetime-class {datetime,AwareDatetime,NaiveDatetime}\n                        Choose Datetime class between AwareDatetime, NaiveDatetime or\n                        datetime. Each output model has its default mapping (for example\n                        pydantic: datetime, dataclass: str, ...)\n  --parent-scoped-naming\n                        Set name of models defined inline from the parent model\n  --reuse-model         Reuse models on the field when a module has the model with the same\n                        content\n  --target-python-version {3.9,3.10,3.11,3.12,3.13,3.14}\n                        target python version\n  --treat-dot-as-module\n                        treat dotted module names as modules\n  --use-exact-imports   import exact types instead of modules, for example: \"from .foo\n                        import Bar\" instead of \"from . import foo\" with \"foo.Bar\"\n  --use-pendulum        use pendulum instead of datetime\n  --use-schema-description\n                        Use schema description to populate class docstring\n  --use-title-as-name   use titles as class names of models\n\nTemplate customization:\n  --aliases ALIASES     Alias mapping file\n  --custom-file-header CUSTOM_FILE_HEADER\n                        Custom file header\n  --custom-file-header-path CUSTOM_FILE_HEADER_PATH\n                        Custom file header file path\n  --custom-formatters-kwargs CUSTOM_FORMATTERS_KWARGS\n                        A file with kwargs for custom formatters.\n  --custom-template-dir CUSTOM_TEMPLATE_DIR\n                        Custom template directory\n  --encoding ENCODING   The encoding of input and output (default: utf-8)\n  --extra-template-data EXTRA_TEMPLATE_DATA\n                        Extra template data for output models. Input is supposed to be a\n                        json/yaml file. For OpenAPI and Jsonschema the keys are the spec\n                        path of the object, or the name of the object if you want to apply\n                        the template data to multiple objects with the same name. If you are\n                        using another input file type (e.g. GraphQL), the key is the name of\n                        the object. The value is a dictionary of the template data to add.\n  --use-double-quotes   Model generated with double quotes. Single quotes or your black\n                        config skip_string_normalization value will be used without this\n                        option.\n  --wrap-string-literal\n                        Wrap string literal by using black `experimental-string-processing`\n                        option (require black 20.8b0 or later)\n\nOpenAPI-only options:\n  --include-path-parameters\n                        Include path parameters in generated parameter models in addition to\n                        query parameters (Only OpenAPI)\n  --openapi-scopes {schemas,paths,tags,parameters} [{schemas,paths,tags,parameters} ...]\n                        Scopes of OpenAPI model generation (default: schemas)\n  --strict-nullable     Treat default field as a non-nullable field (Only OpenAPI)\n  --use-operation-id-as-name\n                        use operation id of OpenAPI as class names of models\n  --validation          Deprecated: Enable validation (Only OpenAPI). this option is\n                        deprecated. it will be removed in future releases\n\nGeneral options:\n  --debug               show debug message (require \"debug\". `$ pip install ''datamodel-code-\n                        generator[debug]''`)\n  --disable-warnings    disable warnings\n  --no-color            disable colorized output\n  --version             show version\n  -h, --help            show this help message and exit\n</code></pre> <p>Click here to see supported input formats</p>"},{"location":"#related-projects","title":"Related projects","text":""},{"location":"#fastapi-code-generator","title":"fastapi-code-generator","text":"<p>This code generator creates FastAPI app from an openapi file.</p> <p>https://github.com/koxudaxi/fastapi-code-generator</p>"},{"location":"#pydantic-pycharm-plugin","title":"pydantic-pycharm-plugin","text":"<p>A JetBrains PyCharm plugin for <code>pydantic</code>.</p> <p>https://github.com/koxudaxi/pydantic-pycharm-plugin</p>"},{"location":"#pypi","title":"PyPi","text":"<p>https://pypi.org/project/datamodel-code-generator</p>"},{"location":"#license","title":"License","text":"<p>datamodel-code-generator is released under the MIT License. http://www.opensource.org/licenses/mit-license</p>"},{"location":"custom-formatters/","title":"Custom Code Formatters","text":"<p>New features of the <code>datamodel-code-generator</code> it is custom code formatters.</p>"},{"location":"custom-formatters/#usage","title":"Usage","text":"<p>To use the <code>--custom-formatters</code> option, you'll need to pass the module with your formatter. For example</p> <p>your_module.py <pre><code>from datamodel_code_generator.format import CustomCodeFormatter\n\nclass CodeFormatter(CustomCodeFormatter):\n    def apply(self, code: str) -&gt; str:\n        # processed code\n        return ...       \n</code></pre></p> <p>and run the following command</p> <pre><code>$ datamodel-codegen --input {your_input_file} --output {your_output_file} --custom-formatters \"{path_to_your_module}.your_module\"\n</code></pre>"},{"location":"custom_template/","title":"Custom Templates","text":"<p>One of the powerful features of the <code>datamodel-code-generator</code> is the ability to use custom templates with the <code>--custom-template-dir</code> option. This option allows you to provide a directory containing Jinja2 templates for customizing the generated code. In this document, we'll explore how to use this option and provide an example to help you understand its usage.</p>"},{"location":"custom_template/#usage","title":"Usage","text":"<p>To use the <code>--custom-template-dir</code> option, you'll need to pass the directory path containing your custom templates as an argument. The command will look like this:</p> <p><pre><code>$ datamodel-codegen --input {your_input_file} --output {your_output_file} --custom-template-dir {your_custom_template_directory}\n</code></pre> Replace {your_input_file}, {your_output_file}, and {your_custom_template_directory} with the appropriate paths.</p>"},{"location":"custom_template/#example","title":"Example","text":"<p>Let's say you want to generate a custom Python data model from a JSON Schema file called person.json. You want the generated data model to include a custom comment at the top of the file. To achieve this, you can create a custom template using Jinja2.</p> <p>First, create a directory called <code>custom_templates</code> in your project directory. Inside this folder, create another folder called pydantic. Now, inside the <code>pydantic</code> folder, create a new file called <code>BaseModel.jinja2</code> with the following content:</p> <p>custom_templates/pydantic/BaseModel.jinja2 <pre><code># This is a custom comment generated with custom_template!!\n\nclass {{ class_name }}({{ base_class }}):\n{%- for field in fields %}\n    {{ field.name }}: {{ field.type_hint }}\n{%- endfor -%}\n</code></pre></p> <p>This custom template includes the custom comment at the top and replicates the default rendering behavior of the BaseModel.jinja2 template from the Datamodel Code Generator.</p> <p>Now, you can use the --custom-template-dir option to generate the data model with your custom template: <pre><code>$ datamodel-codegen --input person.json --output person.py --custom-template-dir custom_templates\n</code></pre></p> <p>The generated <code>person.py</code> file will now include your custom comment at the top:</p> <p>person.py <pre><code># generated by datamodel-codegen:\n#   filename:  person.json\n#   timestamp: 2023-04-09T05:36:24+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n# This is a custom comment generated with custom_template!!\n\n\nclass Model(BaseModel):\n    name: Optional[str]\n    age: Optional[int]\n</code></pre></p> <p>In this example, we kept it simple, but you can create more complex custom templates by copying the default templates Use the default templates as a reference for understanding the structure and available variables, and customize the code generation process according to your specific requirements.</p>"},{"location":"development-contributing/","title":"Development","text":"<p>Install the package in editable mode:</p> <pre><code>$ git clone git@github.com:koxudaxi/datamodel-code-generator.git\n$ pip install -e datamodel-code-generator\n</code></pre>"},{"location":"development-contributing/#contribute","title":"Contribute","text":"<p>We are waiting for your contributions to <code>datamodel-code-generator</code>.</p>"},{"location":"development-contributing/#how-to-contribute","title":"How to contribute","text":"<pre><code>## 1. Clone your fork repository\n$ git clone git@github.com:&lt;your username&gt;/datamodel-code-generator.git\n$ cd datamodel-code-generator\n\n## 2. Install [uv](https://docs.astral.sh/uv/getting-started/installation/)\n$ curl -LsSf https://astral.sh/uv/install.sh | sh\n\n## 3. Install tox with uv\n$ uv tool install --python-preference only-managed --python 3.13 tox --with tox-uv\n\n## 3. Create developer environment\n$ tox run -e dev\n\n.tox/dev is a Python environment you can use for development purposes\n\n## 4. Create new branch and rewrite code.\n$ git checkout -b new-branch\n\n## 5. Run unittest under Python 3.13 (you should pass all test and coverage should be 100%)\n$ tox run -e 3.13\n\n## 7. Format and lint code (will print errors that cannot be automatically fixed)\n$ tox run -e fix\n\n## 8. Commit and Push...\n</code></pre>"},{"location":"field-constraints/","title":"Field Constraints","text":"<p>An option <code>--field-constraints</code> converts all con* annotations to Field constraint options.</p> <p>Mypy may show error for <code>con*</code> annotations on fields. The option resolves the problem.</p>"},{"location":"field-constraints/#example","title":"Example","text":"<p>Convert simple JSON Schema <code>model.json</code> to pydantic model <code>model.py</code></p> <p>Input JSON Schema</p> <p><code>model.json</code> <pre><code>{\n  \"type\":  \"object\",\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\",\n      \"maxLength\": 64\n    }\n  },\n  \"required\": [\"name\"]\n}\n</code></pre></p>"},{"location":"field-constraints/#without-field-constraints-option","title":"Without <code>--field-constraints</code> option","text":"<pre><code>$ datamodel-codegen --input a.json --input-file-type jsonschema &gt; model.py \n</code></pre> <p>Generated Model</p> <p><code>model.py</code> <pre><code># generated by datamodel-codegen:\n#   filename:  model.json\n#   timestamp: 2020-07-20T15:37:56+00:00\n\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel, constr\n\n\nclass  Model(BaseModel):\n  name: constr(max_length=64)\n</code></pre></p> <p>Run mypy... <pre><code>$ mypy model.py \nmodel.py:3: error: Invalid type comment or annotation\nmodel.py:3: note: Suggestion: use constr[...] instead of constr(...)\nFound 1 error in 1 file (checked 1 source file)\n</code></pre> mypy show errors...</p>"},{"location":"field-constraints/#with-field-constraints-option","title":"With <code>--field-constraints</code> option","text":"<pre><code>$ datamodel-codegen --input model.json --input-file-type jsonschema --field-constraints &gt; model.py \n</code></pre> <p>Generated Model</p> <p><code>model.py</code> <pre><code># generated by datamodel-codegen:\n#   filename:  model.json\n#   timestamp: 2020-07-20T15:47:21+00:00\n\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    name: str = Field(..., max_length=64)\n</code></pre></p> <p>Run mypy... <pre><code>$ mypy model.py \nSuccess: no issues found in 1 source file\n</code></pre></p>"},{"location":"field-constraints/#related-issues","title":"Related issues","text":"<p>https://github.com/samuelcolvin/pydantic/issues/156</p>"},{"location":"formatting/","title":"Formatting","text":"<p>Code generated by <code>datamodel-codegen</code> will be passed through <code>isort</code> and <code>black</code> to produce consistent, well-formatted results. Settings for these tools can be specified in <code>pyproject.toml</code> (located in the output directory, or in some parent of the output directory). Also for black you can disable  skip-string-normalization with using datamodel-codegen option <code>--use-double-quotes</code>,  it will override your black config skip-string-normalization value. Using --use-double-quotes may be useful if you can't use black config. </p>"},{"location":"formatting/#example","title":"Example","text":"<p>pyproject.toml <pre><code>[tool.black]\nskip-string-normalization = true\nline-length = 100\n\n[tool.isort]\nmulti_line_output = 3\ninclude_trailing_comma = true\nforce_grid_wrap = 0\nuse_parentheses = true\nline_length = 100\nknown_first_party = \"kelvin\"\n</code></pre></p> <p>See the Black Project for more information.</p>"},{"location":"graphql/","title":"Generate from GraphQL","text":"<p>The code generator can create pydantic models from GraphQL schema definitions.</p>"},{"location":"graphql/#simple-example","title":"Simple example","text":"<pre><code>$ datamodel-codegen --input schema.graphql --input-file-type graphql --output model.py\n</code></pre> <p>Let's consider a simple GraphQL schema (more details in https://graphql.org/learn/schema/).</p> <p>schema.graphql <pre><code>type Book {\n  id: ID!  \n  title: String\n  author: Author\n}\n\ntype Author {\n  id: ID!  \n  name: String\n  books: [Book]\n}\n\ninput BooksInput {\n    ids: [ID!]!\n}\n\ninput AuthorBooksInput {\n    id: ID!\n}\n\ntype Query {\n  getBooks(input: BooksInput): [Book]\n  getAuthorBooks(input: AuthorBooksInput): [Book]\n}\n</code></pre></p> <p>model.py <pre><code># generated by datamodel-codegen:\n#   filename:  schema.graphql\n#   timestamp: 2023-11-20T17:04:42+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional, TypeAlias\n\nfrom pydantic import BaseModel, Field\nfrom typing_extensions import Literal\n\n# The `Boolean` scalar type represents `true` or `false`.\nBoolean: TypeAlias = bool\n\n\n# The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `\"4\"`) or integer (such as `4`) input value will be accepted as an ID.\nID: TypeAlias = str\n\n\n# The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\nString: TypeAlias = str\n\n\nclass Author(BaseModel):\n    books: Optional[List[Optional[Book]]] = Field(default_factory=list)\n    id: ID\n    name: Optional[String] = None\n    typename__: Optional[Literal['Author']] = Field('Author', alias='__typename')\n\n\nclass Book(BaseModel):\n    author: Optional[Author] = None\n    id: ID\n    title: Optional[String] = None\n    typename__: Optional[Literal['Book']] = Field('Book', alias='__typename')\n\n\nclass AuthorBooksInput(BaseModel):\n    id: ID\n    typename__: Optional[Literal['AuthorBooksInput']] = Field(\n        'AuthorBooksInput', alias='__typename'\n    )\n\n\nclass BooksInput(BaseModel):\n    ids: List[ID]\n    typename__: Optional[Literal['BooksInput']] = Field(\n        'BooksInput', alias='__typename'\n    )\n</code></pre></p>"},{"location":"graphql/#response-deserialization","title":"Response deserialization","text":"<p>For the following response of <code>getAuthorBooks</code> GraphQL query  </p> <p>response.json <pre><code>{\n  \"getAuthorBooks\": [\n    {\n      \"author\": {\n        \"id\": \"51341cdscwef14r13\",\n        \"name\": \"J. K. Rowling\"\n      },\n      \"id\": \"1321dfvrt211wdw\",\n      \"title\": \"Harry Potter and the Prisoner of Azkaban\"\n    },\n    {\n      \"author\": {\n        \"id\": \"51341cdscwef14r13\",\n        \"name\": \"J. K. Rowling\"\n      },\n      \"id\": \"dvsmu12e19xmqacqw9\",\n      \"title\": \"Fantastic Beasts: The Crimes of Grindelwald\"\n    }\n  ]\n}\n</code></pre></p> <p>main.py <pre><code>from model import Book\n\nresponse = {...}\n\nbooks = [\n    Book.parse_obj(book_raw) for book_raw in response[\"getAuthorBooks\"]\n]\nprint(books)\n# [Book(author=Author(books=[], id='51341cdscwef14r13', name='J. K. Rowling', typename__='Author'), id='1321dfvrt211wdw', title='Harry Potter and the Prisoner of Azkaban', typename__='Book'), Book(author=Author(books=[], id='51341cdscwef14r13', name='J. K. Rowling', typename__='Author'), id='dvsmu12e19xmqacqw9', title='Fantastic Beasts: The Crimes of Grindelwald', typename__='Book')]\n</code></pre></p>"},{"location":"graphql/#custom-scalar-types","title":"Custom scalar types","text":"<pre><code>$ datamodel-codegen --input schema.graphql --input-file-type graphql --output model.py --extra-template-data data.json\n</code></pre> <p>schema.graphql <pre><code>scalar Long\n\ntype A {\n  id: ID!\n  duration: Long!\n}\n</code></pre></p> <p>data.json <pre><code>{\n  \"Long\": {\n    \"py_type\": \"int\"\n  }\n}\n</code></pre></p> <p>model.py <pre><code># generated by datamodel-codegen:\n#   filename:  custom-scalar-types.graphql\n#   timestamp: 2019-07-26T00:00:00+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Optional, TypeAlias\n\nfrom pydantic import BaseModel, Field\nfrom typing_extensions import Literal\n\n# The `Boolean` scalar type represents `true` or `false`.\nBoolean: TypeAlias = bool\n\n\n# The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `\"4\"`) or integer (such as `4`) input value will be accepted as an ID.\nID: TypeAlias = str\n\n\nLong: TypeAlias = int\n\n\n# The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\nString: TypeAlias = str\n\n\nclass A(BaseModel):\n    duration: Long\n    id: ID\n    typename__: Optional[Literal['A']] = Field('A', alias='__typename')\n</code></pre></p>"},{"location":"jsondata/","title":"Generate from JSON Data","text":"<p>This code generator can create pydantic models from JSON Data. Under the hood, the generator uses GenSON to create JSON Schema from your input. The generated schema is then processed the in the same manner as JSON Schema input data.</p>"},{"location":"jsondata/#example","title":"Example","text":"<pre><code>$ datamodel-codegen  --input pets.json --input-file-type json --output model.py\n</code></pre> <p>pets.json <pre><code>{\n  \"pets\": [\n    {\n      \"name\": \"dog\",\n      \"age\": 2\n    },\n    {\n      \"name\": \"cat\",\n      \"age\": 1\n    },\n    {\n      \"name\": \"snake\",\n      \"age\": 3,\n      \"nickname\": \"python\"\n    }\n  ],\n  \"status\": 200\n}\n</code></pre></p> <p>model.py <pre><code># generated by datamodel-codegen:\n#   filename:  pets.json\n#   timestamp: 2020-04-27T16:08:21+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    name: str\n    age: int\n    nickname: Optional[str] = None\n\n\nclass Model(BaseModel):\n    pets: List[Pet]\n    status: int\n</code></pre></p>"},{"location":"jsonschema/","title":"Generate from JSON Schema","text":"<p>The code generator can create pydantic models from JSON Schema. See more information about supported JSON Schema data types and features here.</p>"},{"location":"jsonschema/#example","title":"Example","text":"<pre><code>$ datamodel-codegen  --input person.json --input-file-type jsonschema --output model.py\n</code></pre> <p>person.json <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Person\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"firstName\": {\n      \"type\": \"string\",\n      \"description\": \"The person's first name.\"\n    },\n    \"lastName\": {\n      \"type\": \"string\",\n      \"description\": \"The person's last name.\"\n    },\n    \"age\": {\n      \"description\": \"Age in years which must be equal to or greater than zero.\",\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"friends\": {\n      \"type\": \"array\"\n    },\n    \"comment\": {\n      \"type\": \"null\"\n    }\n  }\n}\n</code></pre></p> <p>model.py <pre><code># generated by datamodel-codegen:\n#   filename:  person.json\n#   timestamp: 2020-04-27T16:12:27+00:00\n\nfrom __future__ import annotations\n\nfrom typing import Any, List, Optional\n\nfrom pydantic import BaseModel, Field, conint\n\n\nclass Person(BaseModel):\n    firstName: Optional[str] = Field(None, description=\"The person's first name.\")\n    lastName: Optional[str] = Field(None, description=\"The person's last name.\")\n    age: Optional[conint(ge=0)] = Field(\n        None, description='Age in years which must be equal to or greater than zero.'\n    )\n    friends: Optional[List] = None\n    comment: Optional[Any] = None\n</code></pre></p>"},{"location":"openapi/","title":"Generate from OpenAPI","text":"<p>The code generator can create pydantic models from OpenAPI schema definitions, particularly using the data from the <code>schema</code> field.</p>"},{"location":"openapi/#example","title":"Example","text":"<pre><code>$ datamodel-codegen --input api.yaml --input-file-type openapi --output model.py\n</code></pre> api.yaml <pre>\n<code>\n<pre><code>openapi: \"3.0.0\"\ninfo:\n  version: 1.0.0\n  title: Swagger Petstore\n  license:\n    name: MIT\nservers:\n  - url: http://petstore.swagger.io/v1\npaths:\n  /pets:\n    get:\n      summary: List all pets\n      operationId: listPets\n      tags:\n        - pets\n      parameters:\n        - name: limit\n          in: query\n          description: How many items to return at one time (max 100)\n          required: false\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A paged array of pets\n          headers:\n            x-next:\n              description: A link to the next page of responses\n              schema:\n                type: string\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n    post:\n      summary: Create a pet\n      operationId: createPets\n      tags:\n        - pets\n      responses:\n        '201':\n          description: Null response\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n                x-amazon-apigateway-integration:\n                  uri:\n                    Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n                  passthroughBehavior: when_no_templates\n                  httpMethod: POST\n                  type: aws_proxy\n  /pets/{petId}:\n    get:\n      summary: Info for a specific pet\n      operationId: showPetById\n      tags:\n        - pets\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          description: The id of the pet to retrieve\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Pets\"\n        default:\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Error\"\n    x-amazon-apigateway-integration:\n      uri:\n        Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PythonVersionFunction.Arn}/invocations\n      passthroughBehavior: when_no_templates\n      httpMethod: POST\n      type: aws_proxy\ncomponents:\n  schemas:\n    Pet:\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        tag:\n          type: string\n    Pets:\n      type: array\n      items:\n        $ref: \"#/components/schemas/Pet\"\n    Error:\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n    apis:\n      type: array\n      items:\n        type: object\n        properties:\n          apiKey:\n            type: string\n            description: To be used as a dataset parameter value\n          apiVersionNumber:\n            type: string\n            description: To be used as a version parameter value\n          apiUrl:\n            type: string\n            format: uri\n            description: \"The URL describing the dataset's fields\"\n          apiDocumentationUrl:\n            type: string\n            format: uri\n            description: A URL to the API console for each API\n</code></pre>\n</code>\n</pre> <p>model.py <pre><code># generated by datamodel-codegen:\n#   filename:  api.yaml\n#   timestamp: 2020-06-02T05:28:24+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import AnyUrl, BaseModel, Field\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass Api(BaseModel):\n    apiKey: Optional[str] = Field(\n        None, description='To be used as a dataset parameter value'\n    )\n    apiVersionNumber: Optional[str] = Field(\n        None, description='To be used as a version parameter value'\n    )\n    apiUrl: Optional[AnyUrl] = Field(\n        None, description=\"The URL describing the dataset's fields\"\n    )\n    apiDocumentationUrl: Optional[AnyUrl] = Field(\n        None, description='A URL to the API console for each API'\n    )\n\n\nclass Apis(BaseModel):\n    __root__: List[Api]\n</code></pre></p>"},{"location":"pyproject_toml/","title":"pyproject.toml","text":"<p>datamodel-code-generator has a lot of command-line options.</p> <p>The options are supported on <code>pyproject.toml</code>.</p> <p>Example <code>pyproject.toml</code>: <pre><code>[tool.datamodel-codegen]\nfield-constraints = true\nsnake-case-field = true\nstrip-default-none = false\ntarget-python-version = \"3.7\"\n</code></pre></p>"},{"location":"supported-data-types/","title":"Supported Input Formats","text":"<p>This code generator supports the following input formats:</p> <ul> <li>OpenAPI 3 (YAML/JSON, OpenAPI Data Type);</li> <li>JSON Schema (JSON Schema Core /JSON Schema Validation);</li> <li>JSON/YAML Data (it will be converted to JSON Schema);</li> <li>Python dictionary (it will be converted to JSON Schema);</li> <li>GraphQL schema (GraphQL Schemas and Types);</li> </ul>"},{"location":"supported-data-types/#implemented-data-types-and-features","title":"Implemented data types and features","text":"<p>Below are the data types and features recognized by datamodel-code-generator for OpenAPI 3 and JSON Schema.</p>"},{"location":"supported-data-types/#data-types","title":"Data Types","text":"<ul> <li>string (supported keywords: pattern/minLength/maxLength)</li> <li>number (supported keywords: maximum/exclusiveMaximum/minimum/exclusiveMinimum/multipleOf)</li> <li>integer (supported keywords: maximum/exclusiveMaximum/minimum/exclusiveMinimum/multipleOf)</li> <li>boolean</li> <li>array</li> <li>object</li> </ul>"},{"location":"supported-data-types/#string-formats","title":"String Formats","text":"<ul> <li>date</li> <li>datetime</li> <li>time</li> <li>password</li> <li>email</li> <li>idn-email</li> <li>path</li> <li>uuid (uuid1/uuid2/uuid3/uuid4/uuid5)</li> <li>ipv4</li> <li>ipv6</li> <li>hostname</li> <li>decimal</li> <li>uri</li> </ul>"},{"location":"supported-data-types/#other-schema","title":"Other schema","text":"<ul> <li>enum (as enum.Enum or typing.Literal)</li> <li>allOf (as Multiple inheritance)</li> <li>anyOf (as typing.Union)</li> <li>oneOf (as typing.Union)</li> <li>$ref (http extra is required when resolving $ref for remote files.)</li> <li>$id (for JSONSchema)</li> </ul>"},{"location":"using_as_module/","title":"Using datamode-code-generator as a Module","text":"<p>datamodel-code-generator is a CLI tool, but it can also be used as a module.</p> <p>You can call this code-generator in your python code.</p>"},{"location":"using_as_module/#how-to-use-it-as-module","title":"How to use it as module","text":"<p>You can generate models with <code>datamodel_code_generator.generate</code> using parameters that match the arguments provided to the CLI tool. The generated files can be written to and read from the <code>Path</code> object supplied to output.</p> <p>In the below example, we use a file in a <code>TemporaryDirectory</code> to store our output.</p>"},{"location":"using_as_module/#installation","title":"Installation","text":"<pre><code>pip install 'datamodel-code-generator[http]'\n</code></pre>"},{"location":"using_as_module/#example","title":"Example","text":"<pre><code>from pathlib import Path\nfrom tempfile import TemporaryDirectory\nfrom datamodel_code_generator import InputFileType, generate\nfrom datamodel_code_generator import DataModelType\n\njson_schema: str = \"\"\"{\n    \"type\": \"object\",\n    \"properties\": {\n        \"number\": {\"type\": \"number\"},\n        \"street_name\": {\"type\": \"string\"},\n        \"street_type\": {\"type\": \"string\",\n                        \"enum\": [\"Street\", \"Avenue\", \"Boulevard\"]\n                        }\n    }\n}\"\"\"\n\nwith TemporaryDirectory() as temporary_directory_name:\n    temporary_directory = Path(temporary_directory_name)\n    output = Path(temporary_directory / 'model.py')\n    generate(\n        json_schema,\n        input_file_type=InputFileType.JsonSchema,\n        input_filename=\"example.json\",\n        output=output,\n        # set up the output model types\n        output_model_type=DataModelType.PydanticV2BaseModel,\n    )\n    model: str = output.read_text()\nprint(model)\n</code></pre> <p>The result of <code>print(model)</code>: <pre><code># generated by datamodel-codegen:\n#   filename:  example.json\n#   timestamp: 2020-12-21T08:01:06+00:00\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass StreetType(Enum):\n    Street = 'Street'\n    Avenue = 'Avenue'\n    Boulevard = 'Boulevard'\n\n\nclass Model(BaseModel):\n    number: Optional[float] = None\n    street_name: Optional[str] = None\n    street_type: Optional[StreetType] = None\n</code></pre></p> <p>Also, you can call parser directly</p> <pre><code>from datamodel_code_generator import DataModelType, PythonVersion\nfrom datamodel_code_generator.model import get_data_model_types\nfrom datamodel_code_generator.parser.jsonschema import JsonSchemaParser\n\njson_schema: str = \"\"\"{\n    \"type\": \"object\",\n    \"properties\": {\n        \"number\": {\"type\": \"number\"},\n        \"street_name\": {\"type\": \"string\"},\n        \"street_type\": {\"type\": \"string\",\n                        \"enum\": [\"Street\", \"Avenue\", \"Boulevard\"]\n                        }\n    }\n}\"\"\"\n\n\ndata_model_types = get_data_model_types(\n    DataModelType.PydanticV2BaseModel,\n    target_python_version=PythonVersion.PY_311\n)\nparser = JsonSchemaParser(\n   json_schema,\n   data_model_type=data_model_types.data_model,\n   data_model_root_type=data_model_types.root_model,\n   data_model_field_type=data_model_types.field_model,\n   data_type_manager_type=data_model_types.data_type_manager,\n   dump_resolve_reference_action=data_model_types.dump_resolve_reference_action,\n                       )\nresult = parser.parse()\nprint(result)\n ```\n\nThe result of `print(model)`:\n```python\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass StreetType(Enum):\n    Street = 'Street'\n    Avenue = 'Avenue'\n    Boulevard = 'Boulevard'\n\n\nclass Model(BaseModel):\n    number: Optional[float] = None\n    street_name: Optional[str] = None\n    street_type: Optional[StreetType] = None\n</code></pre>"},{"location":"using_as_module/#why-doesnt-datamodel_code_generatorgenerate-return-a-string","title":"Why doesn't <code>datamodel_code_generator.generate</code> return a string?","text":"<p>The above example schema only generates a single python module, but a single schema may generate multiple modules. There is no way to represent these modules as a single string, so the <code>generate</code> method returns <code>None</code>.</p> <p>Note that the output parameter can take any <code>Path</code> object, which includes both file and directory paths. If a file name is provided and multiple modules are generated, <code>generate</code> will raise a <code>datamodel_code_gen.Error</code> exception.</p> <p>If multiple modules are generated, you will need to walk through the supplied output directory to find all of them.</p>"},{"location":"what_is_the_difference_between_v1_and_v2/","title":"What is the difference between pydantic v1 and v2 output model?","text":""},{"location":"what_is_the_difference_between_v1_and_v2/#summary","title":"Summary","text":"<p>datamodel-code-generator supports Pydantic v1 and v2 as output model type.</p> <p>Pydantic v2 is a major release with many breaking changes. See the migration guide for more information: https://docs.pydantic.dev/2.0/migration/</p>"},{"location":"what_is_the_difference_between_v1_and_v2/#whats-changes-in-v2-output","title":"What's changes in v2 output?","text":""},{"location":"what_is_the_difference_between_v1_and_v2/#__root__-field-aka-custom-root-types","title":"<code>__root__</code> field (a.k.a Custom Root Types)","text":"<p><code>__root__</code> field (a.k.a Custom Root Types) is removed in pydantic v2. The model is changed to RootModel</p>"},{"location":"what_is_the_difference_between_v1_and_v2/#pydanticfield","title":"pydantic.Field","text":"<p>https://docs.pydantic.dev/2.0/migration/#changes-to-pydanticfield</p> <ul> <li>const -&gt; removed</li> <li>min_items (use min_length instead)</li> <li>max_items (use max_length instead)</li> <li>unique_items -&gt; removed and the list type will be replaced by <code>typing.Set</code>. this feature is discussed in https://github.com/pydantic/pydantic-core/issues/296</li> <li>allow_mutation (use frozen instead)</li> <li>regex (use pattern instead)</li> </ul>"},{"location":"what_is_the_difference_between_v1_and_v2/#model-config","title":"Model Config","text":"<ul> <li><code>pydantic.Config</code> -&gt; <code>pydantic.ConfigDict</code> </li> <li>allow_mutation \u2014&gt; frozen (inverse value for getting same behavior).</li> <li>allow_population_by_field_name \u2192 populate_by_name</li> </ul>"}]}