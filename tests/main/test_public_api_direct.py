"""Direct public API usage tests for generate and parser classes."""

from __future__ import annotations

from typing import TYPE_CHECKING

import pytest

from datamodel_code_generator import DataModelType, GenerateConfig, InputFileType, generate
from datamodel_code_generator.config import ParserConfig
from datamodel_code_generator.parser.graphql import GraphQLParser
from datamodel_code_generator.parser.jsonschema import JsonSchemaParser
from datamodel_code_generator.parser.openapi import OpenAPIParser
from tests.conftest import assert_output
from tests.main.conftest import (
    EXPECTED_GRAPHQL_PATH,
    EXPECTED_JSON_SCHEMA_PATH,
    EXPECTED_OPENAPI_PATH,
    GRAPHQL_DATA_PATH,
    JSON_SCHEMA_DATA_PATH,
    OPEN_API_DATA_PATH,
)

if TYPE_CHECKING:
    from pathlib import Path

GENERATE_CASES = [
    pytest.param(
        JSON_SCHEMA_DATA_PATH / "person.json",
        EXPECTED_JSON_SCHEMA_PATH / "general.py",
        {
            "input_file_type": InputFileType.JsonSchema,
            "output_model_type": DataModelType.PydanticBaseModel,
        },
        id="jsonschema_person",
    ),
    pytest.param(
        OPEN_API_DATA_PATH / "additional_properties.yaml",
        EXPECTED_OPENAPI_PATH / "additional_properties.py",
        {
            "input_file_type": InputFileType.OpenAPI,
            "output_model_type": DataModelType.PydanticBaseModel,
            "extra_fields": "forbid",
        },
        id="openapi_additional_properties",
    ),
    pytest.param(
        GRAPHQL_DATA_PATH / "simple-star-wars.graphql",
        EXPECTED_GRAPHQL_PATH / "simple_star_wars.py",
        {
            "input_file_type": InputFileType.GraphQL,
            "output_model_type": DataModelType.PydanticBaseModel,
        },
        id="graphql_simple_star_wars",
    ),
]


PARSER_CASES = [
    pytest.param(
        JsonSchemaParser,
        JSON_SCHEMA_DATA_PATH / "person.json",
        EXPECTED_JSON_SCHEMA_PATH / "general.py",
        {
            "use_standard_collections": True,
            "use_union_operator": True,
        },
        id="jsonschema_person",
    ),
    pytest.param(
        OpenAPIParser,
        OPEN_API_DATA_PATH / "additional_properties.yaml",
        EXPECTED_OPENAPI_PATH / "additional_properties.py",
        {
            "extra_fields": "forbid",
            "use_standard_collections": True,
            "use_union_operator": True,
        },
        id="openapi_additional_properties",
    ),
    pytest.param(
        GraphQLParser,
        GRAPHQL_DATA_PATH / "simple-star-wars.graphql",
        EXPECTED_GRAPHQL_PATH / "simple_star_wars.py",
        {
            "use_standard_collections": True,
            "use_union_operator": True,
        },
        id="graphql_simple_star_wars",
    ),
]


@pytest.mark.parametrize("use_config", [False, True])
@pytest.mark.parametrize(("input_path", "expected_path", "options"), GENERATE_CASES)
def test_generate_public_api_direct(
    use_config: bool,
    input_path: Path,
    expected_path: Path,
    options: dict[str, object],
) -> None:
    """Validate public generate() API with config and options."""
    if use_config:
        config = GenerateConfig(**options)
        output = generate(input_path, config=config)
    else:
        output = generate(input_path, **options)
    assert isinstance(output, str)
    normalized_output = output.rstrip("\n") + "\n"
    assert_output(normalized_output, expected_path)


@pytest.mark.parametrize("use_config", [False, True])
@pytest.mark.parametrize(("parser_cls", "input_path", "expected_path", "options"), PARSER_CASES)
def test_parser_public_api_direct(
    use_config: bool,
    parser_cls: type[object],
    input_path: Path,
    expected_path: Path,
    options: dict[str, object],
) -> None:
    """Validate public Parser API with config and options."""
    if use_config:
        config = ParserConfig(**options)
        parser = parser_cls(input_path, config=config)
    else:
        parser = parser_cls(input_path, **options)
    output = parser.parse()
    expected_text = expected_path.read_text(encoding="utf-8")
    expected_lines = expected_text.splitlines()
    if expected_lines[:1] == ["# generated by datamodel-codegen:"]:
        header_end = 4 if len(expected_lines) > 3 and not expected_lines[3] else 3
        expected_lines = expected_lines[header_end:]
    expected_body = "\n".join(expected_lines)
    if expected_text.endswith("\n"):
        expected_body += "\n"

    def _strip_update_forward_refs(text: str) -> str:
        lines = text.splitlines()
        while lines and lines[-1].endswith(".update_forward_refs()"):
            lines.pop()
            while lines and not lines[-1]:
                lines.pop()
        body = "\n".join(lines)
        if text.endswith("\n"):
            body += "\n"
        return body

    normalized_output = output.rstrip("\n") + "\n"
    normalized_expected = expected_body.rstrip("\n") + "\n"
    normalized_output = _strip_update_forward_refs(normalized_output)
    normalized_expected = _strip_update_forward_refs(normalized_expected)
    assert normalized_output == normalized_expected
